<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-jvm学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T08:11:29.879Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP"><strong>解密JVM【黑马程序员出品】</strong></a>教学视频的笔记（转载<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/07/03/JVM%E5%AD%A6%E4%B9%A0/#2%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95">nyimac</a>，做一条懒🐕，这个人做的不错）</p>
<h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" alt="img"></a></p>
<h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" alt="img"></a></p>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>线程私有<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void method1() &#123;</span><br><span class="line">		method2(1, 2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int method2(int a, int b) &#123;</span><br><span class="line">		int c &#x3D; a + b;</span><br><span class="line">		return c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" alt="img"></a></p>
<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul>
<li>垃圾回收是否涉及栈内存？<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li>栈内存的分配越大越好吗？<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>
</ul>
</li>
<li>方法内的局部变量是否是线程安全的？<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>
</ul>
</li>
</ul>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p><strong>发生原因</strong></p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>每个栈帧<strong>所占用过大</strong></li>
</ul>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li>
<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li>
</ul>
</li>
</ul>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>
<h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p>
<p><strong>jmap</strong></p>
<p><strong>jconsole</strong></p>
<p><strong>jvirsalvm</strong></p>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" alt="img"></a></p>
<h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul>
<li>1.8以前会导致<strong>永久代</strong>内存溢出</li>
<li>1.8以后会导致<strong>元空间</strong>内存溢出</li>
</ul>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p><strong>通过反编译来查看类的信息</strong></p>
<ul>
<li><p>获得对应类的.class文件</p>
<ul>
<li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" alt="img"></a></p>
</li>
<li><p>输入 <strong>javac 对应类的绝对路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.java</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>输入完成后，对应的目录下就会出现类的.class文件</p>
</li>
</ul>
</li>
<li><p>在控制台输入 javap -v 类的绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>然后能在控制台看到反编译以后类的信息了</p>
<ul>
<li><p>类的基本信息</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" alt="img"></a></p>
</li>
<li><p>常量池</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" alt="img"></a></p>
</li>
<li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong></li>
</ul>
</li>
</ul>
<h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p>
<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>
<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
<p>用来放字符串对象且里面的<strong>元素不重复</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String a &#x3D; &quot;a&quot;; </span><br><span class="line">		String b &#x3D; &quot;b&quot;;</span><br><span class="line">		String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
<p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
<p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
<p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String a &#x3D; &quot;a&quot;;</span><br><span class="line">		String b &#x3D; &quot;b&quot;;</span><br><span class="line">		String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">		&#x2F;&#x2F;拼接字符串对象来创建新的字符串</span><br><span class="line">		String ab2 &#x3D; a+b; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	 Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">String ab2 &#x3D; a+b;</span><br><span class="line">&#x2F;&#x2F;结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span><br><span class="line">System.out.println(ab &#x3D;&#x3D; ab2);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StringTableStudy &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String a &#x3D; &quot;a&quot;;</span><br><span class="line">		String b &#x3D; &quot;b&quot;;</span><br><span class="line">		String ab &#x3D; &quot;ab&quot;;</span><br><span class="line">		String ab2 &#x3D; a+b;</span><br><span class="line">		&#x2F;&#x2F;使用拼接字符串的方法创建字符串</span><br><span class="line">		String ab3 &#x3D; &quot;a&quot; + &quot;b&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>反编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 	  Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;6, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        &#x2F;&#x2F;ab3初始化时直接从串池中获取字符串</span><br><span class="line">        29: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">        31: astore        5</span><br><span class="line">        33: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li>
<li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>
</ul>
<h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p><strong>例1</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="line">		String str &#x3D; new String(&quot;a&quot;) + new String(&quot;b&quot;);</span><br><span class="line">		&#x2F;&#x2F;调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span><br><span class="line">		String st2 &#x3D; str.intern();</span><br><span class="line">		&#x2F;&#x2F;给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span><br><span class="line">		String str3 &#x3D; &quot;ab&quot;;</span><br><span class="line">		&#x2F;&#x2F;因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span><br><span class="line">		System.out.println(str &#x3D;&#x3D; st2);</span><br><span class="line">		System.out.println(str &#x3D;&#x3D; str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>例2</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span><br><span class="line">		String str3 &#x3D; &quot;ab&quot;;</span><br><span class="line">        &#x2F;&#x2F;&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span><br><span class="line">		String str &#x3D; new String(&quot;a&quot;) + new String(&quot;b&quot;);</span><br><span class="line">        &#x2F;&#x2F;此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span><br><span class="line">		String str2 &#x3D; str.intern();</span><br><span class="line">        &#x2F;&#x2F;false</span><br><span class="line">		System.out.println(str &#x3D;&#x3D; str2);</span><br><span class="line">        &#x2F;&#x2F;false</span><br><span class="line">		System.out.println(str &#x3D;&#x3D; str3);</span><br><span class="line">        &#x2F;&#x2F;true</span><br><span class="line">		System.out.println(str2 &#x3D;&#x3D; str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p>
<h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize&#x3D;xxxx</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以通过<strong>intern方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" alt="img"></a></p>
<p><strong>使用了DirectBuffer</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" alt="img"></a></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<p>通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通过ByteBuffer申请1M的直接内存</span><br><span class="line">ByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(_1M);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</span><br><span class="line">    return new DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>DirectByteBuffer类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(int cap) &#123;   &#x2F;&#x2F; package-private</span><br><span class="line">   </span><br><span class="line">    super(-1, 0, cap, cap);</span><br><span class="line">    boolean pa &#x3D; VM.isDirectMemoryPageAligned();</span><br><span class="line">    int ps &#x3D; Bits.pageSize();</span><br><span class="line">    long size &#x3D; Math.max(1L, (long)cap + (pa ? ps : 0));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    long base &#x3D; 0;</span><br><span class="line">    try &#123;</span><br><span class="line">        base &#x3D; unsafe.allocateMemory(size); &#x2F;&#x2F;申请内存</span><br><span class="line">    &#125; catch (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        throw x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (byte) 0);</span><br><span class="line">    if (pa &amp;&amp; (base % ps !&#x3D; 0)) &#123;</span><br><span class="line">        &#x2F;&#x2F; Round up to page boundary</span><br><span class="line">        address &#x3D; base + ps - (base &amp; (ps - 1));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        address &#x3D; base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner &#x3D; Cleaner.create(this, new Deallocator(base, size, cap)); &#x2F;&#x2F;通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span><br><span class="line">    att &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void clean() &#123;</span><br><span class="line">       if (remove(this)) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               this.thunk.run(); &#x2F;&#x2F;调用run方法</span><br><span class="line">           &#125; catch (final Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                   public Void run() &#123;</span><br><span class="line">                       if (System.err !&#x3D; null) &#123;</span><br><span class="line">                           (new Error(&quot;Cleaner terminated abnormally&quot;, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(1);</span><br><span class="line">                       return null;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应对象的run方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    if (address &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; Paranoia</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); &#x2F;&#x2F;释放直接内存中占用的内存</span><br><span class="line">    address &#x3D; 0;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" alt="img"></a></p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
<li>可以作为GC Root的对象<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
</li>
</ul>
<h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" alt="img"></a></p>
<h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
<ul>
<li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li>
</ul>
<h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>
<ul>
<li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final int _4M &#x3D; 4*1024*1024;</span><br><span class="line">		&#x2F;&#x2F;使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br><span class="line">		List&lt;SoftReference&lt;byte[]&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		SoftReference&lt;byte[]&gt; ref&#x3D; new SoftReference&lt;&gt;(new byte[_4M]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		final int _4M &#x3D; 4*1024*1024;</span><br><span class="line">		&#x2F;&#x2F;使用引用队列，用于移除引用为空的软引用对象</span><br><span class="line">		ReferenceQueue&lt;byte[]&gt; queue &#x3D; new ReferenceQueue&lt;&gt;();</span><br><span class="line">		&#x2F;&#x2F;使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span><br><span class="line">		List&lt;SoftReference&lt;byte[]&gt;&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		SoftReference&lt;byte[]&gt; ref&#x3D; new SoftReference&lt;&gt;(new byte[_4M]);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;遍历引用队列，如果有元素，则移除</span><br><span class="line">		Reference&lt;? extends byte[]&gt; poll &#x3D; queue.poll();</span><br><span class="line">		while(poll !&#x3D; null) &#123;</span><br><span class="line">			&#x2F;&#x2F;引用队列不为空，则从集合中移除该元素</span><br><span class="line">			list.remove(poll);</span><br><span class="line">			&#x2F;&#x2F;移动到引用队列中的下一个元素</span><br><span class="line">			poll &#x3D; queue.poll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p>
<ul>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p>
<ul>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li><p>软引用和弱引用</p>
<p>可以配合</p>
<p>引用队列</p>
<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li><p>虚引用和终结器引用</p>
<p>必须配合</p>
<p>引用队列</p>
<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" alt="img"></a></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" alt="img"></a></p>
<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" alt="img"></a></p>
<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" alt="img"></a></p>
<h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" alt="img"></a></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" alt="img"></a></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" alt="img"></a></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" alt="img"></a></p>
<p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul>
<li>单线程</li>
<li>内存较小，个人电脑（CPU核数较少）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" alt="img"></a></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>
<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" alt="img"></a></p>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
<h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" alt="img"></a></p>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" alt="img"></a></p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" alt="img"></a></p>
<h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" alt="img"></a></p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li>会STW</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" alt="img"></a></p>
<h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" alt="img"></a></p>
<h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记</li>
<li><strong>拷贝</strong>存活</li>
</ul>
<p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" alt="img"></a></p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p>
<ul>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
<h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" alt="img"></a></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" alt="img"></a></p>
<h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" alt="img"></a></p>
<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" alt="img"></a></p>
<h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与String.intern的区别<ul>
<li>intern关注的是字符串对象</li>
<li>字符串去重关注的是char[]</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" alt="img"></a></p>
<h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以根据参数去查询具体的信息</p>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS G1 ZGC</li>
<li>ParallelGC</li>
<li>Zing</li>
</ul>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul>
<li>新生代的特点<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li>新生代内存越大越好么？<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul>
<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>
<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" alt="img"></a></p>
<h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p>
<p>方法：</p>
<ul>
<li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li>
<li>java终端中，执行javac X:…\XXX.java</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910155135.png" alt="img"></a></p>
<p>以下是字节码文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09 </span><br><span class="line">0000020 00 16 00 17 08 00 18 0a 00 19 00 1a 07 00 1b 07 </span><br><span class="line">0000040 00 1c 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29 </span><br><span class="line">0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e </span><br><span class="line">0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 12 4c 6f 63 </span><br><span class="line">0000120 61 6c 56 61 72 69 61 62 6c 65 54 61 62 6c 65 01 </span><br><span class="line">0000140 00 04 74 68 69 73 01 00 1d 4c 63 6e 2f 69 74 63 </span><br><span class="line">0000160 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c 6f </span><br><span class="line">0000200 57 6f 72 6c 64 3b 01 00 04 6d 61 69 6e 01 00 16 </span><br><span class="line">0000220 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 </span><br><span class="line">0000240 69 6e 67 3b 29 56 01 00 04 61 72 67 73 01 00 13 </span><br><span class="line">0000260 5b 4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 </span><br><span class="line">0000300 6e 67 3b 01 00 10 4d 65 74 68 6f 64 50 61 72 61 </span><br><span class="line">0000320 6d 65 74 65 72 73 01 00 0a 53 6f 75 72 63 65 46 </span><br><span class="line">0000340 69 6c 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64</span><br><span class="line">0000360 2e 6a 61 76 61 0c 00 07 00 08 07 00 1d 0c 00 1e </span><br><span class="line">0000400 00 1f 01 00 0b 68 65 6c 6c 6f 20 77 6f 72 6c 64 </span><br><span class="line">0000420 07 00 20 0c 00 21 00 22 01 00 1b 63 6e 2f 69 74 </span><br><span class="line">0000440 63 61 73 74 2f 6a 76 6d 2f 74 35 2f 48 65 6c 6c </span><br><span class="line">0000460 6f 57 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 </span><br><span class="line">0000500 6e 67 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 </span><br><span class="line">0000520 2f 6c 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f </span><br><span class="line">0000540 75 74 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 </span><br><span class="line">0000560 69 6e 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 </span><br><span class="line">0000600 61 2f 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d </span><br><span class="line">0000620 01 00 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a </span><br><span class="line">0000640 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b </span><br><span class="line">0000660 29 56 00 21 00 05 00 06 00 00 00 00 00 02 00 01 </span><br><span class="line">0000700 00 07 00 08 00 01 00 09 00 00 00 2f 00 01 00 01 </span><br><span class="line">0000720 00 00 00 05 2a b7 00 01 b1 00 00 00 02 00 0a 00 </span><br><span class="line">0000740 00 00 06 00 01 00 00 00 04 00 0b 00 00 00 0c 00 </span><br><span class="line">0000760 01 00 00 00 05 00 0c 00 0d 00 00 00 09 00 0e 00 </span><br><span class="line">0001000 0f 00 02 00 09 00 00 00 37 00 02 00 01 00 00 00 </span><br><span class="line">0001020 09 b2 00 02 12 03 b6 00 04 b1 00 00 00 02 00 0a </span><br><span class="line">0001040 00 00 00 0a 00 02 00 00 00 06 00 08 00 07 00 0b </span><br><span class="line">0001060 00 00 00 0c 00 01 00 00 00 09 00 10 00 11 00 00 </span><br><span class="line">0001100 00 12 00 00 00 05 01 00 10 00 00 00 01 00 13 00 </span><br><span class="line">0001120 00 00 02 00 14 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u4 			 magic</span><br><span class="line">u2             minor_version;    </span><br><span class="line">u2             major_version;    </span><br><span class="line">u2             constant_pool_count;    </span><br><span class="line">cp_info        constant_pool[constant_pool_count-1];    </span><br><span class="line">u2             access_flags;    </span><br><span class="line">u2             this_class;    </span><br><span class="line">u2             super_class;   </span><br><span class="line">u2             interfaces_count;    </span><br><span class="line">u2             interfaces[interfaces_count];   </span><br><span class="line">u2             fields_count;    </span><br><span class="line">field_info     fields[fields_count];   </span><br><span class="line">u2             methods_count;    </span><br><span class="line">method_info    methods[methods_count];    </span><br><span class="line">u2             attributes_count;    </span><br><span class="line">attribute_info attributes[attributes_count];</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>34H = 52，代表JDK8</p>
<h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p>
<p>…略</p>
<h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopy</span><br><span class="line">F:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.class</span><br><span class="line">Classfile &#x2F;F:&#x2F;Thread_study&#x2F;src&#x2F;com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1.class</span><br><span class="line">  Last modified 2020-6-6; size 434 bytes</span><br><span class="line">  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e</span><br><span class="line">  Compiled from &quot;Demo1.java&quot;</span><br><span class="line">public class com.nyima.JVM.day5.Demo1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 &#x3D; Methodref          #6.#15         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 &#x3D; Fieldref           #16.#17        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">   #3 &#x3D; String             #18            &#x2F;&#x2F; hello world</span><br><span class="line">   #4 &#x3D; Methodref          #19.#20        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">   #5 &#x3D; Class              #21            &#x2F;&#x2F; com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1</span><br><span class="line">   #6 &#x3D; Class              #22            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object</span><br><span class="line">   #7 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">   #8 &#x3D; Utf8               ()V</span><br><span class="line">   #9 &#x3D; Utf8               Code</span><br><span class="line">  #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">  #11 &#x3D; Utf8               main</span><br><span class="line">  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #13 &#x3D; Utf8               SourceFile</span><br><span class="line">  #14 &#x3D; Utf8               Demo1.java</span><br><span class="line">  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #16 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;System</span><br><span class="line">  #17 &#x3D; NameAndType        #24:#25        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #18 &#x3D; Utf8               hello world</span><br><span class="line">  #19 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #20 &#x3D; NameAndType        #27:#28        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">  #21 &#x3D; Utf8               com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1</span><br><span class="line">  #22 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">  #24 &#x3D; Utf8               out</span><br><span class="line">  #25 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">  #26 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">  #27 &#x3D; Utf8               println</span><br><span class="line">  #28 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public com.nyima.JVM.day5.Demo1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String hello world</span><br><span class="line">         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line"></span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">        line 10: 8</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3_1 &#123;    </span><br><span class="line">	public static void main(String[] args) &#123;        </span><br><span class="line">		int a &#x3D; 10;        </span><br><span class="line">		int b &#x3D; Short.MAX_VALUE + 1;        </span><br><span class="line">		int c &#x3D; a + b;        </span><br><span class="line">		System.out.println(c);   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>常量池载入运行时常量池</strong></p>
<p>常量池也属于方法区，只不过这里单独提出来了</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" alt="img"></a></p>
<p><strong>方法字节码载入方法区</strong></p>
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" alt="img"></a></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<ul>
<li><p>将一个 byte 压入操作数栈</p>
<p>（其长度会补齐 4 个字节），类似的指令还有</p>
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 10 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p>
<p><strong>invokevirtual 5</strong></p>
<p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p>
<p>执行完毕，弹出栈帧</p>
<p>清除 main 操作数栈内容</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p>
<p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i&#x3D;0;</span><br><span class="line">		int x&#x3D;0;</span><br><span class="line">		while(i&lt;10) &#123;</span><br><span class="line">			x &#x3D; x++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(x); &#x2F;&#x2F;接过为0</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1	&#x2F;&#x2F;操作数栈分配2个空间，局部变量表分配3个空间</span><br><span class="line">        0: iconst_0	&#x2F;&#x2F;准备一个常数0</span><br><span class="line">        1: istore_1	&#x2F;&#x2F;将常数0放入局部变量表的1号槽位 i&#x3D;0</span><br><span class="line">        2: iconst_0	&#x2F;&#x2F;准备一个常数0</span><br><span class="line">        3: istore_2	&#x2F;&#x2F;将常数0放入局部变量的2号槽位 x&#x3D;0	</span><br><span class="line">        4: iload_1		&#x2F;&#x2F;将局部变量表1号槽位的数放入操作数栈中</span><br><span class="line">        5: bipush        10	&#x2F;&#x2F;将数字10放入操作数栈中，此时操作数栈中有2个数</span><br><span class="line">        7: if_icmpge     21	&#x2F;&#x2F;比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span><br><span class="line">       10: iload_2		&#x2F;&#x2F;将局部变量2号槽位的数放入操作数栈中，放入的值是0</span><br><span class="line">       11: iinc          2, 1	&#x2F;&#x2F;将局部变量2号槽位的数加1，自增后，槽位中的值为1</span><br><span class="line">       14: istore_2	&#x2F;&#x2F;将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0</span><br><span class="line">       15: iinc          1, 1 &#x2F;&#x2F;1号槽位的值自增1</span><br><span class="line">       18: goto          4 &#x2F;&#x2F;跳转到第4条指令</span><br><span class="line">       21: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       24: iload_2</span><br><span class="line">       25: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">       28: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	static int i &#x3D; 10;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		i &#x3D; 20;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static &#123;</span><br><span class="line">		i &#x3D; 30;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		System.out.println(i); &#x2F;&#x2F;结果为30</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack&#x3D;1, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: putstatic     #3                  &#x2F;&#x2F; Field i:I</span><br><span class="line">         5: bipush        20</span><br><span class="line">         7: putstatic     #3                  &#x2F;&#x2F; Field i:I</span><br><span class="line">        10: bipush        30</span><br><span class="line">        12: putstatic     #3                  &#x2F;&#x2F; Field i:I</span><br><span class="line">        15: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">	private String a &#x3D; &quot;s1&quot;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		b &#x3D; 20;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int b &#x3D; 10;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		a &#x3D; &quot;s2&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Demo4(String a, int b) &#123;</span><br><span class="line">		this.a &#x3D; a;</span><br><span class="line">		this.b &#x3D; b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Demo4 d &#x3D; new Demo4(&quot;s3&quot;, 30);</span><br><span class="line">		System.out.println(d.a);</span><br><span class="line">		System.out.println(d.b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;3, args_size&#x3D;3</span><br><span class="line">        0: aload_0</span><br><span class="line">        1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        4: aload_0</span><br><span class="line">        5: ldc           #2                  &#x2F;&#x2F; String s1</span><br><span class="line">        7: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">       10: aload_0</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: putfield      #4                  &#x2F;&#x2F; Field b:I</span><br><span class="line">       16: aload_0</span><br><span class="line">       17: bipush        10</span><br><span class="line">       19: putfield      #4                  &#x2F;&#x2F; Field b:I</span><br><span class="line">       22: aload_0</span><br><span class="line">       23: ldc           #5                  &#x2F;&#x2F; String s2</span><br><span class="line">       25: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">       &#x2F;&#x2F;原始构造方法在最后执行</span><br><span class="line">       28: aload_0</span><br><span class="line">       29: aload_1</span><br><span class="line">       30: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line">       33: aload_0</span><br><span class="line">       34: iload_2</span><br><span class="line">       35: putfield      #4                  &#x2F;&#x2F; Field b:I</span><br><span class="line">       38: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public Demo5() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void test1() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private final void test2() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void test3() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void test4() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Demo5 demo5 &#x3D; new Demo5();</span><br><span class="line">		demo5.test1();</span><br><span class="line">		demo5.test2();</span><br><span class="line">		demo5.test3();</span><br><span class="line">		Demo5.test4();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>
<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">         0: new           #2                  &#x2F;&#x2F; class com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo5 </span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         7: astore_1</span><br><span class="line">         8: aload_1</span><br><span class="line">         9: invokespecial #4                  &#x2F;&#x2F; Method test1:()V</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: invokespecial #5                  &#x2F;&#x2F; Method test2:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #6                  &#x2F;&#x2F; Method test3:()V</span><br><span class="line">        20: invokestatic  #7                  &#x2F;&#x2F; Method test4:()V</span><br><span class="line">        23: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong></li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			i &#x3D; 20;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          12</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: return</span><br><span class="line">     &#x2F;&#x2F;多出来一个异常表</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125;catch (ArithmeticException e) &#123;</span><br><span class="line">			i &#x3D; 20;</span><br><span class="line">		&#125;catch (Exception e) &#123;</span><br><span class="line">			i &#x3D; 30;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应的字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        5: goto          19</span><br><span class="line">        8: astore_2</span><br><span class="line">        9: bipush        20</span><br><span class="line">       11: istore_1</span><br><span class="line">       12: goto          19</span><br><span class="line">       15: astore_2</span><br><span class="line">       16: bipush        30</span><br><span class="line">       18: istore_1</span><br><span class="line">       19: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5     8   Class java&#x2F;lang&#x2F;ArithmeticException</span><br><span class="line">            2     5    15   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li>
</ul>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 0;</span><br><span class="line">		try &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			i &#x3D; 20;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 30;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;4, args_size&#x3D;1</span><br><span class="line">        0: iconst_0</span><br><span class="line">        1: istore_1</span><br><span class="line">        &#x2F;&#x2F;try块</span><br><span class="line">        2: bipush        10</span><br><span class="line">        4: istore_1</span><br><span class="line">        &#x2F;&#x2F;try块执行完后，会执行finally    </span><br><span class="line">        5: bipush        30</span><br><span class="line">        7: istore_1</span><br><span class="line">        8: goto          27</span><br><span class="line">       &#x2F;&#x2F;catch块     </span><br><span class="line">       11: astore_2 &#x2F;&#x2F;异常信息放入局部变量表的2号槽位</span><br><span class="line">       12: bipush        20</span><br><span class="line">       14: istore_1</span><br><span class="line">       &#x2F;&#x2F;catch块执行完后，会执行finally        </span><br><span class="line">       15: bipush        30</span><br><span class="line">       17: istore_1</span><br><span class="line">       18: goto          27</span><br><span class="line">       &#x2F;&#x2F;出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span><br><span class="line">       21: astore_3</span><br><span class="line">       22: bipush        30</span><br><span class="line">       24: istore_1</span><br><span class="line">       25: aload_3</span><br><span class="line">       26: athrow  &#x2F;&#x2F;抛出异常</span><br><span class="line">       27: return</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     5    11   Class java&#x2F;lang&#x2F;Exception</span><br><span class="line">            2     5    21   any</span><br><span class="line">           11    15    21   any</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
<h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; Demo3.test();</span><br><span class="line">        &#x2F;&#x2F;结果为20</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int test() &#123;</span><br><span class="line">		int i;</span><br><span class="line">		try &#123;</span><br><span class="line">			i &#x3D; 10;</span><br><span class="line">			return i;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 20;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0</span><br><span class="line">        3: iload_0</span><br><span class="line">        4: istore_1  &#x2F;&#x2F;暂存返回值</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0</span><br><span class="line">        8: iload_0</span><br><span class="line">        9: ireturn	&#x2F;&#x2F;ireturn会返回操作数栈顶的整型值20</span><br><span class="line">       &#x2F;&#x2F;如果出现异常，还是会执行finally块中的内容，没有抛出异常</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: iload_0</span><br><span class="line">       15: ireturn	&#x2F;&#x2F;这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     5    10   any</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li>
<li>所以<strong>不要在finally中进行返回操作</strong></li>
</ul>
<h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int i &#x3D; Demo3.test();</span><br><span class="line">      &#x2F;&#x2F;最终结果为20</span><br><span class="line">      System.out.println(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static int test() &#123;</span><br><span class="line">      int i;</span><br><span class="line">      try &#123;</span><br><span class="line">         i &#x3D; 10;</span><br><span class="line">         &#x2F;&#x2F;这里应该会抛出异常</span><br><span class="line">         i &#x3D; i&#x2F;0;</span><br><span class="line">         return i;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         i &#x3D; 20;</span><br><span class="line">         return i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>会发现打印结果为20，并未抛出异常</p>
<h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; Demo4.test();</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static int test() &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		try &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			i &#x3D; 20;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;0</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_0 &#x2F;&#x2F;赋值给i 10</span><br><span class="line">        3: iload_0	&#x2F;&#x2F;加载到操作数栈顶</span><br><span class="line">        4: istore_1 &#x2F;&#x2F;加载到局部变量表的1号位置</span><br><span class="line">        5: bipush        20</span><br><span class="line">        7: istore_0 &#x2F;&#x2F;赋值给i 20</span><br><span class="line">        8: iload_1 &#x2F;&#x2F;加载局部变量表1号位置的数10到操作数栈</span><br><span class="line">        9: ireturn &#x2F;&#x2F;返回操作数栈顶元素 10</span><br><span class="line">       10: astore_2</span><br><span class="line">       11: bipush        20</span><br><span class="line">       13: istore_0</span><br><span class="line">       14: aload_2 &#x2F;&#x2F;加载异常</span><br><span class="line">       15: athrow &#x2F;&#x2F;抛出异常</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            3     5    10   any</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int i &#x3D; 10;</span><br><span class="line">		Lock lock &#x3D; new Lock();</span><br><span class="line">		synchronized (lock) &#123;</span><br><span class="line">			System.out.println(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Lock&#123;&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">        0: bipush        10</span><br><span class="line">        2: istore_1</span><br><span class="line">        3: new           #2                  &#x2F;&#x2F; class com&#x2F;nyima&#x2F;JVM&#x2F;day06&#x2F;Lock</span><br><span class="line">        6: dup &#x2F;&#x2F;复制一份，放到操作数栈顶，用于构造函数消耗</span><br><span class="line">        7: invokespecial #3                  &#x2F;&#x2F; Method com&#x2F;nyima&#x2F;JVM&#x2F;day06&#x2F;Lock.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       10: astore_2 &#x2F;&#x2F;剩下的一份放到局部变量表的2号位置</span><br><span class="line">       11: aload_2 &#x2F;&#x2F;加载到操作数栈</span><br><span class="line">       12: dup &#x2F;&#x2F;复制一份，放到操作数栈，用于加锁时消耗</span><br><span class="line">       13: astore_3 &#x2F;&#x2F;将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span><br><span class="line">       14: monitorenter &#x2F;&#x2F;加锁</span><br><span class="line">       &#x2F;&#x2F;锁住后代码块中的操作    </span><br><span class="line">       15: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       18: iload_1</span><br><span class="line">       19: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V</span><br><span class="line">       &#x2F;&#x2F;加载局部变量表中三号槽位对象的引用，用于解锁    </span><br><span class="line">       22: aload_3    </span><br><span class="line">       23: monitorexit &#x2F;&#x2F;解锁</span><br><span class="line">       24: goto          34</span><br><span class="line">       &#x2F;&#x2F;异常操作    </span><br><span class="line">       27: astore        4</span><br><span class="line">       29: aload_3</span><br><span class="line">       30: monitorexit &#x2F;&#x2F;解锁</span><br><span class="line">       31: aload         4</span><br><span class="line">       33: athrow</span><br><span class="line">       34: return</span><br><span class="line">     &#x2F;&#x2F;可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">           15    24    27   any</span><br><span class="line">           27    31    27   any</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>经过编译期优化后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;</span><br><span class="line">   &#x2F;&#x2F;这个无参构造器是java编译器帮我们加上的</span><br><span class="line">   public Candy1() &#123;</span><br><span class="line">      &#x2F;&#x2F;即调用父类 Object 的无参构造方法，即调用 java&#x2F;lang&#x2F;Object.&quot; &lt;init&gt;&quot;:()V</span><br><span class="line">      super();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Integer x &#x3D; 1;</span><br><span class="line">      int y &#x3D; x;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>转换过程如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;基本类型赋值给包装类型，称为装箱</span><br><span class="line">      Integer x &#x3D; Integer.valueOf(1);</span><br><span class="line">      &#x2F;&#x2F;包装类型赋值给基本类型，称谓拆箱</span><br><span class="line">      int y &#x3D; x.intValue();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">      list.add(10);</span><br><span class="line">      Integer x &#x3D; list.get(0);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">       0: new           #2                  &#x2F;&#x2F; class java&#x2F;util&#x2F;ArrayList</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;ArrayList.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: bipush        10</span><br><span class="line">      11: invokestatic  #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Integer.valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;</span><br><span class="line">      &#x2F;&#x2F;这里进行了泛型擦除，实际调用的是add(Objcet o)</span><br><span class="line">      14: invokeinterface #5,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.add:(Ljava&#x2F;lang&#x2F;Object;)Z</span><br><span class="line"></span><br><span class="line">      19: pop</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: iconst_0</span><br><span class="line">      &#x2F;&#x2F;这里也进行了泛型擦除，实际调用的是get(Object o)   </span><br><span class="line">      22: invokeinterface #6,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.get:(I)Ljava&#x2F;lang&#x2F;Object;</span><br><span class="line">&#x2F;&#x2F;这里进行了类型转换，将Object转换成了Integer</span><br><span class="line">      27: checkcast     #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Integer</span><br><span class="line">      30: astore_2</span><br><span class="line">      31: return</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x &#x3D; (Integer) list.get(0);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x &#x3D; (Integer) list.get(0).intValue();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public static void foo(String... args) &#123;</span><br><span class="line">      &#x2F;&#x2F;将args赋值给arr，可以看出String...实际就是String[] </span><br><span class="line">      String[] arr &#x3D; args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(&quot;hello&quot;, &quot;world&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">   public Demo4 &#123;&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">   public static void foo(String[] args) &#123;</span><br><span class="line">      String[] arr &#x3D; args;</span><br><span class="line">      System.out.println(arr.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;数组赋初值的简化写法也是一种语法糖。</span><br><span class="line">		int[] arr &#x3D; &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">		for(int x : arr) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>编译器会帮我们转换为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">		for(int i&#x3D;0; i&lt;arr.length; ++i) &#123;</span><br><span class="line">			int x &#x3D; arr[i];</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      for (Integer x : list) &#123;</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;</span><br><span class="line">    public Demo5 &#123;&#125;</span><br><span class="line">    </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);</span><br><span class="line">      &#x2F;&#x2F;获得该集合的迭代器</span><br><span class="line">      Iterator&lt;Integer&gt; iterator &#x3D; list.iterator();</span><br><span class="line">      while(iterator.hasNext()) &#123;</span><br><span class="line">         Integer x &#x3D; iterator.next();</span><br><span class="line">         System.out.println(x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str &#x3D; &quot;hello&quot;;</span><br><span class="line">      switch (str) &#123;</span><br><span class="line">         case &quot;hello&quot; :</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case &quot;world&quot; :</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在编译器中执行的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Demo6 &#123;</span><br><span class="line">   public Demo6() &#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      String str &#x3D; &quot;hello&quot;;</span><br><span class="line">      int x &#x3D; -1;</span><br><span class="line">      &#x2F;&#x2F;通过字符串的hashCode+value来判断是否匹配</span><br><span class="line">      switch (str.hashCode()) &#123;</span><br><span class="line">         &#x2F;&#x2F;hello的hashCode</span><br><span class="line">         case 99162322 :</span><br><span class="line">            &#x2F;&#x2F;再次比较，因为字符串的hashCode有可能相等</span><br><span class="line">            if(str.equals(&quot;hello&quot;)) &#123;</span><br><span class="line">               x &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         &#x2F;&#x2F;world的hashCode</span><br><span class="line">         case 11331880 :</span><br><span class="line">            if(str.equals(&quot;world&quot;)) &#123;</span><br><span class="line">               x &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;用第二个switch在进行输出判断</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 0:</span><br><span class="line">            System.out.println(&quot;h&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;w&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>过程说明：</p>
<ul>
<li>在编译期间，单个的switch被分为了两个<ul>
<li>第一个用来匹配字符串，并给x赋值<ul>
<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>
<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>
</ul>
</li>
<li>第二个用来根据x的值来决定输出语句</li>
</ul>
</li>
</ul>
<h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex &#x3D; SEX.MALE;</span><br><span class="line">      switch (sex) &#123;</span><br><span class="line">         case MALE:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case FEMALE:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>编译器中执行的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Demo7 &#123;</span><br><span class="line">   &#x2F;**     </span><br><span class="line">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><br><span class="line">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><br><span class="line">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><br><span class="line">    * 即 MALE 的 ordinal()&#x3D;0，FEMALE 的 ordinal()&#x3D;1     </span><br><span class="line">    *&#x2F; </span><br><span class="line">   static class $MAP &#123;</span><br><span class="line">      &#x2F;&#x2F;数组大小即为枚举元素个数，里面存放了case用于比较的数字</span><br><span class="line">      static int[] map &#x3D; new int[2];</span><br><span class="line">      static &#123;</span><br><span class="line">         &#x2F;&#x2F;ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span><br><span class="line">         map[SEX.MALE.ordinal()] &#x3D; 1;</span><br><span class="line">         map[SEX.FEMALE.ordinal()] &#x3D; 2;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      SEX sex &#x3D; SEX.MALE;</span><br><span class="line">      &#x2F;&#x2F;将对应位置枚举元素的值赋给x，用于case操作</span><br><span class="line">      int x &#x3D; $MAP.map[sex.ordinal()];</span><br><span class="line">      switch (x) &#123;</span><br><span class="line">         case 1:</span><br><span class="line">            System.out.println(&quot;man&quot;);</span><br><span class="line">            break;</span><br><span class="line">         case 2:</span><br><span class="line">            System.out.println(&quot;woman&quot;);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            break;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum SEX &#123;</span><br><span class="line">   MALE, FEMALE;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final class Sex extends Enum&lt;Sex&gt; &#123;   </span><br><span class="line">   &#x2F;&#x2F;对应枚举类中的元素</span><br><span class="line">   public static final Sex MALE;    </span><br><span class="line">   public static final Sex FEMALE;    </span><br><span class="line">   private static final Sex[] $VALUES;</span><br><span class="line">   </span><br><span class="line">    static &#123;       </span><br><span class="line">    	&#x2F;&#x2F;调用构造函数，传入枚举元素的值及ordinal</span><br><span class="line">    	MALE &#x3D; new Sex(&quot;MALE&quot;, 0);    </span><br><span class="line">        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 1);   </span><br><span class="line">        $VALUES &#x3D; new Sex[]&#123;MALE, FEMALE&#125;; </span><br><span class="line">   &#125;</span><br><span class="line"> 	</span><br><span class="line">   &#x2F;&#x2F;调用父类中的方法</span><br><span class="line">    private Sex(String name, int ordinal) &#123;     </span><br><span class="line">        super(name, ordinal);    </span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    public static Sex[] values() &#123;  </span><br><span class="line">        return $VALUES.clone();  </span><br><span class="line">    &#125;</span><br><span class="line">    public static Sex valueOf(String name) &#123; </span><br><span class="line">        return Enum.valueOf(Sex.class, name);  </span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(&quot;running...&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>转换后的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F;用额外创建的类来创建匿名内部类对象</span><br><span class="line">      Runnable runnable &#x3D; new Demo8$1();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建了一个额外的类，实现了Runnable接口</span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   public Demo8$1() &#123;&#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(&quot;running...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x &#x3D; 1;</span><br><span class="line">      Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>转化后代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Demo8 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      int x &#x3D; 1;</span><br><span class="line">      Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class Demo8$1 implements Runnable &#123;</span><br><span class="line">   &#x2F;&#x2F;多创建了一个变量</span><br><span class="line">   int val$x;</span><br><span class="line">   &#x2F;&#x2F;变为了有参构造器</span><br><span class="line">   public Demo8$1(int x) &#123;</span><br><span class="line">      this.val$x &#x3D; x;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void run() &#123;</span><br><span class="line">      System.out.println(val$x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li><p>将类的字节码载入</p>
<p>方法区</p>
<p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p>
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p>
</li>
<li><p>加载和链接可能是<strong>交替运行</strong>的</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p>
<ul>
<li>先获得要查看的进程ID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>打开HSDB</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" alt="img"></a></p>
<ul>
<li>定位需要的进程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" alt="img"></a></p>
<p><strong>解析的含义</strong></p>
<p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">      ClassLoader loader &#x3D; Demo1.class.getClassLoader();</span><br><span class="line">      &#x2F;&#x2F;只加载不解析</span><br><span class="line">      Class&lt;?&gt; c &#x3D; loader.loadClass(&quot;com.nyima.JVM.day8.C&quot;);</span><br><span class="line">      &#x2F;&#x2F;用于阻塞主线程</span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C &#123;</span><br><span class="line">   D d &#x3D; new D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>打开HSDB<ul>
<li>可以看到此时只加载了类C</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p>
<p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p>
<ul>
<li><p>解析以后，会将常量池中的符号引用解析为直接引用</p>
<ul>
<li>可以看到，此时已加载并解析了类C和类D</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p>
</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>
</ul>
<p><strong>注意</strong></p>
<p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，<strong>显示为null</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody></table>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>loadClass源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 首先查找该类是否已经被该类加载器加载过了</span><br><span class="line">        Class&lt;?&gt; c &#x3D; findLoadedClass(name);</span><br><span class="line">        &#x2F;&#x2F;如果没有被加载过</span><br><span class="line">        if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">            long t0 &#x3D; System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F;看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span><br><span class="line">                if (parent !&#x3D; null) &#123;</span><br><span class="line">                    c &#x3D; parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;看是否被启动类加载器加载过</span><br><span class="line">                    c &#x3D; findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#x2F;&#x2F; ClassNotFoundException thrown if class not found</span><br><span class="line">                &#x2F;&#x2F; from the non-null parent class loader</span><br><span class="line">                &#x2F;&#x2F;捕获异常，但不做任何处理</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F;如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span><br><span class="line">                &#x2F;&#x2F;然后让应用类加载器去找classpath下找该类</span><br><span class="line">                long t1 &#x3D; System.nanoTime();</span><br><span class="line">                c &#x3D; findClass(name);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 记录时间</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
</ul>
<h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
<h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<p><strong>全局逃逸（GlobalEscape）</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void doSomething() &#123;  </span><br><span class="line">        &#x2F;&#x2F; to do something  </span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123; </span><br><span class="line">		&#x2F;&#x2F;这里调用了add2方法</span><br><span class="line">        return add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    private int add2(int x1, int x2) &#123;  </span><br><span class="line">        return x1 + x2;  </span><br><span class="line">    &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>方法调用被替换后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private int add4(int x1, int x2, int x3, int x4) &#123;  </span><br><span class="line">    	&#x2F;&#x2F;被替换为了方法本身</span><br><span class="line">        return x1 + x2 + x3 + x4;  </span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Reflect1 &#123;</span><br><span class="line">   public static void foo() &#123;</span><br><span class="line">      System.out.println(&quot;foo...&quot;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">      Method foo &#x3D; Demo3.class.getMethod(&quot;foo&quot;);</span><br><span class="line">      for(int i &#x3D; 0; i&lt;&#x3D;16; i++) &#123;</span><br><span class="line">         foo.invoke(null);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<p>invoke方法源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@CallerSensitive</span><br><span class="line">public Object invoke(Object obj, Object... args)</span><br><span class="line">    throws IllegalAccessException, IllegalArgumentException,</span><br><span class="line">       InvocationTargetException</span><br><span class="line">&#123;</span><br><span class="line">    if (!override) &#123;</span><br><span class="line">        if (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller &#x3D; Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span><br><span class="line">    MethodAccessor ma &#x3D; methodAccessor;             &#x2F;&#x2F; read volatile</span><br><span class="line">    if (ma &#x3D;&#x3D; null) &#123;</span><br><span class="line">        ma &#x3D; acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    return ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" alt="img"></a></p>
<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<p>NativeMethodAccessorImpl源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class NativeMethodAccessorImpl extends MethodAccessorImpl &#123;</span><br><span class="line">    private final Method method;</span><br><span class="line">    private DelegatingMethodAccessorImpl parent;</span><br><span class="line">    private int numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        this.method &#x3D; var1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><br><span class="line">	&#x2F;&#x2F;如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span><br><span class="line">    public Object invoke(Object var1, Object[] var2) throws IllegalArgumentException, InvocationTargetException &#123;</span><br><span class="line">        if (++this.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(this.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 &#x3D; (MethodAccessorImpl)(new MethodAccessorGenerator()).generateMethod(this.method.getDeclaringClass(), this.method.getName(), this.method.getParameterTypes(), this.method.getReturnType(), this.method.getExceptionTypes(), this.method.getModifiers());</span><br><span class="line">            this.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invoke0(this.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void setParent(DelegatingMethodAccessorImpl var1) &#123;</span><br><span class="line">        this.parent &#x3D; var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static native Object invoke0(Method var0, Object var1, Object[] var2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;ReflectionFactory.inflationThreshold()方法的返回值</span><br><span class="line">private static int inflationThreshold &#x3D; 15;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>一开始if条件不满足，就会调用本地方法invoke0</li>
<li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul>
<li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" alt="img"></a></p>
<h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>内存模型内容详见 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/04/17/JUC/#%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98">JAVA并发 第四章</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/" data-id="cknmwaipg0009j4ub2d09aumj" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-juc学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T08:11:13.000Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/">juc学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010"><strong>黑马java并发编程教程</strong></a>教学视频的笔记（转载<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">nyimac</a>，再转一篇学习学习，等看一遍《java并发编程的艺术》后，再整理自己的学习note吧）</p>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li>
</ul>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p>
<p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p>
<ul>
<li>通用目的寄存器</li>
<li>浮点寄存器</li>
<li>程序计数器</li>
<li>用户栈</li>
<li>状态寄存器</li>
<li>内核栈</li>
<li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li>
</ul>
<p><strong>进程切换和线程切换的主要区别</strong></p>
<p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p>
<p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p>
<p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p>
<p><strong>为什么TLB能加快访问速度</strong></p>
<p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p>
<h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p>
<p>并行是多个CPU同时处理不同的线程。</p>
<p>引用 Rob Pike 的一段描述：</p>
<ul>
<li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li>
</ul>
<h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<ol>
<li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li>
<li>结论</li>
</ol>
<ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li>
<li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li>
</ul>
<p>结论</p>
<ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li>
</ol>
<h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreateThread &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread myThread &#x3D; new MyThread();</span><br><span class="line">        &#x2F;&#x2F; 启动线程</span><br><span class="line">		myThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;my thread running...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建线程任务</span><br><span class="line">		Runnable r &#x3D; new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		&#x2F;&#x2F;将Runnable对象传给Thread</span><br><span class="line">		Thread t &#x3D; new Thread(r);</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CreateThread2 &#123;</span><br><span class="line">   private static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         System.out.println(&quot;my runnable running...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line">      Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p>
<h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p>
<p>所以方法二中的代码可以被简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建线程任务</span><br><span class="line">		Runnable r &#x3D; () -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;直接写方法体即可</span><br><span class="line">			System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">			System.out.println(&quot;Hello Thread&quot;);</span><br><span class="line">		&#125;;</span><br><span class="line">		&#x2F;&#x2F;将Runnable对象传给Thread</span><br><span class="line">		Thread t &#x3D; new Thread(r);</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以再Runnable上使用Alt+Enter</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" alt="img"></a></p>
<h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p>
<ul>
<li>方法1 是把线程和任务合并在了一起</li>
<li>方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">	public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;需要传入一个Callable对象</span><br><span class="line">		FutureTask&lt;Integer&gt; task &#x3D; new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public Integer call() throws Exception &#123;</span><br><span class="line">				System.out.println(&quot;线程执行!&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">				return 100;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread r1 &#x3D; new Thread(task, &quot;t2&quot;);</span><br><span class="line">		r1.start();</span><br><span class="line">		&#x2F;&#x2F;获取线程中方法执行后的返回结果</span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UseFutureTask &#123;</span><br><span class="line">   public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyCall());</span><br><span class="line">      Thread thread &#x3D; new Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      &#x2F;&#x2F; 获得线程运行后的返回值</span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCall implements Callable&lt;String&gt; &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String call() throws Exception &#123;</span><br><span class="line">      return &quot;hello world&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p>
<h3 id="（常用）查看进程线程方法⭐"><a href="#（常用）查看进程线程方法⭐" class="headerlink" title="（常用）查看进程线程方法⭐"></a>（常用）查看进程线程方法⭐</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png" alt="img"></a></p>
<h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p>
<ul>
<li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p>
<h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol>
<li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p>
</li>
<li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行</p>
</li>
<li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;休眠一秒</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#x2F;&#x2F;休眠一分钟</span><br><span class="line">TimeUnit.MINUTES.sleep(1);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol>
<li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
</li>
<li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
</li>
<li><p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); &#x2F;&#x2F;设置为优先级最高</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread();</span><br><span class="line">&#x2F;&#x2F;等待thread线程执行结束</span><br><span class="line">thread.join();</span><br><span class="line">&#x2F;&#x2F;最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="line">thread.join(1000);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为true。</li>
<li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于查看打断标记，返回值被boolean类型</span><br><span class="line">t1.isInterrupted();Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">    if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" alt="img"></a></p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断当前线程是否被打断了</span><br><span class="line">					if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">                        &#x2F;&#x2F;终止线程执行</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						&#x2F;&#x2F;如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br><span class="line">						Thread.currentThread().interrupt();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul>
<li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li>
<li>suspend（暂停线程）/resume（恢复线程）方法</li>
</ul>
<h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将线程设置为守护线程, 默认为false</span><br><span class="line">monitor.setDaemon(true); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>守护线程的应用</strong></p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li>
</ul>
<h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" alt="img"></a></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" alt="img"></a></p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>
<h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int counter &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">static void increment() </span><br><span class="line">&#x2F;&#x2F; 临界区 </span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void decrement() </span><br><span class="line">&#x2F;&#x2F; 临界区 </span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	&#x2F;&#x2F;临界区</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int counter &#x3D; 0; </span><br><span class="line">&#x2F;&#x2F;创建一个公共对象，作为对象锁的对象</span><br><span class="line">static final Object room &#x3D; new Object();</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;    </span><br><span class="line">	Thread t1 &#x3D; new Thread(() -&gt; &#123;        </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5000; i++) &#123;            </span><br><span class="line">        synchronized (room) &#123;     </span><br><span class="line">        counter++;            </span><br><span class="line">       	 &#125;       </span><br><span class="line"> 	   &#125;    </span><br><span class="line">    &#125;, &quot;t1&quot;);</span><br><span class="line"> </span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; &#123;       </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5000; i++) &#123;         </span><br><span class="line">            synchronized (room) &#123;            </span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, &quot;t2&quot;);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(&quot;&#123;&#125;&quot;,counter); </span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul>
<li><p>加在成员方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">	&#x2F;&#x2F;在方法上加上synchronized关键字</span><br><span class="line">	public synchronized void test() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;等价于</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		synchronized(this) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>加在静态方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">	&#x2F;&#x2F;在静态方法上加上synchronized关键字</span><br><span class="line">	public synchronized static void test() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;等价于</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		synchronized(Demo.class) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>但局部变量引用的对象则未必 （要看该对象</p>
<p>是否被共享</p>
<p>且被执行了读写操作）</p>
<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
<li><p>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" alt="img"></a></p>
<ul>
<li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" alt="img"></a></p>
<ul>
<li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" alt="img"></a></p>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuﬀer</li>
<li>Random</li>
<li>Vector （List的线程安全实现类）</li>
<li>Hashtable （Hash的线程安全实现类）</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p>
<ul>
<li>它们的每个方法是原子的（都被加上了synchronized）</li>
<li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" alt="img"></a></p>
<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p>
<p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p>
<p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" alt="img"></a></p>
<ul>
<li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p>
<ul>
<li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p>
</li>
<li><p>如果</p>
<p>已经绑定</p>
<p>，则会去查询该Monitor是否已经有了Owner</p>
<ul>
<li>如果没有，则Owner与将当前线程绑定</li>
<li>如果有，则放入EntryList，进入阻塞状态(blocked)</li>
</ul>
</li>
</ul>
</li>
<li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li>
<li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li>
</ul>
</li>
</ul>
<h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" alt="img"></a></p>
<h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p>
<ul>
<li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" alt="img"></a></p>
</li>
<li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" alt="img"></a></p>
<ul>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" alt="img"></a></p>
<h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul>
<li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" alt="img"></a></p>
<ul>
<li><p>此时便会给对象加上重量级锁（使用Monitor）</p>
<ul>
<li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p>
</li>
<li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p>
<ul>
<li>第一种情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" alt="img"></a></p>
<ul>
<li>第二种情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" alt="img"></a></p>
<h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p>
<p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" alt="img"></a></p>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul>
<li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li>
<li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li>
<li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li>
<li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" alt="img"></a></p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li>
<li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li>
</ul>
<h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p>
<ul>
<li>调用对象的hashCode方法</li>
<li>多个线程使用该对象</li>
<li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li>
</ul>
<h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul>
<li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul>
<li>重偏向会重置Thread ID</li>
</ul>
</li>
<li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li>
</ul>
<h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p>
<h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" alt="img"></a></p>
<ul>
<li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p>
</li>
<li><p>处于BLOCKED和WAITING状态的线程都为</p>
<p>阻塞</p>
<p>状态，CPU都不会分给他们时间片。但是有所区别：</p>
<ul>
<li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li>
<li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li>
</ul>
</li>
<li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</p>
</li>
</ul>
<p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">	final static Object LOCK &#x3D; new Object();</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;只有在对象被锁住后才能调用wait方法</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			LOCK.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p>
<ul>
<li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li>
<li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li>
<li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>阻塞状态都为<strong>TIMED_WAITING</strong></li>
</ul>
<h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p>
<ul>
<li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li>
</ul>
<p><strong>使用wait/notify需要注意什么</strong></p>
<ul>
<li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synchronized (LOCK) &#123;</span><br><span class="line">	while(&#x2F;&#x2F;不满足条件，一直等待，避免虚假唤醒) &#123;</span><br><span class="line">		LOCK.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;满足条件后再运行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized (LOCK) &#123;</span><br><span class="line">	&#x2F;&#x2F;唤醒所有等待线程</span><br><span class="line">	LOCK.notifyAll();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" alt="img"></a></p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String hello &#x3D; &quot;hello thread!&quot;;</span><br><span class="line">		Guarded guarded &#x3D; new Guarded();</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;想要得到结果&quot;);</span><br><span class="line">			synchronized (guarded) &#123;</span><br><span class="line">				System.out.println(&quot;结果是：&quot;+guarded.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到结果&quot;);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;设置结果&quot;);</span><br><span class="line">			synchronized (guarded) &#123;</span><br><span class="line">				guarded.setResponse(hello);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Guarded &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 要返回的结果</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private Object response;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;优雅地使用wait&#x2F;notify</span><br><span class="line">	public Object getResponse() &#123;</span><br><span class="line">		&#x2F;&#x2F;如果返回结果为空就一直等待，避免虚假唤醒</span><br><span class="line">		while(response &#x3D;&#x3D; null) &#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					this.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return response;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setResponse(Object response) &#123;</span><br><span class="line">		this.response &#x3D; response;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			&#x2F;&#x2F;唤醒休眠的线程</span><br><span class="line">			this.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Guarded&#123;&quot; +</span><br><span class="line">				&quot;response&#x3D;&quot; + response +</span><br><span class="line">				&#39;&#125;&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>带超时判断的暂停</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public Object getResponse(long time) &#123;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			&#x2F;&#x2F;获取开始时间</span><br><span class="line">			long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">			&#x2F;&#x2F;用于保存已经等待了的时间</span><br><span class="line">			long passedTime &#x3D; 0;</span><br><span class="line">			while(response &#x3D;&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;看经过的时间-开始时间是否超过了指定时间</span><br><span class="line">				long waitTime &#x3D; time -passedTime;</span><br><span class="line">				if(waitTime &lt;&#x3D; 0) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">                   	&#x2F;&#x2F;等待剩余时间</span><br><span class="line">					this.wait(waitTime);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;获取当前时间</span><br><span class="line">				passedTime &#x3D; System.currentTimeMillis()-currentTime		</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return response;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base &#x3D; System.currentTimeMillis();</span><br><span class="line">        long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay &#x3D; millis - now;</span><br><span class="line">                if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;暂停线程运行</span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;恢复线程运行</span><br><span class="line">LockSupport.unpark(thread);Copy</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Thread thread &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;park&quot;);</span><br><span class="line">            &#x2F;&#x2F;暂停线程运行</span><br><span class="line">			LockSupport.park();</span><br><span class="line">			System.out.println(&quot;resume&quot;);</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		System.out.println(&quot;unpark&quot;);</span><br><span class="line">    	&#x2F;&#x2F;恢复线程运行</span><br><span class="line">		LockSupport.unpark(thread);</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p>
<ul>
<li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li>
<li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li>
<li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li>
<li><strong>park不会释放锁</strong>，而wait会释放锁</li>
</ul>
<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p>
<ul>
<li><p>先调用park再调用unpark时</p>
<ul>
<li><p>先调用park</p>
<ul>
<li>线程运行时，会将Park对象中的**_counter的值设为0**；</li>
<li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li>
<li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li>
</ul>
</li>
<li><p>然后调用unpark</p>
<ul>
<li><p>调用unpark方法后，会将counter的值设置为1</p>
</li>
<li><p>去唤醒阻塞队列cond中的线程</p>
</li>
<li><p>线程继续运行并将counter的值设为0</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" alt="img"></a></p>
<ul>
<li>先调用unpark，再调用park<ul>
<li>调用unpark<ul>
<li>会将counter设置为1（运行时0）</li>
</ul>
</li>
<li>调用park方法<ul>
<li>查看counter是否为0</li>
<li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" alt="img"></a></p>
<h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" alt="img"></a></p>
<h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul>
<li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li><p>当前线程</p>
<p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p>
<ul>
<li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li><p>当前线程调用 t.join</p>
<p>(long n</p>
<p>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li>
</ul>
<h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p>
<h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class BigRoom &#123;</span><br><span class="line">    &#x2F;&#x2F;额外创建对象来作为锁</span><br><span class="line">	private final Object studyRoom &#x3D; new Object();</span><br><span class="line">	private final Object bedRoom &#x3D; new Object();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p>
<p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		final Object A &#x3D; new Object();</span><br><span class="line">		final Object B &#x3D; new Object();</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			synchronized (A) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (B) &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			synchronized (B) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (A) &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul>
<li>互斥条件<ul>
<li>在一段时间内，一种资源只能被一个进程所使用</li>
</ul>
</li>
<li>请求和保持条件<ul>
<li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
</ul>
</li>
<li>不可抢占条件<ul>
<li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
</ul>
</li>
<li>循环等待条件<ul>
<li>发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
</li>
</ul>
<h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul>
<li><p>jps+jstack ThreadID</p>
<ul>
<li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" alt="img"></a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\Thread_study&gt;jps</span><br><span class="line">20672 RemoteMavenServer36</span><br><span class="line">22880 Jps</span><br><span class="line">4432 Launcher</span><br><span class="line">5316 Test5</span><br><span class="line">20184 KotlinCompileDaemon</span><br><span class="line">11132</span><br><span class="line"></span><br><span class="line">F:\Thread_study&gt;jstack 5316 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>打印的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;找到一个java级别的死锁</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>jconsole检测死锁</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" alt="img"></a></p>
</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" alt="img"></a></p>
<h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" alt="img"></a></p>
<h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p>
<h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p>
<h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li>
</ul>
<h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p>
<p>在使用顺序加锁时，可能会出现饥饿现象</p>
<h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁 (先到先得)</li>
<li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li>
</ul>
<p><strong>基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取ReentrantLock对象</span><br><span class="line">private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">	&#x2F;&#x2F;需要执行的代码</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">	&#x2F;&#x2F;释放锁</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul>
<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p>
<p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F;加锁，可打断锁</span><br><span class="line">				lock.lockInterruptibly();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">                &#x2F;&#x2F;被打断，返回，不再向下执行</span><br><span class="line">				return;</span><br><span class="line">			&#125;finally &#123;</span><br><span class="line">				&#x2F;&#x2F;释放锁</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			&#x2F;&#x2F;打断</span><br><span class="line">			t1.interrupt();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p>
<p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p>
<p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p>
<p>不设置等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;未设置等待时间，一旦获取失败，直接返回false</span><br><span class="line">			if(!lock.tryLock()) &#123;</span><br><span class="line">				System.out.println(&quot;获取失败&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取失败，不再向下执行，返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到了锁&quot;);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>设置等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F;判断获取锁是否成功，最多等待1秒</span><br><span class="line">				if(!lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">					System.out.println(&quot;获取失败&quot;);</span><br><span class="line">					&#x2F;&#x2F;获取失败，不再向下执行，直接返回</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				&#x2F;&#x2F;被打断，不再向下执行，直接返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到了锁&quot;);</span><br><span class="line">			&#x2F;&#x2F;释放锁</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			&#x2F;&#x2F;打断等待</span><br><span class="line">			t1.interrupt();</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认是不公平锁，需要在创建时指定为公平锁</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock(true); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li>await 前需要<strong>获得锁</strong></li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static Boolean judge &#x3D; false;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">	&#x2F;&#x2F;获得条件变量</span><br><span class="line">	Condition condition &#x3D; lock.newCondition();</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			while(!judge) &#123;</span><br><span class="line">				System.out.println(&quot;不满足条件，等待...&quot;);</span><br><span class="line">				&#x2F;&#x2F;等待</span><br><span class="line">				condition.await();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			System.out.println(&quot;执行完毕！&quot;);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(1);</span><br><span class="line">			judge &#x3D; true;</span><br><span class="line">			&#x2F;&#x2F;释放</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line">   private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">      @Override</span><br><span class="line">      protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">         if (getExclusiveOwnerThread() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            int state &#x3D; getState();</span><br><span class="line">            compareAndSetState(state, state + 1);</span><br><span class="line">            return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean tryRelease(int arg) &#123;</span><br><span class="line">         if (getState() &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (getExclusiveOwnerThread() !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         int state &#x3D; getState();</span><br><span class="line">         if (state &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            compareAndSetState(state, 0);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            compareAndSetState(state, state - 1);</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean isHeldExclusively() &#123;</span><br><span class="line">         return getState() &gt;&#x3D; 1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public Condition newCondition() &#123;</span><br><span class="line">         return new ConditionObject();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Sync sync &#x3D; new Sync();</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void lock() &#123;</span><br><span class="line">      sync.acquire(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">      sync.acquireInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean tryLock() &#123;</span><br><span class="line">      return sync.tryAcquire(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">      return sync.tryAcquireNanos(1, time);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">      sync.release(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Condition newCondition() &#123;</span><br><span class="line">      return sync.newCondition();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">   static int num &#x3D; 0;</span><br><span class="line">   public static void main(String[] args) throws InterruptedException, IOException &#123;</span><br><span class="line">      MyLock lock &#x3D; new MyLock();</span><br><span class="line"></span><br><span class="line">      Object syncLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">      Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  try &#123;</span><br><span class="line">                     num++;</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                     lock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  try &#123;</span><br><span class="line">                     num--;</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                     lock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line"></span><br><span class="line">      int x &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static final Object LOCK &#x3D; new Object();</span><br><span class="line">&#x2F;&#x2F;判断先执行的内容是否执行完毕</span><br><span class="line">static Boolean judge &#x3D; false;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			while (!judge) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					LOCK.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;2&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			System.out.println(&quot;1&quot;);</span><br><span class="line">			judge &#x3D; true;</span><br><span class="line">               &#x2F;&#x2F;执行完毕，唤醒所有等待线程</span><br><span class="line">			LOCK.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Test4 &#123;</span><br><span class="line">	static Symbol symbol &#x3D; new Symbol();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			symbol.run(&quot;a&quot;, 1, 2);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			symbol.run(&quot;b&quot;, 2, 3);</span><br><span class="line"></span><br><span class="line">		&#125;).start();</span><br><span class="line">		symbol.run(&quot;c&quot;, 3, 1);</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Symbol &#123;</span><br><span class="line">	public synchronized void run(String str, int flag, int nextFlag) &#123;</span><br><span class="line">		for(int i&#x3D;0; i&lt;loopNumber; i++) &#123;</span><br><span class="line">			while(flag !&#x3D; this.flag) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					this.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">			&#x2F;&#x2F;设置下一个运行的线程标记</span><br><span class="line">			this.flag &#x3D; nextFlag;</span><br><span class="line">			&#x2F;&#x2F;唤醒所有线程</span><br><span class="line">			this.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private int flag &#x3D; 1;</span><br><span class="line">	private int loopNumber &#x3D; 5;</span><br><span class="line"></span><br><span class="line">	public int getFlag() &#123;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setFlag(int flag) &#123;</span><br><span class="line">		this.flag &#x3D; flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getLoopNumber() &#123;</span><br><span class="line">		return loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setLoopNumber(int loopNumber) &#123;</span><br><span class="line">		this.loopNumber &#x3D; loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>await/signal版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class Test5 &#123;</span><br><span class="line">	static AwaitSignal awaitSignal &#x3D; new AwaitSignal();</span><br><span class="line">	static Condition conditionA &#x3D; awaitSignal.newCondition();</span><br><span class="line">	static Condition conditionB &#x3D; awaitSignal.newCondition();</span><br><span class="line">	static Condition conditionC &#x3D; awaitSignal.newCondition();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;a&quot;, conditionA, conditionB);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;b&quot;, conditionB, conditionC);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;c&quot;, conditionC, conditionA);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		awaitSignal.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">            &#x2F;&#x2F;唤醒一个等待的线程</span><br><span class="line">			conditionA.signal();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			awaitSignal.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AwaitSignal extends ReentrantLock&#123;</span><br><span class="line">	public void run(String str, Condition thisCondition, Condition nextCondition) &#123;</span><br><span class="line">		for(int i&#x3D;0; i&lt;loopNumber; i++) &#123;</span><br><span class="line">			lock();</span><br><span class="line">			try &#123;</span><br><span class="line">                &#x2F;&#x2F;全部进入等待状态</span><br><span class="line">				thisCondition.await();</span><br><span class="line">				System.out.print(str);</span><br><span class="line">				nextCondition.signal();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int loopNumber&#x3D;5;</span><br><span class="line"></span><br><span class="line">	public int getLoopNumber() &#123;</span><br><span class="line">		return loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setLoopNumber(int loopNumber) &#123;</span><br><span class="line">		this.loopNumber &#x3D; loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalStudy &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 创建ThreadLocal变量</span><br><span class="line">      ThreadLocal&lt;String&gt; stringThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">      ThreadLocal&lt;User&gt; userThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建两个线程，分别使用上面的两个ThreadLocal变量</span><br><span class="line">      Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第一次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread1 stringThreadLocal first&quot;);</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第二次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread1 stringThreadLocal second&quot;);</span><br><span class="line">         &#x2F;&#x2F; userThreadLocal赋值</span><br><span class="line">         userThreadLocal.set(new User(&quot;Nyima&quot;, 20));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 取值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line">         System.out.println(userThreadLocal.get());</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; 移除</span><br><span class="line">		 userThreadLocal.remove();</span><br><span class="line">		 System.out.println(userThreadLocal.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread thread2 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第一次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread2 stringThreadLocal first&quot;);</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第二次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread2 stringThreadLocal second&quot;);</span><br><span class="line">         &#x2F;&#x2F; userThreadLocal赋值</span><br><span class="line">         userThreadLocal.set(new User(&quot;Hulu&quot;, 20));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 取值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line">         System.out.println(userThreadLocal.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 启动线程</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">   String name;</span><br><span class="line">   int age;</span><br><span class="line"></span><br><span class="line">   public User(String name, int age) &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      this.age &#x3D; age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">      return &quot;User&#123;&quot; +</span><br><span class="line">            &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &quot;, age&#x3D;&quot; + age +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1 stringThreadLocal second</span><br><span class="line">thread2 stringThreadLocal second</span><br><span class="line">User&#123;name&#x3D;&#39;Nyima&#39;, age&#x3D;20&#125;</span><br><span class="line">User&#123;name&#x3D;&#39;Hulu&#39;, age&#x3D;20&#125;</span><br><span class="line">null </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看出</p>
<ul>
<li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul>
<li>从线程1和线程2的打印结果可以看出</li>
</ul>
</li>
<li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul>
<li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li>
</ul>
</li>
<li>ThreadLocal可以进行以下几个操作<ul>
<li>set 设置值</li>
<li>get 取出值</li>
<li>remove 移除值</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 放在后面说</span><br><span class="line"> ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;Copy</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p>
<h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获得ThreadLocalMap对象 </span><br><span class="line">    &#x2F;&#x2F; 这里的get会返回Thread类中的threadLocals</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; ThreadLocal自生的引用作为key，传入的值作为value</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>如果未创建</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建的同时设置想放入的值</span><br><span class="line">    &#x2F;&#x2F; hreadLocal自生的引用作为key，传入的值作为value</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>get方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">	&#x2F;&#x2F; 获取当前线程的threadLocals变量</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断threadLocals是否被初始化了</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 已经初始化则直接返回</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则就创建threadLocals</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;Copy</span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个方法返回是null</span><br><span class="line">    T value &#x3D; initialValue();</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 无论map创建与否，最终value的值都为null</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;Copy</span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>remove方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">    if (m !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 如果threadLocals已经被初始化，则移除</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p>
<p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p>
<h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread()Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p>
<p>也就是从main所在的线程，传给thread1或thread2</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ThreadLocal&lt;String&gt; stringThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">      InheritableThreadLocal&lt;String&gt; stringInheritable &#x3D; new InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 主线程赋对上面两个变量进行赋值</span><br><span class="line">      stringThreadLocal.set(&quot;this is threadLocal&quot;);</span><br><span class="line">      stringInheritable.set(&quot;this is inheritableThreadLocal&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建线程</span><br><span class="line">      Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; 获得ThreadLocal中存放的值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 获得InheritableThreadLocal存放的值</span><br><span class="line">         System.out.println(stringInheritable.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">this is inheritableThreadLocal </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 传入父线程中的一个值，然后直接返回</span><br><span class="line">    protected T childValue(T parentValue) &#123;</span><br><span class="line">        return parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	&#x2F;&#x2F; 返回传入线程的inheritableThreadLocals</span><br><span class="line">    &#x2F;&#x2F; Thread中有一个inheritableThreadLocals变量</span><br><span class="line">    &#x2F;&#x2F; ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	&#x2F;&#x2F; 创建一个inheritableThreadLocals</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p>
<h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;Copy</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">   	...</span><br><span class="line">        </span><br><span class="line">	&#x2F;&#x2F; 获得当前线程的，在这里是主线程</span><br><span class="line">    Thread parent &#x3D; currentThread();</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果父线程的inheritableThreadLocals存在</span><br><span class="line">    &#x2F;&#x2F; 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 设置子线程的inheritableThreadLocals</span><br><span class="line">        this.inheritableThreadLocals &#x3D;</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Stash the specified stack size in case the VM cares *&#x2F;</span><br><span class="line">    this.stackSize &#x3D; stackSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set thread ID *&#x2F;</span><br><span class="line">    tid &#x3D; nextThreadID();</span><br><span class="line">&#125;Copy</span><br><span class="line">static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    return new ThreadLocalMap(parentMap);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable &#x3D; parentMap.table;</span><br><span class="line">    int len &#x3D; parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table &#x3D; new Entry[len];</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e &#x3D; parentTable[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key &#x3D; (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            if (key !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里调用了 childValue 方法</span><br><span class="line">                &#x2F;&#x2F; 该方法会返回parent的值</span><br><span class="line">                Object value &#x3D; key.childValue(e.value);</span><br><span class="line">                </span><br><span class="line">                Entry c &#x3D; new Entry(key, value);</span><br><span class="line">                int h &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                while (table[h] !&#x3D; null)</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                table[h] &#x3D; c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p>
<p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p>
<h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p><strong>JMM体现在以下几个方面</strong></p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static Boolean run &#x3D; true;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			while (run) &#123;</span><br><span class="line">				&#x2F;&#x2F;如果run为真，则一直执行</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		System.out.println(&quot;改变run的值为false&quot;);</span><br><span class="line">		run &#x3D; false;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>为什么无法退出该循环</strong></p>
<ul>
<li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" alt="img"></a></p>
<ul>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" alt="img"></a></p>
<ul>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" alt="img"></a></p>
<p><strong>解决方法</strong></p>
<ul>
<li>使用<strong>volatile</strong>易变关键字</li>
<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用易变关键字</span><br><span class="line">volatile static Boolean run &#x3D; true;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		while (run) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果run为真，则一直执行</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	Thread.sleep(1000);</span><br><span class="line">	System.out.println(&quot;改变run的值为false&quot;);</span><br><span class="line">	run &#x3D; false;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p>
<ul>
<li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p>
</li>
<li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p>
</li>
<li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p>
<ul>
<li><p>因为使用了<strong>synchronized</strong>关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">		&#x2F;&#x2F;使用了synchronized关键字</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否被终止了</span><br><span class="line">	private volatile boolean stop &#x3D; false;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">					if(stop) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						System.out.println(&quot;被打断了&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">        &#x2F;&#x2F;修改标记</span><br><span class="line">		stop &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p>
<p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p>
<ul>
<li>用一个标记来判断该任务是否已经被执行过了</li>
<li>需要避免线程安全问题<ul>
<li>加锁的代码块要尽量的小，以保证性能</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.nyima.day1;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author Chen Panwen</span><br><span class="line"> * @data 2020&#x2F;3&#x2F;26 16:11</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否被终止了</span><br><span class="line">	private volatile boolean stop &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否已经启动过了</span><br><span class="line">	private boolean starting &#x3D; false;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;上锁，避免多线程运行时出现线程安全问题</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			if (starting) &#123;</span><br><span class="line">				&#x2F;&#x2F;已被启动，直接返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;启动监视器，改变标记</span><br><span class="line">			starting &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">					if(stop) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						System.out.println(&quot;被打断了&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">		stop &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" alt="img"></a></p>
<p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p>
<h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul>
<li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" alt="img"></a></p>
<ul>
<li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p>
</li>
<li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以重排的例子 </span><br><span class="line">int a &#x3D; 10; </span><br><span class="line">int b &#x3D; 20; </span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不能重排的例子 </span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; a - 5; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" alt="img"></a></p>
<p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p>
<ul>
<li>禁止的是加volatile关键字变量之前的代码被重排序</li>
</ul>
<h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul>
<li>可见性<ul>
<li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li>
<li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据</li>
</ul>
</li>
<li>有序性<ul>
<li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul>
<li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" alt="img"></a></p>
</li>
<li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" alt="img"></a></p>
</li>
</ul>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul>
<li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" alt="img"></a></p>
</li>
<li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" alt="img"></a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" alt="img"></a></p>
<p><strong>但是不能解决指令交错问题</strong></p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li>
</ul>
<h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance &#x3D; new Singleton(); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... lock addl ... </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p>
<ul>
<li><p>Lock前缀指令会引起处理器</p>
<p>缓存回写到内存</p>
<ul>
<li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li>
</ul>
</li>
<li><p>一个处理器的缓存回写到内存会</p>
<p>导致其他处理器的缓存无效</p>
<ul>
<li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li>
</ul>
</li>
</ul>
<h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul>
<li><p>使用<strong>原子整数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger balance &#x3D; new AtomicInteger();Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">interface Account &#123;</span><br><span class="line">	Integer getBalance();</span><br><span class="line"></span><br><span class="line">	void withdraw(Integer amount);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void demo(Account account) &#123;</span><br><span class="line">		List&lt;Thread&gt; ts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		long start &#x3D; System.nanoTime();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			ts.add(new Thread(() -&gt; &#123;</span><br><span class="line">				account.withdraw(10);</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		ts.forEach(Thread::start);</span><br><span class="line">		ts.forEach(t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		long end &#x3D; System.nanoTime();</span><br><span class="line">		System.out.println(account.getBalance() + &quot; cost: &quot; + (end - start) &#x2F; 1000_000 + &quot; ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程不安全的做法</span><br><span class="line">class AccountUnsafe implements Account &#123;</span><br><span class="line">	private Integer balance;</span><br><span class="line"></span><br><span class="line">	public AccountUnsafe(Integer balance) &#123;</span><br><span class="line">		this.balance &#x3D; balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Integer getBalance() &#123;</span><br><span class="line">		return this.balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized void withdraw(Integer amount) &#123;</span><br><span class="line">		balance -&#x3D; amount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Account.demo(new AccountUnsafe(10000));</span><br><span class="line">		Account.demo(new AccountCas(10000));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程安全的做法</span><br><span class="line">class AccountCas implements Account &#123;</span><br><span class="line">	&#x2F;&#x2F;使用原子整数</span><br><span class="line">	private AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">	public AccountCas(int balance) &#123;</span><br><span class="line">		this.balance &#x3D; new AtomicInteger(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Integer getBalance() &#123;</span><br><span class="line">		&#x2F;&#x2F;得到原子整数的值</span><br><span class="line">		return balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void withdraw(Integer amount) &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			&#x2F;&#x2F;获得修改前的值</span><br><span class="line">			int prev &#x3D; balance.get();</span><br><span class="line">			&#x2F;&#x2F;获得修改后的值</span><br><span class="line">			int next &#x3D; prev-amount;</span><br><span class="line">			&#x2F;&#x2F;比较并设值</span><br><span class="line">			if(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
<p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" alt="img"></a></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul>
<li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul>
<li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li>
<li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>
<p><strong>注意</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性） </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" alt="img"></a></p>
<p><strong>原因</strong></p>
<h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p>
<ul>
<li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
<li><p>CAS 体现的是</p>
<p>无锁并发、无阻塞并发</p>
<p>，请仔细体会这两句话的意思</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p><strong>以 AtomicInteger 为例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> AtomicInteger i &#x3D; new AtomicInteger(0);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并自增（i &#x3D; 0, 结果 i &#x3D; 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 自增并获取（i &#x3D; 1, 结果 i &#x3D; 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 自减并获取（i &#x3D; 2, 结果 i &#x3D; 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并自减（i &#x3D; 1, 结果 i &#x3D; 0, 返回 1），类似于 i--</span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并加值（i &#x3D; 0, 结果 i &#x3D; 5, 返回 0） </span><br><span class="line">System.out.println(i.getAndAdd(5));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 加值并获取（i &#x3D; 5, 结果 i &#x3D; 0, 返回 0） </span><br><span class="line">System.out.println(i.addAndGet(-5));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并更新（i &#x3D; 0, p 为 i 的当前值, 结果 i &#x3D; -2, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - 2));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 更新并获取（i &#x3D; -2, p 为 i 的当前值, 结果 i &#x3D; 0, 返回 0）</span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + 2));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并计算（i &#x3D; 0, p 为 i 的当前值, x 为参数1, 结果 i &#x3D; 10, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 &#x2F;&#x2F; getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="line">&#x2F;&#x2F; getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br><span class="line">final System.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 计算并获取（i &#x3D; 10, p 为 i 的当前值, x 为参数1, 结果 i &#x3D; 0, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="line">System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x)); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public interface DecimalAccount &#123;</span><br><span class="line">	BigDecimal getBalance();</span><br><span class="line"></span><br><span class="line">	void withdraw(BigDecimal amount);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="line">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void demo(DecimalAccountImpl account) &#123;</span><br><span class="line">		List&lt;Thread&gt; ts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		long start &#x3D; System.nanoTime();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			ts.add(new Thread(() -&gt; &#123;</span><br><span class="line">				account.withdraw(BigDecimal.TEN);</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		ts.forEach(Thread::start);</span><br><span class="line">		ts.forEach(t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		long end &#x3D; System.nanoTime();</span><br><span class="line">		System.out.println(account.getBalance() + &quot; cost: &quot; + (end - start) &#x2F; 1000_000 + &quot; ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DecimalAccountImpl implements DecimalAccount &#123;</span><br><span class="line">	&#x2F;&#x2F;原子引用，泛型类型为小数类型</span><br><span class="line">	AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">	public DecimalAccountImpl(BigDecimal balance) &#123;</span><br><span class="line">		this.balance &#x3D; new AtomicReference&lt;BigDecimal&gt;(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public BigDecimal getBalance() &#123;</span><br><span class="line">		return balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void withdraw(BigDecimal amount) &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			BigDecimal pre &#x3D; balance.get();</span><br><span class="line">			BigDecimal next &#x3D; pre.subtract(amount);</span><br><span class="line">			if(balance.compareAndSet(pre, next)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DecimalAccount.demo(new DecimalAccountImpl(new BigDecimal(&quot;10000&quot;)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	static AtomicReference&lt;String&gt; str &#x3D; new AtomicReference&lt;&gt;(&quot;A&quot;);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.get();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C</span><br><span class="line">			System.out.println(&quot;change A-&gt;C &quot; + str.compareAndSet(pre, &quot;C&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change A-&gt;B &quot; + str.compareAndSet(&quot;A&quot;, &quot;B&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">		Thread.sleep(500);</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change B-&gt;A &quot; + str.compareAndSet(&quot;B&quot;, &quot;A&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" alt="img"></a></p>
<p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	&#x2F;&#x2F;指定版本号</span><br><span class="line">	static AtomicStampedReference&lt;String&gt; str &#x3D; new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.getReference();</span><br><span class="line">			&#x2F;&#x2F;获得版本号</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="line">			System.out.println(&quot;change A-&gt;C stamp &quot; + stamp + str.compareAndSet(pre, &quot;C&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change A-&gt;B stamp &quot; + stamp + str.compareAndSet(&quot;A&quot;, &quot;B&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">		Thread.sleep(500);</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change B-&gt;A stamp &quot; + stamp +  str.compareAndSet(&quot;B&quot;, &quot;A&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" alt="img"></a></p>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">	&#x2F;&#x2F;指定版本号</span><br><span class="line">	static AtomicMarkableReference&lt;String&gt; str &#x3D; new AtomicMarkableReference&lt;&gt;(&quot;A&quot;, true);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.getReference();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="line">			System.out.println(&quot;change A-&gt;C mark &quot; +  str.compareAndSet(pre, &quot;C&quot;, true, false));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change A-&gt;A mark &quot; + str.compareAndSet(&quot;A&quot;, &quot;A&quot;, true, false));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" alt="img"></a></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li>
<li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li>
</ul>
<h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul>
<li>提供者<ul>
<li>无参又返回</li>
<li>()-&gt;返回结果</li>
</ul>
</li>
<li>方法<ul>
<li>有参有返回</li>
<li>(参数一…)-&gt;返回结果</li>
</ul>
</li>
<li>消费者<ul>
<li>有参无返回</li>
<li>(参数一…)-&gt;void</li>
</ul>
</li>
</ul>
<h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul>
<li>AtomicReferenceFieldUpdater // 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdate</li>
</ul>
<p>原子更新器用于帮助我们改变某个对象中的某个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Student student &#x3D; new Student();</span><br><span class="line">       </span><br><span class="line">      &#x2F;&#x2F; 获得原子更新器</span><br><span class="line">      &#x2F;&#x2F; 泛型</span><br><span class="line">      &#x2F;&#x2F; 参数1 持有属性的类 参数2 被更新的属性的类</span><br><span class="line">      &#x2F;&#x2F; newUpdater中的参数：第三个为属性的名称</span><br><span class="line">      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater &#x3D; AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, &quot;name&quot;);</span><br><span class="line">       </span><br><span class="line">      &#x2F;&#x2F; 修改</span><br><span class="line">      updater.compareAndSet(student, null, &quot;Nyima&quot;);</span><br><span class="line">      System.out.println(student);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">   volatile String name;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">      return &quot;Student&#123;&quot; +</span><br><span class="line">            &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p>
<ul>
<li>拥有属性的类的Class</li>
<li>属性的Class</li>
<li>属性的名称</li>
</ul>
<p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p>
<h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(Class&lt;U&gt; tclass,</span><br><span class="line">                                                                Class&lt;W&gt; vclass,</span><br><span class="line">                                                                String fieldName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回了一个AtomicReferenceFieldUpdaterImpl实例</span><br><span class="line">    return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line">        (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>从newUpdater方法还并不能看出来具体的初始化过程</p>
<h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" alt="img"></a></p>
<p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt;</span><br><span class="line">        extends AtomicReferenceFieldUpdater&lt;T,V&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" alt="img"></a></p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass,</span><br><span class="line">                                final Class&lt;V&gt; vclass,</span><br><span class="line">                                final String fieldName,</span><br><span class="line">                                final Class&lt;?&gt; caller) &#123;</span><br><span class="line">    &#x2F;&#x2F; 用于保存要被修改的属性</span><br><span class="line">    final Field field;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 属性的Class</span><br><span class="line">    final Class&lt;?&gt; fieldClass;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; field的修饰符</span><br><span class="line">    final int modifiers;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射获得属性</span><br><span class="line">        field &#x3D; AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                    &#x2F;&#x2F; tclass为传入的属性的Class，可以通过它来获得属性</span><br><span class="line">                    return tclass.getDeclaredField(fieldName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得属性的修饰符，主要用于判断</span><br><span class="line">        &#x2F;&#x2F; 1、vclass 与 属性确切的类型是否匹配</span><br><span class="line">        &#x2F;&#x2F; 2、是否为引用类型</span><br><span class="line">        &#x2F;&#x2F; 3、被修改的属性是否加了volatile关键字</span><br><span class="line">        modifiers &#x3D; field.getModifiers();</span><br><span class="line">        sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">            caller, tclass, null, modifiers);</span><br><span class="line">        ClassLoader cl &#x3D; tclass.getClassLoader();</span><br><span class="line">        ClassLoader ccl &#x3D; caller.getClassLoader();</span><br><span class="line">        if ((ccl !&#x3D; null) &amp;&amp; (ccl !&#x3D; cl) &amp;&amp;</span><br><span class="line">            ((cl &#x3D;&#x3D; null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得属性类的Class</span><br><span class="line">        fieldClass &#x3D; field.getType();</span><br><span class="line">    &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">        throw new RuntimeException(pae.getException());</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vclass !&#x3D; fieldClass)</span><br><span class="line">        throw new ClassCastException();</span><br><span class="line">    if (vclass.isPrimitive())</span><br><span class="line">        throw new IllegalArgumentException(&quot;Must be reference type&quot;);</span><br><span class="line"></span><br><span class="line">    if (!Modifier.isVolatile(modifiers))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Access to protected field members is restricted to receivers only</span><br><span class="line">    &#x2F;&#x2F; of the accessing class, or one of its subclasses, and the</span><br><span class="line">    &#x2F;&#x2F; accessing class must in turn be a subclass (or package sibling)</span><br><span class="line">    &#x2F;&#x2F; of the protected member&#39;s defining class.</span><br><span class="line">    &#x2F;&#x2F; If the updater refers to a protected field of a declaring class</span><br><span class="line">    &#x2F;&#x2F; outside the current package, the receiver argument will be</span><br><span class="line">    &#x2F;&#x2F; narrowed to the type of the accessing class.</span><br><span class="line"> 	&#x2F;&#x2F; 对类中的属性进行初始化</span><br><span class="line">    this.cclass &#x3D; (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                   tclass.isAssignableFrom(caller) &amp;&amp;</span><br><span class="line">                   !isSamePackage(tclass, caller))</span><br><span class="line">                  ? caller : tclass;</span><br><span class="line">    this.tclass &#x3D; tclass;</span><br><span class="line">    this.vclass &#x3D; vclass;</span><br><span class="line">    &#x2F;&#x2F; 获得偏移量</span><br><span class="line">    this.offset &#x3D; U.objectFieldOffset(field);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>可以看出，原子引用更新器确实使用了反射</strong></p>
<h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" alt="img"></a></p>
<p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" alt="img"></a></p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" alt="img"></a></p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>
<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p>
<p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p>
<p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" alt="img"></a></p>
<p><strong>累加主要调用以下方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">       Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">       if ((as &#x3D; cells) !&#x3D; null || !casBase(b &#x3D; base, b + x)) &#123;</span><br><span class="line">           boolean uncontended &#x3D; true;</span><br><span class="line">           if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">               (a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">               !(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)))</span><br><span class="line">               longAccumulate(x, null, uncontended);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>累加流程图</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" alt="img"></a></p>
<h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class GetUnsafe &#123;</span><br><span class="line">	public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">		&#x2F;&#x2F; 通过反射获得Unsafe对象</span><br><span class="line">		Class unsafeClass &#x3D; Unsafe.class;</span><br><span class="line">		&#x2F;&#x2F; 获得构造函数，Unsafe的构造函数为私有的</span><br><span class="line">		Constructor constructor &#x3D; unsafeClass.getDeclaredConstructor();</span><br><span class="line">		&#x2F;&#x2F; 设置为允许访问私有内容</span><br><span class="line">		constructor.setAccessible(true);</span><br><span class="line">		&#x2F;&#x2F; 创建Unsafe对象</span><br><span class="line">		Unsafe unsafe &#x3D; (Unsafe) constructor.newInstance();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建Person对象</span><br><span class="line">		Person person &#x3D; new Person();</span><br><span class="line">		&#x2F;&#x2F; 获得其属性 name 的偏移量</span><br><span class="line">		Field field &#x3D; Person.class.getDeclaredField(&quot;name&quot;);</span><br><span class="line">		long offset &#x3D; unsafe.objectFieldOffset(field);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 通过unsafe的CAS操作改变值</span><br><span class="line">		unsafe.compareAndSwapObject(person, offset, null, &quot;Nyima&quot;);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    &#x2F;&#x2F; 配合CAS操作，必须用volatile修饰</span><br><span class="line"> 	volatile String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Person&#123;&quot; +</span><br><span class="line">				&quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">				&#39;&#125;&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p>
<h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    &#x2F;** Cache the hash code for the string *&#x2F;</span><br><span class="line">    private int hash; &#x2F;&#x2F; Default to 0</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F;....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p>
<ul>
<li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li>
<li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li>
</ul>
<p>**保护性拷贝 **</p>
<p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen &#x3D; value.length - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">    	&#x2F;&#x2F;返回的是一个新的对象</span><br><span class="line">        return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &lt;&#x3D; 0) &#123;</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            if (offset &lt;&#x3D; value.length) &#123;</span><br><span class="line">                this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">        if (offset &gt; value.length - count) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        this.value &#x3D; Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p>
<h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" alt="img"></a></p>
<ul>
<li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li>
<li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li>
<li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ThreadPool threadPool &#x3D; new ThreadPool(2,  TimeUnit.SECONDS, 1, 4);</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">         threadPool.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(10000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;任务正在执行!&quot;);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 自定义线程池</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ThreadPool &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 自定义阻塞队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 核心线程数</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private int coreSize;</span><br><span class="line"></span><br><span class="line">   private HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 用于指定线程最大存活时间</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private TimeUnit timeUnit;</span><br><span class="line">   private long timeout;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 工作线程类</span><br><span class="line">    * 内部封装了Thread类，并且添加了一些属性</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private class Worker extends Thread &#123;</span><br><span class="line">      Runnable task;</span><br><span class="line"></span><br><span class="line">      public Worker(Runnable task) &#123;</span><br><span class="line">         System.out.println(&quot;初始化任务&quot;);</span><br><span class="line">         this.task &#x3D; task;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果有任务就执行</span><br><span class="line">         &#x2F;&#x2F; 如果阻塞队列中有任务，就继续执行</span><br><span class="line">         while (task !&#x3D; null || (task &#x3D; blockingQueue.take()) !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               System.out.println(&quot;执行任务&quot;);</span><br><span class="line">               task.run();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               &#x2F;&#x2F; 任务执行完毕，设为空</span><br><span class="line">               System.out.println(&quot;任务执行完毕&quot;);</span><br><span class="line">               task &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 移除任务</span><br><span class="line">         synchronized (workers) &#123;</span><br><span class="line">            System.out.println(&quot;移除任务&quot;);</span><br><span class="line">            workers.remove(this);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public ThreadPool(int coreSize, TimeUnit timeUnit, long timeout, int capacity) &#123;</span><br><span class="line">      this.coreSize &#x3D; coreSize;</span><br><span class="line">      this.timeUnit &#x3D; timeUnit;</span><br><span class="line">      blockingQueue &#x3D; new BlockingQueue&lt;&gt;(capacity);</span><br><span class="line">      this.timeout &#x3D; timeout;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void execute(Runnable task) &#123;</span><br><span class="line">      synchronized (workers) &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建任务</span><br><span class="line">         &#x2F;&#x2F; 池中还有空余线程时，可以运行任务</span><br><span class="line">         &#x2F;&#x2F; 否则阻塞</span><br><span class="line">         if (workers.size() &lt; coreSize) &#123;</span><br><span class="line">            Worker worker &#x3D; new Worker(task);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;线程池中线程已用完，请稍等&quot;);</span><br><span class="line">            blockingQueue.put(task);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 阻塞队列</span><br><span class="line"> * 用于存放主线程或其他线程产生的任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">class BlockingQueue&lt;T&gt; &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 阻塞队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private  Deque&lt;T&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 阻塞队列容量</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private int capacity;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 锁</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 条件队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private Condition fullQueue;</span><br><span class="line">   private Condition emptyQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public BlockingQueue(int capacity) &#123;</span><br><span class="line">      blockingQueue &#x3D; new ArrayDeque&lt;&gt;(capacity);</span><br><span class="line">      lock &#x3D; new ReentrantLock();</span><br><span class="line">      fullQueue &#x3D; lock.newCondition();</span><br><span class="line">      emptyQueue &#x3D; lock.newCondition();</span><br><span class="line">      this.capacity &#x3D; capacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 获取任务的方法</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public T take() &#123;</span><br><span class="line">      &#x2F;&#x2F; 加锁</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果阻塞队列为空（没有任务），就一直等待</span><br><span class="line">         while (blockingQueue.isEmpty()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               emptyQueue.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 获取任务并唤醒生产者线程</span><br><span class="line">         T task &#x3D; blockingQueue.removeFirst();</span><br><span class="line">         fullQueue.signalAll();</span><br><span class="line">         return task;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public T takeNanos(long timeout, TimeUnit unit) &#123;</span><br><span class="line">      &#x2F;&#x2F; 转换等待时间</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">         while (blockingQueue.isEmpty()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               &#x2F;&#x2F; awaitNanos会返回剩下的等待时间</span><br><span class="line">               nanos &#x3D; emptyQueue.awaitNanos(nanos);</span><br><span class="line">               if (nanos &lt; 0) &#123;</span><br><span class="line">                  return null;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         T task &#x3D; blockingQueue.removeFirst();</span><br><span class="line">         fullQueue.signalAll();</span><br><span class="line">         return task;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 放入任务的方法</span><br><span class="line">    * @param task 放入阻塞队列的任务</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void put(T task) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         while (blockingQueue.size() &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               System.out.println(&quot;阻塞队列已满&quot;);</span><br><span class="line">               fullQueue.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         blockingQueue.add(task);</span><br><span class="line">         &#x2F;&#x2F; 唤醒等待的消费者</span><br><span class="line">         emptyQueue.signalAll();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int getSize() &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         return blockingQueue.size();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>实现了一个简单的线程池</p>
<ul>
<li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul>
<li>也可以说是平衡生产者和消费者执行速度上的差异</li>
<li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li>
</ul>
</li>
<li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul>
<li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li>
</ul>
</li>
<li>线程池中执行任务的主要方法为execute方法<ul>
<li>执行时要判断正在执行的线程数是否大于了线程池容量</li>
</ul>
</li>
</ul>
<h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" alt="img"></a></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程池状态</span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">&#x2F;&#x2F; RUNNING 高3位为111</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SHUTDOWN 高3位为000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 001</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 010</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 011</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态名称</th>
<th>高3位的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p>
<ul>
<li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并不是所有平台的int都是32位。</span><br><span class="line">&#x2F;&#x2F; 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="line">&#x2F;&#x2F; 高3位为0，剩余位数全为1</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="line">&#x2F;&#x2F; CAPACITY 的高3位为 0</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>获取线程池状态、线程数量以及合并两个值的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Packing and unpacking ctl</span><br><span class="line">&#x2F;&#x2F; 获取运行状态</span><br><span class="line">&#x2F;&#x2F; 该操作会让除高3位以外的数全部变为0</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取运行线程数</span><br><span class="line">&#x2F;&#x2F; 该操作会让高3位为0</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算ctl新值</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 工作线程，内部封装了Thread</span><br><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 锁</span><br><span class="line">private final ReentrantLock mainLock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="line">private final HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p>
<p>也是构造自定义线程池的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数<ul>
<li>maximumPoolSize - corePoolSize = 救急线程数</li>
</ul>
</li>
<li>keepAliveTime：救急线程空闲时的最大生存时间</li>
<li>unit：时间单位</li>
<li>workQueue：阻塞队列（存放任务）<ul>
<li>有界阻塞队列 ArrayBlockingQueue</li>
<li>无界阻塞队列 LinkedBlockingQueue</li>
<li>最多只有一个同步元素的 SynchronousQueue</li>
<li>优先队列 PriorityBlockingQueue</li>
</ul>
</li>
<li>threadFactory：线程工厂（给线程取名字）</li>
<li>handler：拒绝策略</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>当一个任务传给线程池以后，可能有以下几种可能<ul>
<li>将任务分配给一个核心线程来执行</li>
<li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li>
<li>阻塞队列满了，使用救急线程来执行任务<ul>
<li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li>
</ul>
</li>
<li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li>
</ul>
</li>
</ul>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" alt="img"></a></p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   static AtomicInteger threadId &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 手动创建线程池</span><br><span class="line">      &#x2F;&#x2F; 创建有界阻塞队列</span><br><span class="line">      ArrayBlockingQueue&lt;Runnable&gt; runnable &#x3D; new ArrayBlockingQueue&lt;Runnable&gt;(10);</span><br><span class="line">      &#x2F;&#x2F; 创建线程工厂</span><br><span class="line">      ThreadFactory threadFactory &#x3D; new ThreadFactory() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(r, &quot;working_thread_&quot;+threadId.getAndIncrement());</span><br><span class="line">            return thread;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 手动创建线程池</span><br><span class="line">      &#x2F;&#x2F; 拒绝策略采用默认策略</span><br><span class="line">      ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 7, 10, TimeUnit.SECONDS, runnable, threadFactory);</span><br><span class="line"></span><br><span class="line">      for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">         executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">               System.out.println(Thread.currentThread());</span><br><span class="line">               try &#123;</span><br><span class="line">                  Thread.sleep(100000);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestFixedThreadPool &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 自定义线程工厂</span><br><span class="line">      ThreadFactory factory &#x3D; new ThreadFactory() &#123;</span><br><span class="line">         AtomicInteger atomicInteger &#x3D; new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public Thread newThread(Runnable r) &#123;</span><br><span class="line">            return new Thread(r, &quot;myThread_&quot; + atomicInteger.getAndIncrement());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建核心线程数量为2的线程池</span><br><span class="line">      &#x2F;&#x2F; 通过 ThreadFactory可以给线程添加名字</span><br><span class="line"></span><br><span class="line">      ExecutorService executorService &#x3D; Executors.newFixedThreadPool(2, factory);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 任务</span><br><span class="line">      Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(&quot;this is fixedThreadPool&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      executorService.execute(runnable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>固定大小的线程池可以传入两个参数</p>
<ul>
<li>核心线程数：nThreads</li>
<li>线程工厂：threadFactory</li>
</ul>
<p>内部调用的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                              new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>内部构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                              60L, TimeUnit.SECONDS,</span><br><span class="line">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p>
</li>
<li><p>阻塞队列使用的是SynchronousQueue</p>
<ul>
<li><p>SynchronousQueue</p>
<p>是一种特殊的队列</p>
<ul>
<li><strong>没有容量</strong>，没有线程来取是放不进去的</li>
<li>只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>内部构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new FinalizableDelegatedExecutorService</span><br><span class="line">    (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                            0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                            new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p>
<h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul>
<li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p>
<ul>
<li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li>
</ul>
</li>
<li><p>SingleThread和newFixedThreadPool(1)的区别</p>
<ul>
<li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 强转为ThreadPoolExecutor</span><br><span class="line">ThreadPoolExecutor threadPool &#x3D; (ThreadPoolExecutor) Executors.newFixedThreadPool(1);</span><br><span class="line">&#x2F;&#x2F; 改变核心线程数</span><br><span class="line">threadPool.setCorePoolSize(2);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>而SingleThread无法修改核心线程数</li>
</ul>
</li>
</ul>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute(Runnable command)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>传入一个Runnable对象，执行其中的run方法</p>
<p><strong>源码解析</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取ctl</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断当前启用的线程数是否小于核心线程数</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为该任务分配线程</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            &#x2F;&#x2F; 分配成功就返回</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 分配失败再次获取ctl</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 分配和信息线程失败以后</span><br><span class="line">    &#x2F;&#x2F; 如果池状态为RUNNING并且插入到任务队列成功</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 双重检测，可能在添加后线程池状态变为了非RUNNING</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果池状态为非RUNNING，则不会执行新来的任务</span><br><span class="line">        &#x2F;&#x2F; 将该任务从阻塞队列中移除</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            &#x2F;&#x2F; 调用拒绝策略，拒绝该任务的执行</span><br><span class="line">            reject(command);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果没有正在运行的线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;&#x2F; 就创建新线程来执行该任务</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果添加失败了（任务队列已满），就调用拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>其中调用了**addWoker()**方法，再看看看这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        &#x2F;&#x2F; 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            &#x2F;&#x2F; 创建新线程失败</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获得当前工作线程数</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 参数中 core 为true</span><br><span class="line">            &#x2F;&#x2F; CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span><br><span class="line">            &#x2F;&#x2F; 如果工作线程数大于了核心线程数，则创建失败</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 通过CAS操作改变c的值</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                &#x2F;&#x2F; 更改成功就跳出多重循环，且不再运行循环</span><br><span class="line">                break retry;</span><br><span class="line">            &#x2F;&#x2F; 更改失败，重新获取ctl的值</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                &#x2F;&#x2F; 跳出多重循环，且重新进入循环</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于标记work中的任务是否成功执行</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 用于标记worker是否成功加入了线程池中</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建新线程来执行任务</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">            &#x2F;&#x2F; 加锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Recheck while holding lock.</span><br><span class="line">                &#x2F;&#x2F; Back out on ThreadFactory failure or if</span><br><span class="line">                &#x2F;&#x2F; shut down before lock acquired.</span><br><span class="line">                &#x2F;&#x2F; 加锁的同时再次检测</span><br><span class="line">                &#x2F;&#x2F; 避免在释放锁之前调用了shut down</span><br><span class="line">                int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    &#x2F;&#x2F; 将线程添加到线程池中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    &#x2F;&#x2F; 添加成功标志位变为true</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果worker成功加入了线程池，就执行其中的任务</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                &#x2F;&#x2F; 启动成功</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果执行失败</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            &#x2F;&#x2F; 调用添加失败的函数</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; submit(Callable&lt;T&gt; task) </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p>
<p><strong>使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过submit执行Callable中的call方法</span><br><span class="line">&#x2F;&#x2F; 通过Future来捕获返回值</span><br><span class="line">Future&lt;String&gt; future &#x3D; threadPool.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String call() throws Exception &#123;</span><br><span class="line">      return &quot;hello submit&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看捕获的返回值</span><br><span class="line">System.out.println(future.get());</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 将线程池的状态改为 SHUTDOWN</span><br><span class="line">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><br><span class="line">*&#x2F;</span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 修改线程池状态为 SHUTDOWN</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        </span><br><span class="line">  		&#x2F;&#x2F; 中断空闲线程（没有执行任务的线程）</span><br><span class="line">        &#x2F;&#x2F; Idle：空闲的</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 尝试终结，不一定成功</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;Copy</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 终结失败的条件</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为RUNNING</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果活跃线程数不为0</span><br><span class="line">        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate</span><br><span class="line">            &#x2F;&#x2F; 中断空闲线程</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 处于可以终结的状态</span><br><span class="line">            &#x2F;&#x2F; 通过CAS将线程池状态改为TIDYING</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 通过CAS将线程池状态改为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 将线程池的状态改为 STOP</span><br><span class="line">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><br><span class="line">* 会将阻塞队列中未执行的任务返回给调用者</span><br><span class="line">*&#x2F;</span><br><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 修改状态为STOP，不执行任何任务</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 中断所有线程</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将未执行的任务从队列中移除，然后返回给调用者</span><br><span class="line">        tasks &#x3D; drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 尝试终结，一定会成功，因为阻塞队列为空了</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/18/juc%E5%AD%A6%E4%B9%A0/" data-id="cknmwaipm000aj4ub5yvl8f5c" data-title="juc学习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T01:44:31.831Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/07/hello-world/" data-id="cknmwaiox0000j4ubhr8idcjl" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis集群与企业级解决方案" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:36:22.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">redis集群与企业级解决方案</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis集群与企业级解决方案"><a href="#Redis集群与企业级解决方案" class="headerlink" title="Redis集群与企业级解决方案"></a>Redis集群与企业级解决方案</h1><p>基于<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>的视频的学习笔记</p>
<h2 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h2><h3 id="1-1-主从复制简介"><a href="#1-1-主从复制简介" class="headerlink" title="1.1 主从复制简介"></a>1.1 主从复制简介</h3><h4 id="1-1-1-互联网“三高”架构"><a href="#1-1-1-互联网“三高”架构" class="headerlink" title="1.1.1 互联网“三高”架构"></a>1.1.1 互联网“三高”架构</h4><ul>
<li>高并发</li>
<li>高性能</li>
<li>高可用</li>
</ul>
<h4 id="1-1-2-单机redis的风险和问题"><a href="#1-1-2-单机redis的风险和问题" class="headerlink" title="1.1.2 单机redis的风险和问题"></a>1.1.2 单机redis的风险和问题</h4><ul>
<li>机器故障</li>
<li>容量瓶颈</li>
<li>结论：<ul>
<li>避免单点redis服务器故障，准备堕胎服务器互联</li>
<li>互联服务器保证数据同步</li>
<li>实现Redis高可用，实现数据冗余备份</li>
</ul>
</li>
</ul>
<h4 id="1-1-3-多台服务器连接方案"><a href="#1-1-3-多台服务器连接方案" class="headerlink" title="1.1.3 多台服务器连接方案"></a>1.1.3 多台服务器连接方案</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_32_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_32_20210327.png" alt="img"></a></p>
<ul>
<li>提供数据方：master<ul>
<li>主服务器，主节点，主库</li>
<li>主客户端</li>
</ul>
</li>
<li>接收数据的方：slave<ul>
<li>从服务器，从节点，从库</li>
<li>从客户端</li>
</ul>
</li>
<li>需要解决的问题<ul>
<li><strong>数据同步</strong></li>
</ul>
</li>
<li>核心工作<ul>
<li>master的数据<strong>复制</strong>到slave中</li>
</ul>
</li>
</ul>
<h4 id="1-1-4-主从复制"><a href="#1-1-4-主从复制" class="headerlink" title="1.1.4 主从复制"></a>1.1.4 主从复制</h4><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中</p>
<p>特征：一个master可以拥有多个slave，一个slave只对应一个master</p>
<p>职责：</p>
<ul>
<li>master:<ul>
<li>写数据</li>
<li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave</li>
<li>读数据（可忽略）</li>
</ul>
</li>
<li>slave:<ul>
<li>读数据</li>
<li>写数据（<strong>禁止</strong>）</li>
</ul>
</li>
</ul>
<h4 id="1-1-5-主从复制的作用"><a href="#1-1-5-主从复制的作用" class="headerlink" title="1.1.5 主从复制的作用"></a>1.1.5 主从复制的作用</h4><ul>
<li>读写分离：master写、slave读，提高服务器的读写负载能力</li>
<li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li>
<li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li>
<li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式</li>
<li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li>
</ul>
<h3 id="1-2-主从复制工作流程"><a href="#1-2-主从复制工作流程" class="headerlink" title="1.2 主从复制工作流程"></a>1.2 主从复制工作流程</h3><h4 id="1-2-1-总述"><a href="#1-2-1-总述" class="headerlink" title="1.2.1 总述"></a>1.2.1 总述</h4><ul>
<li>主从复制过程大体可以分为3个阶段<ul>
<li>建立连接阶段（即准备阶段）</li>
<li>数据同步阶段</li>
<li>命令传播阶段</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_33_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_33_20210327.png" alt="img"></a></p>
<h4 id="1-2-2-第一阶段：建立连接"><a href="#1-2-2-第一阶段：建立连接" class="headerlink" title="1.2.2 第一阶段：建立连接"></a>1.2.2 第一阶段：建立连接</h4><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_34_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_34_20210327.png" alt="img"></a></p>
<p>**主从连接（slave连接master） **</p>
<ul>
<li><p>方式一：客户端发送命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：启动服务器参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server -slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>方式三：服务器配置 （常用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>slave系统信息</p>
<ul>
<li>master_link_down_since_seconds</li>
<li>masterhost</li>
<li>masterport</li>
</ul>
</li>
<li><p>master系统信息</p>
<ul>
<li>slave_listening_port(多个)</li>
</ul>
</li>
</ul>
<p><strong>主从断开连接</strong></p>
<ul>
<li><p><strong>客户端</strong>发送命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slaveof no one</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据</li>
</ul>
</li>
</ul>
<p><strong>授权访问</strong></p>
<ul>
<li><p>master客户端发送命令设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">requirepass &lt;password&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>master配置文件设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set requirepass &lt;password&gt; </span><br><span class="line">config get requirepass</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>slave客户端发送命令设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth &lt;password&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>slave配置文件设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;password&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>slave启动服务器设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-server –a &lt;password&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-3-第二阶段：数据同步"><a href="#1-2-3-第二阶段：数据同步" class="headerlink" title="1.2.3 第二阶段：数据同步"></a>1.2.3 第二阶段：数据同步</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_35_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_35_20210327.png" alt="img"></a></p>
<ul>
<li>全量复制<ul>
<li>将master执行bgsave之前，master中所有的数据同步到slave中</li>
</ul>
</li>
<li>部分复制（增量复制）<ul>
<li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li>
</ul>
</li>
</ul>
<h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol>
<li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行</li>
<li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在master端修改</span><br><span class="line">repl-backlog-size 1mb</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li>
</ol>
<h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol>
<li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave-serve-stale-data yes|no</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li>
<li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰</li>
<li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li>
</ol>
<h4 id="1-2-4-第三阶段：命令传播"><a href="#1-2-4-第三阶段：命令传播" class="headerlink" title="1.2.4 第三阶段：命令传播"></a>1.2.4 第三阶段：命令传播</h4><ul>
<li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong></li>
<li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li>
</ul>
<h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul>
<li>命令传播阶段出现了断网现象<ul>
<li>网络闪断闪连（忽略）</li>
<li>短时间网络中断（部分复制）</li>
<li>长时间网络中断（全量复制）</li>
</ul>
</li>
<li>部分复制的<strong>三个核心要素</strong><ul>
<li>服务器的运行 id（run id）</li>
<li>主服务器的复制积压缓冲区</li>
<li>主从服务器的复制偏移量</li>
</ul>
</li>
</ul>
<h5 id="核心一：服务器运行ID（runid）"><a href="#核心一：服务器运行ID（runid）" class="headerlink" title="核心一：服务器运行ID（runid）"></a>核心一：服务器运行ID（runid）</h5><ul>
<li>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id</li>
<li>组成：运行id由40位字符组成，是一个随机的十六进制字符<ul>
<li>例如：fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce</li>
</ul>
</li>
<li>作用：运行id被用于在服务器间进行传输，识别身份<ul>
<li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别</li>
</ul>
</li>
<li>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid</li>
</ul>
<h5 id="核心二：复制缓冲区"><a href="#核心二：复制缓冲区" class="headerlink" title="核心二：复制缓冲区"></a>核心二：复制缓冲区</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_36_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_36_20210327.png" alt="img"></a></p>
<ul>
<li><p>概念：</p>
<p>复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区</p>
</li>
<li><p>由来：</p>
<p>每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区</p>
</li>
<li><p>作用：</p>
<p>用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select）</p>
</li>
<li><p>数据来源：</p>
<p>当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中</p>
</li>
<li><p>复制缓冲区的工作原理：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_37_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_37_20210327.png" alt="img"></a></p>
</li>
</ul>
<h5 id="核心三：主从服务器复制偏移量（offset）"><a href="#核心三：主从服务器复制偏移量（offset）" class="headerlink" title="核心三：主从服务器复制偏移量（offset）"></a>核心三：主从服务器复制偏移量（offset）</h5><ul>
<li>概念：一个数字，描述复制缓冲区中的指令字节位置</li>
<li>分类：<ul>
<li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个）</li>
<li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个）</li>
</ul>
</li>
<li>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次</li>
<li>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用</li>
</ul>
<h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_38_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_38_20210327.png" alt="img"></a></p>
<h4 id="1-2-5-心跳机制"><a href="#1-2-5-心跳机制" class="headerlink" title="1.2.5 心跳机制"></a>1.2.5 心跳机制</h4><ul>
<li>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线</li>
<li>master心跳：<ul>
<li>指令：PING</li>
<li>周期：由repl-ping-slave-period决定，默认10秒</li>
<li>作用：判断slave是否在线</li>
<li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常</li>
</ul>
</li>
<li>slave心跳任务<ul>
<li>指令：REPLCONF ACK {offset}</li>
<li>周期：1秒</li>
<li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令</li>
<li>作用2：判断master是否在线</li>
</ul>
</li>
</ul>
<h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul>
<li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2 </span><br><span class="line">min-slaves-max-lag 8</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步</li>
</ul>
</li>
<li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认</p>
</li>
<li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p>
</li>
</ul>
<h4 id="1-2-6-主从复制完整流程"><a href="#1-2-6-主从复制完整流程" class="headerlink" title="1.2.6 主从复制完整流程"></a>1.2.6 主从复制完整流程</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_39_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_39_20210327.png" alt="img"></a></p>
<h3 id="1-3-主从复制常见问题"><a href="#1-3-主从复制常见问题" class="headerlink" title="1.3 主从复制常见问题"></a>1.3 主从复制常见问题</h3><h5 id="频繁的全量复制"><a href="#频繁的全量复制" class="headerlink" title="频繁的全量复制"></a>频繁的全量复制</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_40_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_40_20210327.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_41_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_41_20210327.png" alt="img"></a></p>
<h5 id="网络中断"><a href="#网络中断" class="headerlink" title="网络中断"></a>网络中断</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_42_20210327_.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_42_20210327_.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_43_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_43_20210327.png" alt="img"></a></p>
<h5 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_44_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_44_20210327.png" alt="img"></a></p>
<h2 id="2-哨兵模式"><a href="#2-哨兵模式" class="headerlink" title="2. 哨兵模式"></a>2. 哨兵模式</h2><h3 id="2-1-哨兵简介"><a href="#2-1-哨兵简介" class="headerlink" title="2.1 哨兵简介"></a>2.1 哨兵简介</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_45_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_45_20210327.png" alt="img"></a></p>
<h3 id="2-2-哨兵的定义"><a href="#2-2-哨兵的定义" class="headerlink" title="2.2 哨兵的定义"></a>2.2 哨兵的定义</h3><blockquote>
<p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_46_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_46_20210327.png" alt="img"></a></p>
<h3 id="2-3-哨兵的作用"><a href="#2-3-哨兵的作用" class="headerlink" title="2.3 哨兵的作用"></a>2.3 哨兵的作用</h3><ul>
<li>监控<ul>
<li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测</li>
</ul>
</li>
<li>通知（提醒）<ul>
<li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。</li>
</ul>
</li>
<li>自动故障转移<ul>
<li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong></p>
<h3 id="2-4-哨兵的配置"><a href="#2-4-哨兵的配置" class="headerlink" title="2.4 哨兵的配置"></a>2.4 哨兵的配置</h3><ul>
<li><p>配置一拖二的主从结构</p>
</li>
<li><p>配置三个哨兵（配置相同，端口不同）</p>
<ul>
<li>参看sentinel.conf</li>
</ul>
</li>
<li><p>启动哨兵</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel端口号 .conf</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_47_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_47_20210327.png" alt="img"></a></p>
<h3 id="2-5-哨兵工作原理"><a href="#2-5-哨兵工作原理" class="headerlink" title="2.5 哨兵工作原理"></a>2.5 哨兵工作原理</h3><p>主从切换</p>
<ul>
<li>哨兵在进行主从切换过程中经历三个阶段<ul>
<li>监控</li>
<li>通知</li>
<li>故障转移</li>
</ul>
</li>
</ul>
<h4 id="2-5-1-监控阶段"><a href="#2-5-1-监控阶段" class="headerlink" title="2.5.1 监控阶段"></a>2.5.1 监控阶段</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_48_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_48_20210327.png" alt="img"></a></p>
<ul>
<li>用于同步各个节点的状态信息<ul>
<li>获取各个sentinel的状态（是否在线）</li>
<li>获取master的状态<ul>
<li>master属性<ul>
<li>runid</li>
<li>role：master</li>
</ul>
</li>
<li>各个slave的详细信息</li>
</ul>
</li>
<li>获取所有slave的状态（根据master中的slave信息）<ul>
<li>slave属性<ul>
<li>runid</li>
<li>role：slave</li>
<li>master_host、master_port</li>
<li>offset</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_49_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_49_20210327.png" alt="img"></a></p>
<h4 id="2-5-2-通知阶段"><a href="#2-5-2-通知阶段" class="headerlink" title="2.5.2 通知阶段"></a>2.5.2 通知阶段</h4><ul>
<li>各个哨兵将得到的信息相互同步（信息对称）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_50_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_50_20210327.png" alt="img"></a></p>
<h4 id="2-5-3-故障转移阶段"><a href="#2-5-3-故障转移阶段" class="headerlink" title="2.5.3 故障转移阶段"></a>2.5.3 故障转移阶段</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_51_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_51_20210327.png" alt="img"></a></p>
<ul>
<li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li>
<li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li>
</ul>
<h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_52_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_52_20210327.png" alt="img"></a></p>
<ul>
<li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li>
<li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li>
</ul>
<h5 id="挑选新master"><a href="#挑选新master" class="headerlink" title="挑选新master"></a>挑选新master</h5><ul>
<li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul>
<li>服务器列表中挑选备选master<ul>
<li>在线的</li>
<li>响应慢的</li>
<li>与原master断开时间久的</li>
<li>优先原则<ul>
<li>优先级</li>
<li>offset</li>
<li>runid</li>
</ul>
</li>
</ul>
</li>
<li>发送指令（ sentinel ）<ul>
<li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li>
<li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-5-4-各阶段的总结"><a href="#2-5-4-各阶段的总结" class="headerlink" title="2.5.4 各阶段的总结"></a>2.5.4 各阶段的总结</h4><ul>
<li>监控<ul>
<li>同步信息</li>
</ul>
</li>
<li>通知<ul>
<li>保持联通</li>
</ul>
</li>
<li>故障转移<ul>
<li>发现问题</li>
<li>竞选负责人</li>
<li>优选新master</li>
<li>新master上任，其他slave切换master，原master作为slave故障恢复后连接</li>
</ul>
</li>
</ul>
<h2 id="3-集群"><a href="#3-集群" class="headerlink" title="3. 集群"></a>3. 集群</h2><h3 id="3-1-集群简介"><a href="#3-1-集群简介" class="headerlink" title="3.1 集群简介"></a>3.1 集群简介</h3><h4 id="3-1-1-集群架构"><a href="#3-1-1-集群架构" class="headerlink" title="3.1.1 集群架构"></a>3.1.1 集群架构</h4><ul>
<li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果</li>
</ul>
<h4 id="3-1-2-集群作用"><a href="#3-1-2-集群作用" class="headerlink" title="3.1.2 集群作用"></a>3.1.2 集群作用</h4><ul>
<li>分散单台服务器的访问压力，实现<strong>负载均衡</strong></li>
<li>分散单台服务器的存储压力，实现<strong>可扩展性</strong></li>
<li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong></li>
</ul>
<h3 id="3-2-集群结构设计"><a href="#3-2-集群结构设计" class="headerlink" title="3.2 集群结构设计"></a>3.2 集群结构设计</h3><h4 id="3-2-1-数据存储设计"><a href="#3-2-1-数据存储设计" class="headerlink" title="3.2.1 数据存储设计"></a>3.2.1 数据存储设计</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_53_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_53_20210328.png" alt="img"></a></p>
<ul>
<li><p>通过算法设计，计算出key应该保存的位置</p>
</li>
<li><p>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</p>
</li>
<li><p>将key按照计算出的结果放到对应的存储空间</p>
</li>
<li><p>增强可扩展性：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_54_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_54_20210328.png" alt="img"></a></p>
</li>
</ul>
<h4 id="3-2-2-集群内部通讯设计"><a href="#3-2-2-集群内部通讯设计" class="headerlink" title="3.2.2 集群内部通讯设计"></a>3.2.2 集群内部通讯设计</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_55_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_55_20210328.png" alt="img"></a></p>
<ul>
<li>各个数据库互相连通，保存各个库中槽的编号数据</li>
<li>一次命中，直接返回</li>
<li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li>
</ul>
<h4 id="3-2-3-集群cluster搭建"><a href="#3-2-3-集群cluster搭建" class="headerlink" title="3.2.3 集群cluster搭建"></a>3.2.3 集群cluster搭建</h4><h5 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h5><ul>
<li>修改一份redis-6379.conf</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_56_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_56_20210328.png" alt="img"></a></p>
<ul>
<li><p>复制5份，并修改端口名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sed &quot;s&#x2F;6379&#x2F;6380&#x2F;g&quot; redis-6379.conf &gt; redis-6380.conf</span><br><span class="line">sed &quot;s&#x2F;6379&#x2F;6381&#x2F;g&quot; redis-6379.conf &gt; redis-6381.conf</span><br><span class="line">sed &quot;s&#x2F;6379&#x2F;6382&#x2F;g&quot; redis-6379.conf &gt; redis-6382.conf</span><br><span class="line">sed &quot;s&#x2F;6379&#x2F;6383&#x2F;g&quot; redis-6379.conf &gt; redis-6383.conf</span><br><span class="line">sed &quot;s&#x2F;6379&#x2F;6384&#x2F;g&quot; redis-6379.conf &gt; redis-6384.conf</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>分别在6个客户端启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 执行6次</span><br><span class="line">redis-server 配置文件路径</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看服务是否启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_57_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_57_20210328.png" alt="img"></a></p>
<p>服务开启正常</p>
</li>
<li><p>查找redis-trib.rb的命令(该指令执行基于ruby，gem，需要安装)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ll | grep redis-</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_58_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_58_20210328.png" alt="img"></a></p>
</li>
<li><p>执行redis-trib命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 该命令只在当前目录下有效,--replicas代表集群结构，1表示每个master连接1个slave</span><br><span class="line">.&#x2F;redis-trib.rb create --replicas 1 127.0.0.1：6379 127.0.0.1：6380 127.0.0.1：6381 127.0.0.1：6382 127.0.0.1：6383 127.0.0.1：6384</span><br><span class="line"># 最后输入yes</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_59_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_59_20210328.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_60_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_60_20210328.png" alt="img"></a></p>
</li>
<li><p>完成运行后，每个node文件加入了糟分配信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_61_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_61_20210328.png" alt="img"></a></p>
</li>
<li><p>集群搭建完毕</p>
</li>
</ul>
<h5 id="集群设置与获取数据"><a href="#集群设置与获取数据" class="headerlink" title="集群设置与获取数据"></a>集群设置与获取数据</h5><ul>
<li>设置数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 操作集群</span><br><span class="line">redis-cli -c</span><br><span class="line">set name itheima</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>获取数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6382</span><br><span class="line"># 如果不在6382端口，下面会提示发生了重定向</span><br><span class="line">get name</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="主从下线与主从切换"><a href="#主从下线与主从切换" class="headerlink" title="主从下线与主从切换"></a>主从下线与主从切换</h5><ul>
<li><p>slave下线对功能不产生影响，会标记以下slave</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_62_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_62_20210328.png" alt="img"></a></p>
</li>
<li><p>master下线</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_63_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_63_20210328.png" alt="img"></a></p>
<p>之后slave会变为master</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 查看集群节点信息</span><br><span class="line">cluster nodes</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_64_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_64_20210328.png" alt="img"></a><br>master上线后，变为slave，之前的slave变为master<br><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_65_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_65_20210328.png" alt="img"></a></p>
</li>
</ul>
<h5 id="集群配置总结"><a href="#集群配置总结" class="headerlink" title="集群配置总结"></a>集群配置总结</h5><ul>
<li><p>设置加入cluster，成为其中节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-enabled yes | no</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>cluster配置文件名，该文件属于自动生成，仅用于快速查找文件并查询文件内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-config-file &lt;filename&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>节点服务响应超时时间，用于判定该节点是否下线或者切换为从节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-node-timeout &lt;millseconds&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>master连接的slave最小数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster-migration-barrier &lt;count&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="cluster节点操作指令总结"><a href="#cluster节点操作指令总结" class="headerlink" title="cluster节点操作指令总结"></a>cluster节点操作指令总结</h5><ul>
<li><p>查看集群节点信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster node</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>进入一个从节点redis，切换其为主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate &lt;master-id&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>发现一个新节点，新增主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster meet ip:port</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>忽略一个没有solt的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster forget &lt;id&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>手动故障转移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster failover</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-企业级解决方案"><a href="#4-企业级解决方案" class="headerlink" title="4. 企业级解决方案"></a>4. 企业级解决方案</h2><h3 id="4-1-缓存预热"><a href="#4-1-缓存预热" class="headerlink" title="4.1 缓存预热"></a>4.1 缓存预热</h3><h4 id="4-1-1-问题排查"><a href="#4-1-1-问题排查" class="headerlink" title="4.1.1 问题排查"></a>4.1.1 问题排查</h4><ul>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ul>
<h4 id="4-1-2-解决方案"><a href="#4-1-2-解决方案" class="headerlink" title="4.1.2 解决方案"></a>4.1.2 解决方案</h4><ul>
<li>前置准备工作：<ul>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列<ul>
<li>例如：storm与kafka配合</li>
</ul>
</li>
</ul>
</li>
<li>准备工作：<ul>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ul>
</li>
<li>实施：<ul>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了CDN（内容分发网络），效果会更好</li>
</ul>
</li>
</ul>
<h4 id="4-1-3-总结"><a href="#4-1-3-总结" class="headerlink" title="4.1.3 总结"></a>4.1.3 总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<h3 id="4-2-缓存雪崩"><a href="#4-2-缓存雪崩" class="headerlink" title="4.2 缓存雪崩"></a>4.2 缓存雪崩</h3><h4 id="4-2-1-数据库服务器崩溃（1）"><a href="#4-2-1-数据库服务器崩溃（1）" class="headerlink" title="4.2.1 数据库服务器崩溃（1）"></a>4.2.1 数据库服务器崩溃（1）</h4><ol>
<li>系统平稳运行过程中，忽然数据库连接量激增</li>
<li>应用服务器无法及时处理请求</li>
<li>大量408，500错误页面出现</li>
<li>客户反复刷新页面获取数据</li>
<li>数据库崩溃</li>
<li>应用服务器崩溃</li>
<li>重启应用服务器无效</li>
<li>Redis服务器崩溃</li>
<li>Redis集群崩溃</li>
<li>重启数据库后再次被瞬间流量放倒</li>
</ol>
<h4 id="4-2-2-问题排查"><a href="#4-2-2-问题排查" class="headerlink" title="4.2.2 问题排查"></a>4.2.2 问题排查</h4><ol>
<li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li>
<li>数据库同时接收到大量的请求无法及时处理</li>
<li>Redis大量请求被积压，开始出现超时现象</li>
<li>数据库流量激增，数据库崩溃</li>
<li>重启后仍然面对缓存中无数据可用</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃</li>
<li>Redis集群呈现崩塌，集群瓦解</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li>
<li>应用服务器，redis，数据库全部重启，效果不理想</li>
</ol>
<h4 id="4-2-3-问题分析"><a href="#4-2-3-问题分析" class="headerlink" title="4.2.3 问题分析"></a>4.2.3 问题分析</h4><ul>
<li>短时间范围内</li>
<li>大量key集中过期</li>
</ul>
<h4 id="4-2-4-解决方案（道）"><a href="#4-2-4-解决方案（道）" class="headerlink" title="4.2.4 解决方案（道）"></a>4.2.4 解决方案（道）</h4><ol>
<li><p>更多的页面静态化处理</p>
</li>
<li><p>构建<strong>多级缓存架构</strong></p>
<ul>
<li>Nginx缓存+redis缓存+ehcache缓存</li>
</ul>
</li>
<li><p>检测Mysql严重耗时业务进行优化</p>
<ul>
<li>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</li>
</ul>
</li>
<li><p>灾难预警机制</p>
<p>监控redis服务器性能指标</p>
<ul>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
</li>
<li><p>限流、降级</p>
<ul>
<li>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
</ul>
</li>
</ol>
<h4 id="4-2-5-解决方案（术）"><a href="#4-2-5-解决方案（术）" class="headerlink" title="4.2.5 解决方案（术）"></a>4.2.5 解决方案（术）</h4><ol>
<li>LRU与LFU切换</li>
<li>数据有效期策略调整<ul>
<li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量</li>
</ul>
</li>
<li><strong>超热</strong>数据使用永久key</li>
<li>定期维护（自动+人工）<ul>
<li>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
</ul>
</li>
<li>加锁 <strong>慎用！</strong></li>
</ol>
<h4 id="4-2-6-总结"><a href="#4-2-6-总结" class="headerlink" title="4.2.6 总结"></a>4.2.6 总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_66_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_66_20210328.png" alt="img"></a></p>
<h3 id="4-3-缓存击穿"><a href="#4-3-缓存击穿" class="headerlink" title="4.3 缓存击穿"></a>4.3 缓存击穿</h3><h4 id="4-3-1-数据库服务器崩溃（2）"><a href="#4-3-1-数据库服务器崩溃（2）" class="headerlink" title="4.3.1 数据库服务器崩溃（2）"></a>4.3.1 数据库服务器崩溃（2）</h4><ol>
<li>系统平稳运行过程中</li>
<li>数据库连接量<strong>瞬间激增</strong></li>
<li>Redis服务器无大量key过期</li>
<li>Redis内存平稳，无波动</li>
<li>Redis服务器CPU正常</li>
<li><strong>数据库崩溃</strong></li>
</ol>
<h4 id="4-3-2-问题排查"><a href="#4-3-2-问题排查" class="headerlink" title="4.3.2 问题排查"></a>4.3.2 问题排查</h4><ol>
<li>Redis中<strong>某个key过期，该key访问量巨大</strong></li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问</li>
</ol>
<h4 id="4-3-3-问题分析"><a href="#4-3-3-问题分析" class="headerlink" title="4.3.3 问题分析"></a>4.3.3 问题分析</h4><ul>
<li>单个key高热数据</li>
<li>key过期</li>
</ul>
<h4 id="4-3-4-解决方案（术）"><a href="#4-3-4-解决方案（术）" class="headerlink" title="4.3.4 解决方案（术）"></a>4.3.4 解决方案（术）</h4><ol>
<li><p>预先设定</p>
<p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong></p>
<p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p>
</li>
<li><p>现场调整</p>
<ul>
<li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key</li>
</ul>
</li>
<li><p>后台刷新数据</p>
<ul>
<li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失</li>
</ul>
</li>
<li><p>二级缓存</p>
<ul>
<li>设置不同的失效时间，保障不会被同时淘汰就行</li>
</ul>
</li>
<li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong></p>
</li>
</ol>
<h4 id="4-3-5-总结"><a href="#4-3-5-总结" class="headerlink" title="4.3.5 总结"></a>4.3.5 总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p>
<h3 id="4-4-缓存穿透"><a href="#4-4-缓存穿透" class="headerlink" title="4.4 缓存穿透"></a>4.4 缓存穿透</h3><h4 id="4-4-1-数据库服务器崩溃（3）"><a href="#4-4-1-数据库服务器崩溃（3）" class="headerlink" title="4.4.1 数据库服务器崩溃（3）"></a>4.4.1 数据库服务器崩溃（3）</h4><ol>
<li>系统平稳运行过程中</li>
<li>应用服务器流量随时间增量较大</li>
<li>Redis服务器命中率随时间逐步降低</li>
<li>Redis内存平稳，内存无压力</li>
<li>Redis服务器CPU占用激增</li>
<li>数据库服务器压力激增</li>
<li><strong>数据库崩溃</strong></li>
</ol>
<h4 id="4-4-2-问题排查"><a href="#4-4-2-问题排查" class="headerlink" title="4.4.2 问题排查"></a>4.4.2 问题排查</h4><ol>
<li>Redis中大面积出限未命中</li>
<li>出现<strong>非正常URL访问</strong></li>
</ol>
<h4 id="4-4-3-问题分析"><a href="#4-4-3-问题分析" class="headerlink" title="4.4.3 问题分析"></a>4.4.3 问题分析</h4><ul>
<li>获取的数据在数据库中也不存在，数据库查询未得到对于数据</li>
<li>Redis获取到null数据未进行持久化，直接返回</li>
<li>下次此类数据到达重复上述过程</li>
<li>出限黑客攻击服务器</li>
</ul>
<h4 id="4-4-4-解决方案（术）"><a href="#4-4-4-解决方案（术）" class="headerlink" title="4.4.4 解决方案（术）"></a>4.4.4 解决方案（术）</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_67_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_67_20210328.png" alt="img"></a></p>
<h4 id="4-4-5-总结"><a href="#4-4-5-总结" class="headerlink" title="4.4.5 总结"></a>4.4.5 总结</h4><p>缓存基础访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低值，当出现此类情况以毒攻毒，并即使报警。应对策略应该在临时预案防范方面多做文章。</p>
<p>（目标就是拦在服务器外面，用bitmaps就是拦到redis和服务器中间，用加密key就是拦到应用服务器外面）</p>
<p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h3 id="4-5-性能指标监控"><a href="#4-5-性能指标监控" class="headerlink" title="4.5 性能指标监控"></a>4.5 性能指标监控</h3><h4 id="4-5-1-监控指标"><a href="#4-5-1-监控指标" class="headerlink" title="4.5.1 监控指标"></a>4.5.1 监控指标</h4><ul>
<li><p>性能指标：Performance</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_68_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_68_20210328.png" alt="img"></a></p>
</li>
<li><p>内存指标： Memory</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_69_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_69_20210328.png" alt="img"></a></p>
</li>
<li><p>基本活动指标：Basic acticity</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_70_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_70_20210328.png" alt="img"></a></p>
</li>
<li><p>持久性指标：Persistence</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_71_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_71_20210328.png" alt="img"></a></p>
</li>
<li><p>错误指标：Error</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_72_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_72_20210328.png" alt="img"></a></p>
</li>
</ul>
<h4 id="4-5-2-监控方式"><a href="#4-5-2-监控方式" class="headerlink" title="4.5.2 监控方式"></a>4.5.2 监控方式</h4><ul>
<li>工具<ul>
<li>Cloud Insight Redis</li>
<li>Prometheus</li>
<li>Redis-stat</li>
<li>Redis-faina</li>
<li>RedisLive</li>
<li>zabbix</li>
</ul>
</li>
<li>命令<ul>
<li>benchmark</li>
<li>redis cli<ul>
<li>monitor</li>
<li>showlog</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h5><ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark [-h ] [-p ] [-c ] [-n &lt;requests]&gt; [-k ]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_73_20210328.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_73_20210328.png" alt="img"></a></p>
</li>
</ul>
<h5 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h5><ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monitor</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>打印服务器调试信息</p>
</li>
</ul>
<h5 id="showlog"><a href="#showlog" class="headerlink" title="showlog"></a>showlog</h5><ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog [operator]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>get：获取慢查询日志</li>
<li>len：获取慢查询日志条目数</li>
<li>reset：充值慢查询日志</li>
</ul>
</li>
<li><p>相关配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slowlog-log-slower-than 1000 # 设置慢查询的时间下限，单位ms</span><br><span class="line">slowlog-max-len 100          # 设置慢查询命令对应的日志显示长度，单位命令数</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="cknmwaip60003j4ubahtqd5p2" data-title="redis集群与企业级解决方案" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:35:09.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/">redis高级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><p>基于<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>的视频的学习笔记</p>
<h2 id="1-Linux环节安装"><a href="#1-Linux环节安装" class="headerlink" title="1. Linux环节安装"></a>1. Linux环节安装</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_12_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_12_20210326.png" alt="img"></a></p>
<h3 id="1-2-启动方式"><a href="#1-2-启动方式" class="headerlink" title="1.2 启动方式"></a>1.2 启动方式</h3><ul>
<li>普通默认端口启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认端口开启</span><br><span class="line">redis-serve</span><br><span class="line"># 默认端口连接</span><br><span class="line">redis-cli</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>指定端口启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 换端口启动</span><br><span class="line">redis-server --port 6380</span><br><span class="line"># 连接客户端指定端口连接</span><br><span class="line">redis-cli -p 6380</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>指定配置文件启动 redis-6379.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">daemonize yes</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dir &#x2F;redis-4.0.0&#x2F;data</span><br><span class="line">Copy</span><br><span class="line"># 启动</span><br><span class="line">redis-server redis-6379.conf</span><br><span class="line">redis-server conf&#x2F;redis-6379.conf</span><br><span class="line"># 连接</span><br><span class="line">redis-cli</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="2-持久化"><a href="#2-持久化" class="headerlink" title="2. 持久化"></a>2. 持久化</h2><h3 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1 基本介绍"></a>2.1 基本介绍</h3><blockquote>
<p>什么是持久化：</p>
</blockquote>
<p>利用永久性存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制</p>
<blockquote>
<p>为什么要持久化：</p>
</blockquote>
<p>防止数据的意外丢失，确保数据安全</p>
<blockquote>
<p>持久化过程保存什么</p>
</blockquote>
<ul>
<li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong></li>
<li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_13_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_13_20210326.png" alt="img"></a></p>
<h3 id="2-2-RDB"><a href="#2-2-RDB" class="headerlink" title="2.2 RDB"></a>2.2 RDB</h3><h4 id="2-2-1-RDB启动方式1–save指令"><a href="#2-2-1-RDB启动方式1–save指令" class="headerlink" title="2.2.1 RDB启动方式1–save指令"></a>2.2.1 RDB启动方式1–save指令</h4><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>手动执行一次保存操作</p>
</li>
</ul>
<h5 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h5><ul>
<li>dbfilename dump.rdb<ul>
<li>说明：设置本地数据库文件名，默认值为 dump.rdb</li>
<li>经验：通常设置为<strong>dump-<strong><strong>端口号</strong></strong>.rdb</strong></li>
</ul>
</li>
<li>dir<ul>
<li>说明：设置存储.rdb文件的路径</li>
<li>经验：通常设置成存储空间较大的目录中，目录名称<strong>data</strong></li>
</ul>
</li>
<li>rdbcompression yes<ul>
<li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大）</li>
</ul>
</li>
<li>rdbchecksum yes<ul>
<li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行</li>
<li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险</li>
</ul>
</li>
</ul>
<p>配置后，conf文件内容为：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_14_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_14_20210326.png" alt="img"></a></p>
<h5 id="save指令工作原理"><a href="#save指令工作原理" class="headerlink" title="save指令工作原理"></a>save指令工作原理</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_15_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_15_20210326.png" alt="img"></a></p>
<h4 id="2-2-2-RDB启动方式2–bgsave指令"><a href="#2-2-2-RDB启动方式2–bgsave指令" class="headerlink" title="2.2.2 RDB启动方式2–bgsave指令"></a>2.2.2 RDB启动方式2–bgsave指令</h4><h5 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h5><ul>
<li><p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bgsave</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>作用</p>
<p>手动启动后台保存操作，但<strong>不是立即执行</strong></p>
</li>
</ul>
<h5 id="相关配置-1"><a href="#相关配置-1" class="headerlink" title="相关配置"></a>相关配置</h5><ul>
<li>dbfilename dump.rdb（同save）</li>
<li>dir（同save）</li>
<li>rdbcompression yes（同save）</li>
<li>rdbchecksum yes（同save）</li>
<li>stop-writes-on-bgsave-error yes<ul>
<li>说明：后台存储过程中如果出现错误现象，是否停止保存现象</li>
<li>经验：通常默认为开启状态</li>
</ul>
</li>
</ul>
<h5 id="bgsave指令工作原理"><a href="#bgsave指令工作原理" class="headerlink" title="bgsave指令工作原理"></a>bgsave指令工作原理</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_16_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_16_20210326.png" alt="img"></a></p>
<h4 id="2-2-3-RDB启动方式3–save配置"><a href="#2-2-3-RDB启动方式3–save配置" class="headerlink" title="2.2.3 RDB启动方式3–save配置"></a>2.2.3 RDB启动方式3–save配置</h4><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><ul>
<li><p>配置到.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save second changes</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>配置后：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_17_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_17_20210326.png" alt="img"></a></p>
</li>
<li><p>作用</p>
<p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化</p>
</li>
<li><p>参数</p>
<ul>
<li>second：监控时间范围</li>
<li>changes：监控key的变化量</li>
</ul>
</li>
</ul>
<h5 id="save配置工作原理"><a href="#save配置工作原理" class="headerlink" title="save配置工作原理"></a>save配置工作原理</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_18_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_18_20210326.png" alt="img"></a></p>
<p>注意：</p>
<ul>
<li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的</li>
<li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系</li>
<li>save配置启动后执行的是<strong>bgsave操作</strong></li>
</ul>
<h4 id="2-2-4-三种启动方式对比"><a href="#2-2-4-三种启动方式对比" class="headerlink" title="2.2.4 三种启动方式对比"></a>2.2.4 三种启动方式对比</h4><table>
<thead>
<tr>
<th>方式</th>
<th>save指令</th>
<th>bgsave指令</th>
</tr>
</thead>
<tbody><tr>
<td>读写</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞客户端指令</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>额外内存消耗</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>启动新线程</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="2-2-5-RDB特殊启动形式（了解）"><a href="#2-2-5-RDB特殊启动形式（了解）" class="headerlink" title="2.2.5 RDB特殊启动形式（了解）"></a>2.2.5 RDB特殊启动形式（了解）</h4><ul>
<li><p>全量复制</p>
<p>在主从复制中详细讲解</p>
</li>
<li><p>服务器运行过程中重启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug reload</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>关闭服务器时指定保存数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown save</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-6-RDB优缺点"><a href="#2-2-6-RDB优缺点" class="headerlink" title="2.2.6 RDB优缺点"></a>2.2.6 RDB优缺点</h4><ul>
<li>优点<ul>
<li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong></li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景</li>
<li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li>
</ul>
</li>
<li>缺点<ul>
<li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li>
<li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong></li>
<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象</li>
</ul>
</li>
</ul>
<h3 id="2-3-AOF"><a href="#2-3-AOF" class="headerlink" title="2.3 AOF"></a>2.3 AOF</h3><h4 id="2-3-1-AOF概念"><a href="#2-3-1-AOF概念" class="headerlink" title="2.3.1 AOF概念"></a>2.3.1 AOF概念</h4><ul>
<li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程</li>
<li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式</li>
</ul>
<h4 id="2-3-2-AOF写数据过程"><a href="#2-3-2-AOF写数据过程" class="headerlink" title="2.3.2 AOF写数据过程"></a>2.3.2 AOF写数据过程</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_20_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_20_20210326.png" alt="img"></a></p>
<h4 id="2-3-3-AOF写数据三种策略-appendfsync"><a href="#2-3-3-AOF写数据三种策略-appendfsync" class="headerlink" title="2.3.3 AOF写数据三种策略(appendfsync)"></a>2.3.3 AOF写数据三种策略(appendfsync)</h4><ul>
<li>always（每次）<ul>
<li>每次写入操作均同步到AOF文件中，<strong>数据零误差</strong>，<strong>性能较低</strong>，<strong>不建议使用</strong></li>
</ul>
</li>
<li>everysec（每秒）<ul>
<li>每秒将缓冲区中的指令同步到AOF文件中，数据<strong>准确性较高</strong>，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置</li>
<li>在系统突然宕机的情况下丢失1秒内的数据</li>
</ul>
</li>
<li>no（系统控制）<ul>
<li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong></li>
</ul>
</li>
</ul>
<h4 id="2-3-4-AOF功能开启"><a href="#2-3-4-AOF功能开启" class="headerlink" title="2.3.4 AOF功能开启"></a>2.3.4 AOF功能开启</h4><ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes|no</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>作用</li>
</ul>
<p>是否开启AOF持久化功能，<strong>默认为不开启状态</strong></p>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always|everysec|no</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用</p>
<p>AOF写数据策略</p>
</li>
</ul>
</li>
</ul>
<p>配置后，conf配置文件如下：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_19_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_19_20210326.png" alt="img"></a></p>
<h4 id="2-3-5-AOF相关配置"><a href="#2-3-5-AOF相关配置" class="headerlink" title="2.3.5 AOF相关配置"></a>2.3.5 AOF相关配置</h4><ul>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendfilename filename</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>作用</li>
</ul>
<p>AOF持久化文件名，默认文件名为appendonly.aof，建议配置为appendonly-端口号.aof</p>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dir</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>作用</p>
<p>AOF持久化文件保存路径，与RDB持久化文件保持一致即可</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-6-AOF重写"><a href="#2-3-6-AOF重写" class="headerlink" title="2.3.6 AOF重写"></a>2.3.6 AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效指令，重写时使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入命令<ul>
<li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等</li>
</ul>
</li>
<li>对同一数据的多条写命令合并为一条命令<ul>
<li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li>
<li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素</li>
</ul>
</li>
</ul>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ul>
<li><p>手动重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bgrewriteaof</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1.触发条件设置</span><br><span class="line"># 触发重写的最小大小</span><br><span class="line">auto-aof-rewrite-min-size size </span><br><span class="line"># 触发重写须达到的最小百分比 </span><br><span class="line">auto-aof-rewrite-percentage percentage</span><br><span class="line"></span><br><span class="line"># 2.触发比对参数（ 运行指令info Persistence获取具体信息 ）</span><br><span class="line"># 当前.aof的文件大小</span><br><span class="line">aof_current_size </span><br><span class="line"># 基础文件大小</span><br><span class="line">aof_base_size</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>自动重写触发条件</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_22_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_22_20210326.png" alt="img"></a></p>
</li>
</ul>
<h5 id="重写工作原理"><a href="#重写工作原理" class="headerlink" title="重写工作原理"></a>重写工作原理</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_21_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_21_20210326.png" alt="img"></a></p>
<h5 id="重写工作流程"><a href="#重写工作流程" class="headerlink" title="重写工作流程"></a>重写工作流程</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_23_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_23_20210326.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_24_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_24_20210326.png" alt="img"></a></p>
<h3 id="2-4-RDB与AOF的区别"><a href="#2-4-RDB与AOF的区别" class="headerlink" title="2.4 RDB与AOF的区别"></a>2.4 RDB与AOF的区别</h3><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用存储空间</td>
<td>小（数据级：压缩）</td>
<td>大（指令级：重写）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="2-5-RDB与AOF的选择"><a href="#2-5-RDB与AOF的选择" class="headerlink" title="2.5 RDB与AOF的选择"></a>2.5 RDB与AOF的选择</h3><ul>
<li>对数据非常敏感，建议使用默认的AOF持久化方案<ul>
<li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。</li>
<li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong></li>
</ul>
</li>
<li>数据呈现阶段有效性，建议使用RDB持久化方案<ul>
<li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案</li>
<li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li>
</ul>
</li>
<li>综合比对<ul>
<li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li>
<li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong></li>
<li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong></li>
<li><strong>灾难恢复选用RDB</strong></li>
<li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li>
</ul>
</li>
</ul>
<h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3. 事务"></a>3. 事务</h2><h3 id="3-1-事务简介"><a href="#3-1-事务简介" class="headerlink" title="3.1 事务简介"></a>3.1 事务简介</h3><blockquote>
<p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p>
</blockquote>
<h3 id="3-2-事务基本操作"><a href="#3-2-事务基本操作" class="headerlink" title="3.2 事务基本操作"></a>3.2 事务基本操作</h3><ul>
<li><p>开启事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multi</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
</ul>
</li>
<li><p>取消事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discard</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>作用终止当前事务的定义，发生在multi之后，exec之前</li>
</ul>
</li>
<li><p>执行事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exec</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>作用：设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用</li>
</ul>
</li>
</ul>
<h3 id="3-3-事务工作流程"><a href="#3-3-事务工作流程" class="headerlink" title="3.3 事务工作流程"></a>3.3 事务工作流程</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_25_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_25_20210326.png" alt="img"></a></p>
<h3 id="3-4-事务注意事项"><a href="#3-4-事务注意事项" class="headerlink" title="3.4 事务注意事项"></a>3.4 事务注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p>
<ul>
<li>语法错误<ul>
<li>指命令书写格式有误 例如执行了一条不存在的指令</li>
</ul>
</li>
<li>处理结果<ul>
<li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li>
</ul>
</li>
</ul>
<p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong></p>
<ul>
<li>运行错误<ul>
<li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作</li>
</ul>
</li>
<li>处理结果<ul>
<li>能够正确运行的命令会执行，运行错误的命令不会被执行</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。</p>
<h3 id="3-5-锁"><a href="#3-5-锁" class="headerlink" title="3.5 锁"></a>3.5 锁</h3><h4 id="3-5-1-基于特定条件的事务执行–锁"><a href="#3-5-1-基于特定条件的事务执行–锁" class="headerlink" title="3.5.1 基于特定条件的事务执行–锁"></a>3.5.1 基于特定条件的事务执行–锁</h4><p>监视锁类似CAS的思想，如果监视对象在事务执行前被修改了，那么就不执行了</p>
<ul>
<li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watch key1, key2....</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>取消对<strong>所有</strong>key的监视</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unwatch</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-2基于特定条件的事务执行–分布式锁"><a href="#3-5-2基于特定条件的事务执行–分布式锁" class="headerlink" title="3.5.2基于特定条件的事务执行–分布式锁"></a>3.5.2基于特定条件的事务执行–分布式锁</h4><p>分布式锁类似悲观锁的思想，但是只是一个标记</p>
<ul>
<li><p>使用 setnx 设置一个公共锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 上锁</span><br><span class="line">setnx lock-key value</span><br><span class="line"># 释放锁</span><br><span class="line">del lock-key</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li>
<li>操作完毕通过del操作释放锁</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性</p>
<h4 id="3-5-3-分布式锁改良"><a href="#3-5-3-分布式锁改良" class="headerlink" title="3.5.3 分布式锁改良"></a>3.5.3 分布式锁改良</h4><ul>
<li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expire lock-key seconds</span><br><span class="line">pexpire lock-key millisecondsCopy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。</p>
<ul>
<li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。</li>
<li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时</li>
<li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110%</li>
<li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li>
</ul>
</li>
</ul>
<h2 id="4-删除策略"><a href="#4-删除策略" class="headerlink" title="4. 删除策略"></a>4. 删除策略</h2><h3 id="4-1-数据删除策略"><a href="#4-1-数据删除策略" class="headerlink" title="4.1 数据删除策略"></a>4.1 数据删除策略</h3><ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_26_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_26_20210327.png" alt="img"></a></p>
<h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露</p>
<h3 id="4-2-三种删除策略"><a href="#4-2-三种删除策略" class="headerlink" title="4.2 三种删除策略"></a>4.2 三种删除策略</h3><h4 id="4-2-1-定时删除"><a href="#4-2-1-定时删除" class="headerlink" title="4.2.1 定时删除"></a>4.2.1 定时删除</h4><ul>
<li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</li>
<li>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用</li>
<li>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li>
<li>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</li>
</ul>
<h4 id="4-2-2-惰性删除"><a href="#4-2-2-惰性删除" class="headerlink" title="4.2.2 惰性删除"></a>4.2.2 惰性删除</h4><ul>
<li>数据到达过期时间，不做处理。等下次访问该数据时<ul>
<li>如果未过期，返回数据</li>
<li>发现已过期，删除，返回不存在</li>
</ul>
</li>
<li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除</li>
<li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据</li>
<li>总结：用存储空间换取处理器性能 （<strong>拿空间换时间</strong>）</li>
</ul>
<h4 id="4-2-3-定期删除（折中方案）"><a href="#4-2-3-定期删除（折中方案）" class="headerlink" title="4.2.3 定期删除（折中方案）"></a>4.2.3 定期删除（折中方案）</h4><ul>
<li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度</li>
<li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li>
<li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li>
<li>总结：周期性抽查存储空间 （随机抽查，重点抽查）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_27_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_27_20210327.png" alt="img"></a></p>
<h4 id="4-2-4-删除策略对比"><a href="#4-2-4-删除策略对比" class="headerlink" title="4.2.4 删除策略对比"></a>4.2.4 删除策略对比</h4><table>
<thead>
<tr>
<th>删除策略</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频率高</td>
<td>拿时间换空间</td>
</tr>
<tr>
<td>惰性删除</td>
<td>内存占用严重</td>
<td>延时执行，CPU利用率高</td>
<td>拿空间换时间</td>
</tr>
<tr>
<td>定期删除</td>
<td>内存定期随机清理</td>
<td>每秒花费固定的CPU资源维护内存</td>
<td>随机抽查，重点抽查</td>
</tr>
</tbody></table>
<p>redis内部一般使用惰性删除和定期删除</p>
<h3 id="4-3-逐出算法（淘汰算法）"><a href="#4-3-逐出算法（淘汰算法）" class="headerlink" title="4.3 逐出算法（淘汰算法）"></a>4.3 逐出算法（淘汰算法）</h3><p>**当新数据进入redis时，如果内存不足怎么办？ **</p>
<ul>
<li>Redis使用内存存储数据，在执行每一个命令前，会调用**freeMemoryIfNeeded()*<em>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为*<em>逐出算法</em></em></li>
<li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。</li>
</ul>
<h4 id="4-3-1-影响数据逐出的相关配置"><a href="#4-3-1-影响数据逐出的相关配置" class="headerlink" title="4.3.1 影响数据逐出的相关配置"></a>4.3.1 影响数据逐出的相关配置</h4><ul>
<li><p>最大可使用内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。</p>
</li>
<li><p>每次选取待删除数据的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-samples</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p>
</li>
<li><p>删除策略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>达到最大内存后的，对被挑选出来的数据进行删除的策略</p>
</li>
<li><p>删除策略包括以下8种不同设置：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_28_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_28_20210327.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置方式</span><br><span class="line">maxmemory-policy volatile-lru</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-3-2-数据逐出策略配置依据"><a href="#4-3-2-数据逐出策略配置依据" class="headerlink" title="4.3.2 数据逐出策略配置依据"></a>4.3.2 数据逐出策略配置依据</h4><ul>
<li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_29_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_29_20210327.png" alt="img"></a></p>
<h2 id="5-服务器基础配置"><a href="#5-服务器基础配置" class="headerlink" title="5. 服务器基础配置"></a>5. 服务器基础配置</h2><h3 id="5-1-服务器端设定"><a href="#5-1-服务器端设定" class="headerlink" title="5.1 服务器端设定"></a>5.1 服务器端设定</h3><p>设置到conf文件中</p>
<ul>
<li>设置服务器以守护进程的方式运行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes | no</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定主机地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>设置服务器端口号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>设置数据库数量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">database 16</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_30_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_30_20210327.png" alt="img"></a></p>
<h3 id="5-2-日志配置"><a href="#5-2-日志配置" class="headerlink" title="5.2 日志配置"></a>5.2 日志配置</h3><ul>
<li>设置服务器以指定日志记录级别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loglevel debug|verbose|notice|warning</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>日志记录文件名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logfile 端口号.log</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</p>
<h3 id="5-3-客户端配置"><a href="#5-3-客户端配置" class="headerlink" title="5.3 客户端配置"></a>5.3 客户端配置</h3><ul>
<li>设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxclients 0</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端闲置等待最大时长，达到最大值后关闭连接。如需关闭该功能，设置为0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout 300</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="5-4-多服务器快捷配置"><a href="#5-4-多服务器快捷配置" class="headerlink" title="5.4 多服务器快捷配置"></a>5.4 多服务器快捷配置</h3><ul>
<li>导入并加载指定配置文件信息，用于快速船舰redis公共配置较多的redis实例配置文件，便于维护</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &#x2F;path&#x2F;server-端口号.conf</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="6-高级数据类型"><a href="#6-高级数据类型" class="headerlink" title="6. 高级数据类型"></a>6. 高级数据类型</h2><h3 id="6-1-Bitmaps"><a href="#6-1-Bitmaps" class="headerlink" title="6.1 Bitmaps"></a>6.1 Bitmaps</h3><h4 id="6-1-1-基础操作"><a href="#6-1-1-基础操作" class="headerlink" title="6.1.1 基础操作"></a>6.1.1 基础操作</h4><ul>
<li><p>获取指定key对应偏移量上的bit值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-1-2-扩展操作"><a href="#6-1-2-扩展操作" class="headerlink" title="6.1.2 扩展操作"></a>6.1.2 扩展操作</h4><ul>
<li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitop op destKey key1 [key2...]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>and：交</li>
<li>or：并</li>
<li>not：非</li>
<li>xor：异或</li>
</ul>
</li>
<li><p>统计指定key中1的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-2-HyperLogLog"><a href="#6-2-HyperLogLog" class="headerlink" title="6.2 HyperLogLog"></a>6.2 HyperLogLog</h3><h4 id="6-2-1-基数"><a href="#6-2-1-基数" class="headerlink" title="6.2.1 基数"></a>6.2.1 基数</h4><ul>
<li>基数是数据集<strong>去重后元素个数</strong></li>
<li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_31_20210327.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_31_20210327.png" alt="img"></a></p>
<h4 id="6-2-2-基本操作"><a href="#6-2-2-基本操作" class="headerlink" title="6.2.2 基本操作"></a>6.2.2 基本操作</h4><ul>
<li><p>添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element1, element2...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>统计数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pfcount key1 key2....</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>合并数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey...]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-2-3-相关说明"><a href="#6-2-3-相关说明" class="headerlink" title="6.2.3 相关说明"></a>6.2.3 相关说明</h4><ul>
<li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据</li>
<li>核心是基数估算算法，最终数值<strong>存在一定误差</strong></li>
<li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li>
<li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数</li>
<li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong></li>
<li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少</li>
</ul>
<h3 id="6-3-GEO"><a href="#6-3-GEO" class="headerlink" title="6.3 GEO"></a>6.3 GEO</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ul>
<li><p>添加坐标点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...] </span><br><span class="line">georadius key longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>获取坐标点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geopos key member [member ...] </span><br><span class="line">georadiusbymember key member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>计算坐标点距离</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">geodist key member1 member2 [unit] </span><br><span class="line">geohash key member [member ...]</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/redis%E9%AB%98%E7%BA%A7/" data-id="cknmwaip60004j4ubhncs1eyz" data-title="redis高级" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-redis基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/redis%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:34:19.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/redis%E5%9F%BA%E7%A1%80/">redis基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><p>学习Javaweb时，学习过Redis的基本使用，学习<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CJ411m7Gc">黑马Redis</a>进阶内容顺带复习一下基础，整理本学习笔记</p>
<h2 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h2><h3 id="1-1-NoSQL简介"><a href="#1-1-NoSQL简介" class="headerlink" title="1.1 NoSQL简介"></a>1.1 NoSQL简介</h3><p>NoSQL：即Not-OnlySQL（泛指非关系性数据库），作为关系型数据库的补充</p>
<p>作用：应对基于海量数据和海量用户的数据处理。</p>
<p>特征：</p>
<ul>
<li>可扩容，可伸展</li>
<li>大数据量下高性能</li>
<li>灵活的数据模型</li>
<li>高可用</li>
</ul>
<p>常见的NoSQL数据库：</p>
<ul>
<li><strong>Redis</strong></li>
<li>memcache</li>
<li>HBase</li>
<li>MongoDB</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_2_20210325.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_2_20210325.png" alt="img"></a></p>
<h3 id="1-2-Redis简介"><a href="#1-2-Redis简介" class="headerlink" title="1.2 Redis简介"></a>1.2 Redis简介</h3><blockquote>
<p>概念：Redis（REmote DIctionary Server）是用C语言开发的一个开源的高性能键值对（key-value）数据库。</p>
</blockquote>
<p>特征：</p>
<ul>
<li>数据之间没有必然的联系</li>
<li>内部采用了单线程机制进行工作</li>
<li>高性能</li>
<li>多数据类型支持<ul>
<li>String</li>
<li>list</li>
<li>hash</li>
<li>set</li>
<li>sorted_set</li>
</ul>
</li>
<li>持久化支持，可以进行数据灾难恢复</li>
</ul>
<p>应用：</p>
<ul>
<li>热点数据加速查询（热点资讯，热点商品）</li>
<li>任务队列（秒杀）</li>
<li>即使信息查询（排行榜）</li>
<li>时效性习性控制（验证码）</li>
<li>分布式数据共享（分布式集群中的session分离）</li>
<li>消息队列</li>
<li>分布式锁</li>
</ul>
<h3 id="1-3-Redis常用指令"><a href="#1-3-Redis常用指令" class="headerlink" title="1.3 Redis常用指令"></a>1.3 Redis常用指令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 启动容器</span><br><span class="line">docker run -d -p 6379:6379 -it  --name&#x3D;&quot;myredis&quot;  redis</span><br><span class="line"># 输入密码：</span><br><span class="line">auth 密码</span><br><span class="line"># 进入redis容器</span><br><span class="line">docker exec -it myredis  redis-cli</span><br><span class="line"># 退出</span><br><span class="line">quit</span><br><span class="line">exit</span><br><span class="line"># 清屏</span><br><span class="line">clear</span><br><span class="line"># 获取帮助, 可以使用Tab键来切换</span><br><span class="line">help 命令名称</span><br><span class="line">help @组名</span><br><span class="line"># 设置&#x2F;获取数据</span><br><span class="line">set name xlh</span><br><span class="line">get name</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><p>redis数据存储格式</p>
<ul>
<li>redis自身是一个map，其中所有的数据都是采用的key：value的形式存储[^1]</li>
<li>数据类型指的是value部分的类型，key部分都是String</li>
</ul>
<h3 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h3><h4 id="2-1-1-基本操作"><a href="#2-1-1-基本操作" class="headerlink" title="2.1.1 基本操作"></a>2.1.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 设置String</span><br><span class="line">set key value</span><br><span class="line">mset key1 value1 key2 value2...</span><br><span class="line"></span><br><span class="line"># 得到String</span><br><span class="line">get key </span><br><span class="line">mget key1 key2...</span><br><span class="line"># 获取字符串长度</span><br><span class="line">strlen key</span><br><span class="line"></span><br><span class="line"># 删除String</span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"># 向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span><br><span class="line">append key value</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-单-多指令对比"><a href="#2-1-2-单-多指令对比" class="headerlink" title="2.1.2 单/多指令对比"></a>2.1.2 单/多指令对比</h4><ul>
<li>单指令对比多指令（对于多指令，如果执行事间过长对于单线程操作时不适用的，注意及时切割）</li>
</ul>
<h4 id="2-1-3-拓展操作"><a href="#2-1-3-拓展操作" class="headerlink" title="2.1.3 拓展操作"></a>2.1.3 拓展操作</h4><ul>
<li><p>String作为数值的操作</p>
<ul>
<li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。</li>
<li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。</li>
<li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li>
</ul>
<p><strong>tips：</strong></p>
<ul>
<li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong></li>
<li>此方案适用于所有数据库，且支持数据库集群</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 增长指令，只有当value为数字时才能增长</span><br><span class="line">incr key  </span><br><span class="line">incrby key increment  </span><br><span class="line">incrbyfloat key increment </span><br><span class="line"></span><br><span class="line"># 减少指令，有当value为数字时才能减少</span><br><span class="line">decr key  </span><br><span class="line">decrby key increment</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>指定生命周期<ul>
<li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置数据的生命周期，单位 秒</span><br><span class="line">setex key seconds value</span><br><span class="line"># 设置数据的生命周期，单位 毫秒</span><br><span class="line">psetex key milliseconds value</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-String类型数据操作的注意事项"><a href="#2-1-4-String类型数据操作的注意事项" class="headerlink" title="2.1.4 String类型数据操作的注意事项"></a>2.1.4 String类型数据操作的注意事项</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_3_20210325.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_3_20210325.png" alt="img"></a></p>
<ul>
<li><p>key的设置约定</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_4_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_4_20210326.png" alt="img"></a></p>
</li>
</ul>
<h3 id="2-2-Hash"><a href="#2-2-Hash" class="headerlink" title="2.2 Hash"></a>2.2 Hash</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_5_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_5_20210326.png" alt="img"></a></p>
<ul>
<li>新的存储需求：对一系列存储的数据进行编组，方便管理，典型应用存储对象信息</li>
<li>需要的存储结构：一个存储空间保存多个键值对数据</li>
<li>hash类型：底层使用哈希表结构实现数据存储</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_6_20210325.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_6_20210325.png" alt="img"></a></p>
<h4 id="2-2-1-基本操作"><a href="#2-2-1-基本操作" class="headerlink" title="2.2.1 基本操作"></a>2.2.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 插入（如果已存在同名的field，会被覆盖）</span><br><span class="line">hset key field value</span><br><span class="line">hmset key field1 value1 field2 value2...</span><br><span class="line"></span><br><span class="line"># 取出</span><br><span class="line">hget key field</span><br><span class="line">hgetall key</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">hdel key field1 field2...</span><br><span class="line"></span><br><span class="line"># 获取field数量</span><br><span class="line">hlen key</span><br><span class="line"></span><br><span class="line"># 查看是否存在</span><br><span class="line">hexists key field</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-拓展操作"><a href="#2-2-2-拓展操作" class="headerlink" title="2.2.2 拓展操作"></a>2.2.2 拓展操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 获取哈希表中所有的字段名或字段值 </span><br><span class="line">hkeys key</span><br><span class="line">hvals key</span><br><span class="line"></span><br><span class="line"># 设置指定字段的数值数据增加指定范围的值 </span><br><span class="line">hincrby key field increment </span><br><span class="line">hdecrby key field increment</span><br><span class="line"></span><br><span class="line"># 插入（如果已存在同名的field，不会被覆盖）</span><br><span class="line">hsetnx key field value</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-hash类型数据操作的注意事项"><a href="#2-2-3-hash类型数据操作的注意事项" class="headerlink" title="2.2.3 hash类型数据操作的注意事项"></a>2.2.3 hash类型数据操作的注意事项</h4><ul>
<li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li>
<li>每个 hash 可以存储 2^32 - 1 个键值</li>
<li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong></li>
<li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈</li>
</ul>
<h3 id="2-3-List"><a href="#2-3-List" class="headerlink" title="2.3 List"></a>2.3 List</h3><ul>
<li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型：保存多个数据，底层使用双向链表存储结构实现</li>
<li><strong>元素有序，且可重</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_8_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_8_20210326.png" alt="img"></a></p>
<h4 id="2-3-1-基本操作"><a href="#2-3-1-基本操作" class="headerlink" title="2.3.1 基本操作"></a>2.3.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 添加修改数据,lpush为从左边添加，rpush为从右边添加</span><br><span class="line">lpush key value1 value2 value3...</span><br><span class="line">rpush key value1 value2 value3...</span><br><span class="line"></span><br><span class="line"># 查看数据, 从左边开始向右查看. 如果不知道list有多少个元素，end的值可以为-1,代表倒数第一个元素</span><br><span class="line"># lpush先进的元素放在最后,rpush先进的元素放在最前面</span><br><span class="line">lrange key start end</span><br><span class="line"># 取出对应索引的元素</span><br><span class="line">lindex key index</span><br><span class="line"># 得到长度</span><br><span class="line">llen key</span><br><span class="line"></span><br><span class="line"># 获取并移除元素（从list左边或者右边移除）</span><br><span class="line">lpop key</span><br><span class="line">rpop key</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-拓展操作"><a href="#2-3-2-拓展操作" class="headerlink" title="2.3.2 拓展操作"></a>2.3.2 拓展操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 规定时间内获取并移除数据,b&#x3D;block,给定一个时间，如果在指定时间内放入了元素，就移除</span><br><span class="line">blpop key1 key2... timeout</span><br><span class="line">brpop key1 key2... timeout</span><br><span class="line"></span><br><span class="line"># 移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span><br><span class="line">lrem key count value</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3-list类型数据操作注意事项"><a href="#2-3-3-list类型数据操作注意事项" class="headerlink" title="2.3.3 list类型数据操作注意事项"></a>2.3.3 list类型数据操作注意事项</h4><ul>
<li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。</li>
<li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作</li>
<li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li>
<li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载</li>
</ul>
<h3 id="2-4-Set"><a href="#2-4-Set" class="headerlink" title="2.4 Set"></a>2.4 Set</h3><ul>
<li>新的存储需求：存储大量数据，在查询方面提供更高的效率</li>
<li>需要的存储结构：能够保存大量的数据，高效的内部存储机制，便于查询</li>
<li>set类型：与hash存储结构完全相同，仅存键，不存值（nil），并且值时不允许重复的</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_7_20210325.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_7_20210325.png" alt="img"></a></p>
<h4 id="2-4-1-基本操作"><a href="#2-4-1-基本操作" class="headerlink" title="2.4.1 基本操作"></a>2.4.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 添加元素</span><br><span class="line">sadd key member1 member2...</span><br><span class="line"></span><br><span class="line"># 查看元素</span><br><span class="line">smembers key</span><br><span class="line"></span><br><span class="line"># 移除元素</span><br><span class="line">srem key member</span><br><span class="line"></span><br><span class="line"># 查看元素个数</span><br><span class="line">scard key</span><br><span class="line"></span><br><span class="line"># 查看某个元素是否存在</span><br><span class="line">sismember key member</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-拓展操作"><a href="#2-4-2-拓展操作" class="headerlink" title="2.4.2 拓展操作"></a>2.4.2 拓展操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 从set中任意选出count个元素</span><br><span class="line">srandmember key count</span><br><span class="line"></span><br><span class="line"># 从set中任意选出count个元素并移除</span><br><span class="line">spop key count</span><br><span class="line"></span><br><span class="line"># 求两个集合的交集、并集、差集</span><br><span class="line">sinter key1 key2...</span><br><span class="line">sunion key1 key2...</span><br><span class="line">sdiff key1 key2...</span><br><span class="line"></span><br><span class="line"># 求两个set的交集、并集、差集，并放入另一个set中</span><br><span class="line">sinterstore destination key1 key2...</span><br><span class="line">sunionstore destination key1 key2...</span><br><span class="line">sdiffstore destination key1 key2...</span><br><span class="line"></span><br><span class="line"># 求指定元素从原集合放入目标集合中</span><br><span class="line">smove source destination key</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-4-3-Set类型数据操作的注意事项"><a href="#2-4-3-Set类型数据操作的注意事项" class="headerlink" title="2.4.3 Set类型数据操作的注意事项"></a>2.4.3 Set类型数据操作的注意事项</h4><ul>
<li>set类型不允许数据重复，如果添加的数据在set中已经存在，将只保留一份</li>
<li>set虽然与hash的存储结构相同，但是无法启动hash中存储值的空间</li>
</ul>
<h3 id="2-5-Sorted-set"><a href="#2-5-Sorted-set" class="headerlink" title="2.5 Sorted_set"></a>2.5 Sorted_set</h3><ul>
<li>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式</li>
<li>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据</li>
<li>sorted_set类型：在set的存储结构基础上添加可排序字段</li>
<li><strong>不重但有序（score）</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_9_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_9_20210326.png" alt="img"></a></p>
<h4 id="2-5-1-基本操作"><a href="#2-5-1-基本操作" class="headerlink" title="2.5.1 基本操作"></a>2.5.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 插入元素, 需要指定score(用于排序)</span><br><span class="line">zadd key score1 member1 score2 member2</span><br><span class="line"></span><br><span class="line"># 查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br><span class="line">zrange key start end [withscore]</span><br><span class="line"># 查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来</span><br><span class="line">zrevrange key start end [withscore]</span><br><span class="line"></span><br><span class="line"># 移除元素</span><br><span class="line">zrem key member1 member2...</span><br><span class="line"></span><br><span class="line"># 按条件获取数据, 其中offset为索引开始位置，count为获取的数目</span><br><span class="line">zrangebyscore key min max [withscore] [limit offset count]</span><br><span class="line">zrevrangebyscore key max min [withscore] [limit offset count]</span><br><span class="line"></span><br><span class="line"># 按条件移除元素</span><br><span class="line">zremrangebyrank key start end</span><br><span class="line">zremrangebyscore key min max</span><br><span class="line"># 按照从大到小的顺序移除count个值</span><br><span class="line">zpopmax key [count]</span><br><span class="line"># 按照从小到大的顺序移除count个值</span><br><span class="line">zpopmin key [count]</span><br><span class="line"></span><br><span class="line"># 获得元素个数</span><br><span class="line">zcard key</span><br><span class="line"></span><br><span class="line"># 获得元素在范围内的个数</span><br><span class="line">zcount min max</span><br><span class="line"></span><br><span class="line"># 求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目</span><br><span class="line">zinterstore destination numkeys key1 key2...</span><br><span class="line">zunionstore destination numkeys key1 key2...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>min与max用于限定搜索查询的<strong>条件</strong></li>
<li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引</li>
<li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong></li>
</ul>
<h4 id="2-5-2-拓展操作"><a href="#2-5-2-拓展操作" class="headerlink" title="2.5.2 拓展操作"></a>2.5.2 拓展操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看某个元素的索引(排名)</span><br><span class="line">zrank key member</span><br><span class="line">zrevrank key member</span><br><span class="line"></span><br><span class="line"># 查看某个元素索引的值</span><br><span class="line">zscore key member</span><br><span class="line"># 增加某个元素索引的值</span><br><span class="line">zincrby key increment member</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-sorted-set类型数据操作的注意事项"><a href="#2-5-3-sorted-set类型数据操作的注意事项" class="headerlink" title="2.5.3 sorted_set类型数据操作的注意事项"></a>2.5.3 sorted_set类型数据操作的注意事项</h4><ul>
<li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong></li>
<li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果</li>
</ul>
<h2 id="3-通用指令"><a href="#3-通用指令" class="headerlink" title="3. 通用指令"></a>3. 通用指令</h2><h3 id="3-1-key-特征"><a href="#3-1-key-特征" class="headerlink" title="3.1 key 特征"></a>3.1 key 特征</h3><ul>
<li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据</li>
</ul>
<h3 id="3-2-key通用操作"><a href="#3-2-key通用操作" class="headerlink" title="3.2 key通用操作"></a>3.2 key通用操作</h3><h4 id="3-2-1-基本操作"><a href="#3-2-1-基本操作" class="headerlink" title="3.2.1 基本操作"></a>3.2.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看key是否存在</span><br><span class="line">exists key</span><br><span class="line"></span><br><span class="line"># 删除key</span><br><span class="line">del key</span><br><span class="line"></span><br><span class="line"># 查看key的类型</span><br><span class="line">type key</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-拓展操作"><a href="#3-2-2-拓展操作" class="headerlink" title="3.2.2 拓展操作"></a>3.2.2 拓展操作</h4><ul>
<li>时效性操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置生命周期</span><br><span class="line">expire key seconds</span><br><span class="line">pexpire key milliseconds</span><br><span class="line"># Linux下使用时间戳设置有效事件</span><br><span class="line">expireat key timestamp</span><br><span class="line">pexpireat key milliseconds-timestamp</span><br><span class="line"></span><br><span class="line"># 查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span><br><span class="line">ttl key</span><br><span class="line">pttl key</span><br><span class="line"></span><br><span class="line"># 将有时限的数据设置为永久有效</span><br><span class="line">persist key</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>查询操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 根据key查询符合条件的数据</span><br><span class="line">keys pattern</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_10_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_10_20210326.png" alt="img"></a></p>
<ul>
<li>其他操作</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span><br><span class="line">rename key newKey</span><br><span class="line">renamenx key newKey</span><br><span class="line"></span><br><span class="line"># 查看所有关于key的操作, 可以使用Tab快速切换</span><br><span class="line">help @generic</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-3-数据库的通用指令"><a href="#3-3-数据库的通用指令" class="headerlink" title="3.3 数据库的通用指令"></a>3.3 数据库的通用指令</h3><p>key重复的问题</p>
<ul>
<li>key时程序员定义的</li>
<li>redis使用中数据量不断增加，key也会不断增多</li>
<li>数据部分种类，类别混在在一起容易重复或冲突</li>
</ul>
<p>解决：数据库</p>
<ul>
<li>Redis为每个服务提供有16个数据库，编号从0到15</li>
<li>每个数据库之间的数据相互独立</li>
</ul>
<h4 id="3-3-1-基本操作"><a href="#3-3-1-基本操作" class="headerlink" title="3.3.1 基本操作"></a>3.3.1 基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 切换数据库 0~15</span><br><span class="line">select index</span><br><span class="line"></span><br><span class="line"># 其他操作</span><br><span class="line">quit</span><br><span class="line">ping</span><br><span class="line">echo massage</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-拓展操作"><a href="#3-3-2-拓展操作" class="headerlink" title="3.3.2 拓展操作"></a>3.3.2 拓展操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 移动数据, 必须保证目的数据库中没有该数据</span><br><span class="line">mov key db</span><br><span class="line"></span><br><span class="line"># 查看该库中数据总量</span><br><span class="line">dbsize</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="4-Jedis"><a href="#4-Jedis" class="headerlink" title="4. Jedis"></a>4. Jedis</h2><ul>
<li>Java语言连接redis的服务<ul>
<li>Jedis</li>
<li>SpringData Redis</li>
<li>Lettuce</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_11_20210326.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/Redis_11_20210326.png" alt="img"></a></p>
<ul>
<li><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</li>
</ul>
<h3 id="4-1-Java操作redis的步骤"><a href="#4-1-Java操作redis的步骤" class="headerlink" title="4.1 Java操作redis的步骤"></a>4.1 Java操作redis的步骤</h3><ul>
<li>连接Redis</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 参数为Redis所在的ip地址和端口号</span><br><span class="line">Jedis jedis &#x3D; new Jedis(String host, int port)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>操作Redis</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 操作redis的指令和redis本身的指令几乎一致</span><br><span class="line">jedis.set(String key, String value);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>断开连接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.close();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>常规演示Test</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jedis.test;</span><br><span class="line"></span><br><span class="line">import cn.itcast.jedis.util.JedisPoolUtils;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * jedis的测试类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JedisTest &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 快速入门</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;localhost&quot;,6379);</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * string 数据结构操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        &#x2F;&#x2F;存储</span><br><span class="line">        jedis.set(&quot;username&quot;,&quot;zhangsan&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取</span><br><span class="line">        String username &#x3D; jedis.get(&quot;username&quot;);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        &#x2F;&#x2F;可以使用setex()方法存储可以指定过期时间的 key value</span><br><span class="line">        jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;);&#x2F;&#x2F;将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * hash 数据结构操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        &#x2F;&#x2F; 存储hash</span><br><span class="line">        jedis.hset(&quot;user&quot;,&quot;name&quot;,&quot;lisi&quot;);</span><br><span class="line">        jedis.hset(&quot;user&quot;,&quot;age&quot;,&quot;23&quot;);</span><br><span class="line">        jedis.hset(&quot;user&quot;,&quot;gender&quot;,&quot;female&quot;);</span><br><span class="line">        &#x2F;&#x2F; 获取hash</span><br><span class="line">        String name &#x3D; jedis.hget(&quot;user&quot;, &quot;name&quot;);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        &#x2F;&#x2F; 获取hash的所有map中的数据</span><br><span class="line">        Map&lt;String, String&gt; user &#x3D; jedis.hgetAll(&quot;user&quot;);</span><br><span class="line">        &#x2F;&#x2F; keyset</span><br><span class="line">        Set&lt;String&gt; keySet &#x3D; user.keySet();</span><br><span class="line">        for (String key : keySet) &#123;</span><br><span class="line">            &#x2F;&#x2F;获取value</span><br><span class="line">            String value &#x3D; user.get(key);</span><br><span class="line">            System.out.println(key + &quot;:&quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * list 数据结构操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        &#x2F;&#x2F; list 存储</span><br><span class="line">        jedis.lpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从左边存</span><br><span class="line">        jedis.rpush(&quot;mylist&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);&#x2F;&#x2F;从右边存</span><br><span class="line">        &#x2F;&#x2F; list 范围获取</span><br><span class="line">        List&lt;String&gt; mylist &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);</span><br><span class="line">        System.out.println(mylist);</span><br><span class="line">        &#x2F;&#x2F; list 弹出</span><br><span class="line">        String element1 &#x3D; jedis.lpop(&quot;mylist&quot;);&#x2F;&#x2F;c</span><br><span class="line">        System.out.println(element1);</span><br><span class="line">        </span><br><span class="line">        String element2 &#x3D; jedis.rpop(&quot;mylist&quot;);&#x2F;&#x2F;c</span><br><span class="line">        System.out.println(element2);</span><br><span class="line">        &#x2F;&#x2F; list 范围获取</span><br><span class="line">        List&lt;String&gt; mylist2 &#x3D; jedis.lrange(&quot;mylist&quot;, 0, -1);</span><br><span class="line">        System.out.println(mylist2);</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * set 数据结构操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        &#x2F;&#x2F; set 存储</span><br><span class="line">        jedis.sadd(&quot;myset&quot;,&quot;java&quot;,&quot;php&quot;,&quot;c++&quot;);</span><br><span class="line">        &#x2F;&#x2F; set 获取</span><br><span class="line">        Set&lt;String&gt; myset &#x3D; jedis.smembers(&quot;myset&quot;);</span><br><span class="line">        System.out.println(myset);</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * sortedset 数据结构操作</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        &#x2F;&#x2F;1. 获取连接</span><br><span class="line">        Jedis jedis &#x3D; new Jedis();&#x2F;&#x2F;如果使用空参构造，默认值 &quot;localhost&quot;,6379端口</span><br><span class="line">        &#x2F;&#x2F;2. 操作</span><br><span class="line">        &#x2F;&#x2F; sortedset 存储</span><br><span class="line">        jedis.zadd(&quot;mysortedset&quot;,3,&quot;亚瑟&quot;);</span><br><span class="line">        jedis.zadd(&quot;mysortedset&quot;,30,&quot;后裔&quot;);</span><br><span class="line">        jedis.zadd(&quot;mysortedset&quot;,55,&quot;孙悟空&quot;);</span><br><span class="line">        &#x2F;&#x2F; sortedset 获取</span><br><span class="line">        Set&lt;String&gt; mysortedset &#x3D; jedis.zrange(&quot;mysortedset&quot;, 0, -1);</span><br><span class="line">        System.out.println(mysortedset);</span><br><span class="line">        &#x2F;&#x2F;3. 关闭连接</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * jedis连接池使用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test7()&#123;</span><br><span class="line">        &#x2F;&#x2F;0.创建一个配置对象</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(50);</span><br><span class="line">        config.setMaxIdle(10);</span><br><span class="line">        &#x2F;&#x2F;1.创建Jedis连接池对象</span><br><span class="line">        JedisPool jedisPool &#x3D; new JedisPool(config,&quot;localhost&quot;,6379);</span><br><span class="line">        &#x2F;&#x2F;2.获取连接</span><br><span class="line">        Jedis jedis &#x3D; jedisPool.getResource();</span><br><span class="line">        &#x2F;&#x2F;3. 使用</span><br><span class="line">        jedis.set(&quot;hehe&quot;,&quot;heihei&quot;);</span><br><span class="line">        &#x2F;&#x2F;4. 关闭 归还到连接池中</span><br><span class="line">        jedis.close();;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * jedis连接池工具类使用</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test8()&#123;</span><br><span class="line">        &#x2F;&#x2F;通过连接池工具类获取</span><br><span class="line">        Jedis jedis &#x3D; JedisPoolUtils.getJedis();</span><br><span class="line">        &#x2F;&#x2F;3. 使用</span><br><span class="line">        jedis.set(&quot;hello&quot;,&quot;world&quot;);</span><br><span class="line">        &#x2F;&#x2F;4. 关闭 归还到连接池中</span><br><span class="line">        jedis.close();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Jedis工具类抽取"><a href="#4-2-Jedis工具类抽取" class="headerlink" title="4.2 Jedis工具类抽取"></a>4.2 Jedis工具类抽取</h3><ul>
<li>redis.properties(配置文件)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">host&#x3D;127.0.0.1</span><br><span class="line">port&#x3D;6379</span><br><span class="line">maxTotal&#x3D;50</span><br><span class="line">maxIdle&#x3D;10</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>JedisPoolUtils工具类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jedis.util;</span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import redis.clients.jedis.JedisPool;</span><br><span class="line">import redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">&#x2F;**</span><br><span class="line"> JedisPool工具类</span><br><span class="line">    加载配置文件，配置连接池的参数</span><br><span class="line">    提供获取连接的方法</span><br><span class="line"></span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JedisPoolUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        &#x2F;&#x2F;读取配置文件</span><br><span class="line">        InputStream is &#x3D; JedisPoolUtils.class.getClassLoader().getResourceAsStream(&quot;jedis.properties&quot;);</span><br><span class="line">        &#x2F;&#x2F;创建Properties对象</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        &#x2F;&#x2F;关联文件</span><br><span class="line">        try &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;获取数据，设置到JedisPoolConfig中</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        </span><br><span class="line">		config.setMaxTotal(Integer.parseInt(pro.getProperty(&quot;maxTotal&quot;)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(&quot;maxIdle&quot;)));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;初始化JedisPool</span><br><span class="line">        jedisPool &#x3D; new JedisPool(config,pro.getProperty(&quot;host&quot;),Integer.parseInt(pro.getProperty(&quot;port&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Jedis getJedis()&#123;</span><br><span class="line">        return jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/redis%E5%9F%BA%E7%A1%80/" data-id="cknmwaip50002j4uba7xz2tlh" data-title="redis基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:33:18.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">计算机网络总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><p>本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:2">2]</a>以及少量的补充</p>
<h2 id="1-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1. OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1. OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png" alt="img"></a></p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><blockquote>
<p><strong>应用层</strong>：直接为用户的应用进程提供网络服务。</p>
</blockquote>
<p><strong>应用层协议</strong>： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候像应用层协议就可以规定这些数据的格式要满足什么形式。</p>
<p>在互联网中应用层协议很多，如</p>
<ul>
<li>域名系统<strong>DNS</strong></li>
</ul>
<blockquote>
<p>域名系统DNS：</p>
<p>是因特网的一项核心服务，他作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，不用去记住能够背极其直接读取的IP数串。</p>
</blockquote>
<ul>
<li>支持万维网应用的 <strong>HTTP</strong>协议</li>
</ul>
<blockquote>
<p>HTTP协议:</p>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<ul>
<li>支持电子邮件的 <strong>SMTP</strong>协议</li>
<li>文件传输 <strong>FTP</strong>等等</li>
</ul>
<p>我们把应用层交互的数据单元称为报文。</p>
<h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><blockquote>
<p><strong>表示层</strong>：在满足用户需求的基础上，尽可能的节省传输费用而设置的，表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p>
</blockquote>
<p>表示层的<strong>数据转换</strong>包括:</p>
<ul>
<li>数据加密</li>
<li>数据压缩</li>
<li>数据格式转换等。</li>
</ul>
<p>比如传输压缩文件，jpeg或者加密文件等格式。</p>
<h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><blockquote>
<p>会话层：<strong>管理</strong>主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话。</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><blockquote>
<p><strong>运输层</strong>：为应用进程之间提供端到端的逻辑通讯。</p>
</blockquote>
<h4 id="1-2-1-运输层协议⭐"><a href="#1-2-1-运输层协议⭐" class="headerlink" title="1.2.1 运输层协议⭐"></a>1.2.1 运输层协议⭐</h4><p><strong>运输层协议</strong>: IP协议是<strong>主机之间</strong>的通信，TCP和UDP是进程之间的通信。</p>
<ul>
<li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）</p>
<p>提供面向连接的，可靠的数据传输服务</p>
<ul>
<li>客户端和服务器之间要保持一个会话直到传输结束</li>
<li>分段传输建立会话可靠传输流量控制（发送窗口大小根据接收窗口大小确定）</li>
<li>流量控制、拥塞控制，全双工</li>
<li>每一条TCP连接有两个端点（套接字：IP+端口号）</li>
</ul>
</li>
<li><p>用户数据协议 <strong>UDP</strong>（User Datagram Protocol）</p>
<p>提供无连接的，尽最大努力的数据传输服务</p>
<ul>
<li>不保证数据传输的可靠性</li>
<li>不分段</li>
<li>支持一对一，一对多，多对一通信</li>
</ul>
</li>
<li><p>TCP和UDP对比[见问题三](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/3.TCP/UDP">http://lihengxu.cn/2021/03/23/计网/3.TCP/UDP</a> 协议的区别⭐)</p>
</li>
</ul>
<h4 id="1-2-2-本层加端口号"><a href="#1-2-2-本层加端口号" class="headerlink" title="1.2.2 本层加端口号"></a>1.2.2 本层加端口号</h4><p>常见端口：</p>
<ul>
<li>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制；</li>
<li>Telnet（远程登录协议）：23；</li>
<li>DNS（域名解析服务）：53；</li>
<li>TFTP（简单文件传输协议）：69；</li>
<li>HTTP（超文本传输协议）：80</li>
</ul>
<h4 id="1-2-3-传输层进行差错检测"><a href="#1-2-3-传输层进行差错检测" class="headerlink" title="1.2.3 传输层进行差错检测"></a>1.2.3 传输层进行差错检测</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png" alt="img"></a></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><blockquote>
<p><strong>网络层</strong>（网际层/IP层）：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。(<strong>路径选择、路由及逻辑寻址</strong>)</p>
</blockquote>
<ul>
<li><p><strong>协议</strong>：ARP IP ICMP IGMP(ARP为IP提供服务，IP为ICMP和IGMP提供服务）</p>
<ul>
<li>由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 IP 数据报 ，简称<strong>数据报</strong></li>
<li>无论是哪一层的数据单元都可以笼统的用”分组“表示，主要不要混淆”用户数据包UDP“和网络层的”IP数据报“</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png" alt="img"></a></p>
</li>
<li><p><strong>特点</strong>：网络层不管发的顺序也不管丢数据不（对方传输层负责），根据目标地址选择合适路径转发。</p>
</li>
<li><p><strong>本层加源IP地址与目标IP地址，构成IP数据报。</strong> <strong>IP协议非常简单，仅仅提供不可靠、无连接的传送服务</strong>。 IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p>
</li>
<li><p><strong>路由器工作在网络层</strong>，在不同网段转发数据。</p>
</li>
</ul>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><blockquote>
<p>数据链路层：数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
</blockquote>
<ul>
<li>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <strong>IP 数据报组装成帧</strong>，进行传送。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。</li>
<li>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。</li>
<li>封装成帧（帧头、帧尾、物理地址、校验值） 透明传输（字节填充法，传输数据出现控制字符前面插入一个转义字符） 差错校验（循环冗余检验CRC）</li>
</ul>
<blockquote>
<p><strong>数据链路层协议</strong>(了解)：</p>
</blockquote>
<ul>
<li>PPP（点到点信道） （拨号电话线接入因特网就是PPP）</li>
<li>CSMA/CD(带冲突检测的载波监听多路访问协议）（使用广播信道）（局域网）</li>
<li>多路访问：多个设备可以同时访问介质（多个设备在同一信道发送信号协议），一个设备发送的帧也可以被多个设备接收。</li>
<li>载波监听：每一个设备发送数据前，对信道侦听，空闲才可以发送，如果有其他设备正在发暂时不发避免碰撞。</li>
<li>碰撞检测：设备边发数据边检测信道上电压大小，一旦出现碰撞，立即停止发送，等待一段时间后再发。 这个协议只能<strong>半双工</strong>通信。</li>
</ul>
<blockquote>
<p><strong>以太网</strong>（ 全球使用最广泛的局域网技术）拓扑结构为总线型</p>
</blockquote>
<p>以太网的标准<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91">拓扑</a>结构为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91">总线型拓扑</a>，但目前的快速以太网为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CSMA%2FCD">CSMA/CD</a>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png" alt="img"></a></p>
<blockquote>
<p>网桥交换机：网桥设备（可以连接集线器）</p>
</blockquote>
<p>网桥既有过滤帧的功能。当网桥收到一个帧的时候，并不是像所有接口发此帧，而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口。</p>
<ul>
<li>网桥口越来越多了就变成了交换机（直接连计算机）</li>
<li>交换机前身为网桥</li>
<li>交换机口可以存储转发，基于MAC地址转发，通过学习构建MAC地址表</li>
</ul>
<p><strong>本层加MAC地址</strong></p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><blockquote>
<p>物理层：实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p>
</blockquote>
<ul>
<li>在物理层上传送比特流</li>
<li>频分复用，时分复用</li>
</ul>
<blockquote>
<p>集线器：多接口转发器，工作在物理层</p>
</blockquote>
<h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>发送端：</p>
<ul>
<li><p>应用程序准备传输的文件</p>
</li>
<li><p>传输层 将文件分段 并编号</p>
</li>
<li><p>网络层 添加目标IP地址源IP地址</p>
</li>
<li><p>数据链路层 两种情况</p>
<p>使用自己的子网掩码 判断自己在那个网段</p>
<p>使用自己的子网掩码 判断目标地址在哪个网段</p>
<ul>
<li>如果是同一个网段 arp协议广播解析目标IP地址的MAC</li>
<li>如果不是同一个网段 则mac写网关地址</li>
</ul>
</li>
</ul>
<hr>
<p>一些帮助理解的解释：</p>
<ul>
<li><p>ARP发送的广播包，目标MAC是全1（48位），交换机会给所有出口转发。得到MAC地址后会缓存，过一段时间不和目标地址通信了，这个缓存会删除掉。</p>
</li>
<li><p>交换机根据mac地址转发数据</p>
</li>
<li><p>每个计算机配有网关（知道自己所在子网的路由网口地址）</p>
</li>
<li><p>点到点信道，物理层地址固定为FF（因为只能这个传给对方，不用看地址）</p>
</li>
<li><p>IP地址决定了数据的起点与终点，MAC地址决定了本点和下一跳给谁</p>
</li>
<li><p>集线器：</p>
<p>只负责把比特流传出去，并对信号进行加强，属于物理层设备（与网线差不多，只认比特流）</p>
</li>
<li><p>交换机（一个网段内转给其他计算机还是路由器）：</p>
<p>收完比特流，存储，看目标mac地址，选择出口，工作在第二层数据链路层设备，存储转发（只能看懂mac地址看不懂IP地址）</p>
</li>
<li><p>路由器：</p>
<p>有网卡（接口）接收比特流，可以看懂mac，判断是不是给自己，然后会把mac地址去掉，剩下IP数据报，根据数据报的目标地址按照路由表选择出口（路由器看不懂具体传的数据），出口写上新的MAC地址，为三层设备网络设备</p>
<p>路由器–网关–交换机三层结构：</p>
<p>知道IP地址，想知道具体是哪个物理PC机</p>
<ul>
<li>首先要通过IP地址的网段查找到是哪个网关的</li>
<li>然后在网关ARP表中查找mac地址和交换机位置</li>
<li>然后通过MAC表查找到物理PC机。</li>
<li>即IP地址-网关-MAC地址-交换机-port-PC机</li>
</ul>
<blockquote>
<p><strong>mac表</strong>：记录交换机接口（端口）和终端MAC的对应关系，即说明交换机哪个端口和终端的哪个MAC地址对应，指的是物理层面的连接关系，存在于交换机当中。</p>
<p><strong>ARP缓存表</strong>：记录主机的IP地址和MAC地址的对应关系，对于同一台PC机，IP地址是可变的，但是MAC地址是物理网卡的地址，是网卡特有的信息，是不可变的。这个缓存表一般不存在交换机里面，而是在交换机上一层的仪器中，即网关中。这个表里面只能知道IP地址和MAC的对应关系，以及在哪个交换机上连接着，并不能知道在交换机的哪个端口，需要和mac表相结合才能知道。</p>
<p><strong>路由表</strong>：记录路由器掌握的所有目的地网段，以及到达这些目的的最佳路径</p>
</blockquote>
</li>
<li><p>工作在哪一层指的最高能看懂那一层的内容</p>
</li>
<li><p>对方物理层收到比特流后，数据链路层看目标mac地址是给自己的，然后到网络层去掉mac地址剩下IP数据报，然后数据报把IP地址去掉（IP地址）给传输层，传输层排序检查丢包后给应用层</p>
</li>
</ul>
<hr>
<p>病毒是一个代码，也会分段传，路由器只能看到每一段所以中不了病毒，交换机以及集线器也不会</p>
<h3 id="1-7-TCP-IP协议有了解吗？"><a href="#1-7-TCP-IP协议有了解吗？" class="headerlink" title="1.7 TCP/IP协议有了解吗？"></a>1.7 TCP/IP协议有了解吗？</h3><p>TCP/IP 协议不是TCP 和IP 这两个协议的合称，而是指因特网整个TCP/IP 协议族，是一系列网络协议的总称。</p>
<p>TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为</p>
<ul>
<li><strong>应用层</strong></li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong></li>
<li><strong>链路层</strong></li>
</ul>
<h2 id="2-TCP-三次握手和四次挥手⭐"><a href="#2-TCP-三次握手和四次挥手⭐" class="headerlink" title="2. TCP 三次握手和四次挥手⭐"></a>2. TCP 三次握手和四次挥手⭐</h2><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p>
<h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><ul>
<li>第一次握手：主机A 发送syn＝1,随机产生seq=x(如1234567) 的数据包到服务器，主机B由SYN=1 知道，A 要求建立联机；</li>
<li>第二次握手： 主机B 收到请求后要确认联机信息， 向A 发送ack=( 主机A 的seq+1),syn=1,ack=1,随机产生seq=y(如7654321） 的包</li>
<li>第三次握手：主机A 收到后检查ack是否正确，即第一次发送的seq +1,以及位码ACK是否为1，若正确，主机A 会再发送ack =(主机B 的seq+1),ACK=1，主机B 收到后确认</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png" alt="img"></a></p>
<p><strong>序列号</strong>：TCP缓存中字节流分数据段发，序号是这个数据段的第一个字节是整个文件的第几个字节（ 如果传输的数据字节为0，即只有首部，那序列号还增加吗？当syn 或 fin被置1，虽然报文里长度为0（应用层的数据叫报文），计算ack时我们可以认为其长度为1。其他情况（如只有ack）不增加）</p>
<p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的<strong>握手信号</strong>。</p>
<p><strong>确认号ack</strong>：根据收到的数据包的最后一个字节，给信号说下一个该发哪个字节了，这个确认号就是下一个该发得字节号</p>
<p><strong>ACK</strong>：0确认号无效，1确认号有效</p>
<blockquote>
<p>状态变化:</p>
<ul>
<li>客户端: Close-&gt;SYN_SENT-&gt;ESTABLISHED</li>
<li>服务端: Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED</li>
</ul>
</blockquote>
<h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收是正常的。 <strong>核心思想</strong>：<strong>让双方都证实对方能发收</strong>。</p>
<ul>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-两次握手可以么？"><a href="#2-3-两次握手可以么？" class="headerlink" title="2.3 两次握手可以么？"></a>2.3 两次握手可以么？</h3><p>不可以</p>
<blockquote>
<p>假如只有前面两次握手，那么服务器在接收到第一次握手信号，发出第二次握手信号后就会开始工作。</p>
</blockquote>
<ol>
<li>服务器角度：可能客户端发送的第一次握手请求传输过程中阻塞，客户端会再次发送一个请求，这个时候服务器先后接收到两次请求，并持续等两个客户端请求发送数据，其实只有一个，服务端却有两个响应，极端情况可能N个，会造成资源浪费。</li>
<li>客户端角度：假如发送建立连接的请求阻塞，过了一段时间发现没回复，然后再发一个（这次很快到达），然后给确认也很快， 就开始发数据。过了一会第一个阻塞的建立连接的请求也到了，再给一个确认给A，结果A不认了，刚已经收到确认了，就不理了，然后B就得等着传数据（没收到数据过一段就释放了），会造成资源浪费，所以需要第三个数据包的确认</li>
</ol>
<h3 id="2-4-第2次握手传回了ACK，为什么还要传回SYN？"><a href="#2-4-第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="2.4 第2次握手传回了ACK，为什么还要传回SYN？"></a>2.4 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。</p>
<p>而回传SYN则是为了建立并确认从服务端到客户端的通信，还要客户端确认我的发送是否正常（SYN=1了ack才为seq+1）。</p>
<h3 id="2-5-四次挥手"><a href="#2-5-四次挥手" class="headerlink" title="2.5 四次挥手"></a>2.5 四次挥手</h3><ul>
<li>第一次：主机A 请求断开连接 发送FIN=1 seq=u后，进入终止等待状态1，</li>
<li>第二次： 服务端对客户端的请求应答：ACK=1,ack=u+1,seq=v，然后服务器B 就进入关闭等待状态，此时TCP 服务器进程就通知高层应用进程，因而从A 到B 的连接就释放了。此时是“半关闭”状态。即A 不可以发送给B，但是B 可以发送给A。</li>
<li>第三次：此时，若B 没有数据报要发送给A 了，其应用进程就通知TCP 释放连接， 服务端请求断开连接：FIN=1，ACK=1,seq=w,ack=u+1，并等待确认。</li>
<li>第四次： 客户端对服务端的请求应答： ACK=1，seq=u+1，ack=w+1，A 进入时间等待，注意，此时TCP 连接还没有释放掉，然后经过时间等待计时器设置的2MSL 后，A 才进入到关闭状态。</li>
</ul>
<p>（FIN：finish）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png" alt="img"></a></p>
<blockquote>
<p>状态变化：</p>
<p>客户端：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p>
<p>服务端：ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p>
</blockquote>
<h3 id="2-7-为什么要四次挥手？"><a href="#2-7-为什么要四次挥手？" class="headerlink" title="2.7 为什么要四次挥手？"></a>2.7 为什么要四次挥手？</h3><p>我们可以看出服务端响应断开连接的请求时，其<strong>ACK和FIN包并不是一起发送给客户端的</strong>，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h3 id="2-8-四次挥手主动方为什么需要等待2MSL"><a href="#2-8-四次挥手主动方为什么需要等待2MSL" class="headerlink" title="2.8 四次挥手主动方为什么需要等待2MSL?"></a>2.8 四次挥手主动方为什么需要等待2MSL?</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p>
<blockquote>
<p>MSL（Maximum Segment Lifetime）：</p>
<p>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。（ 去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)=2MSL）</p>
</blockquote>
<p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了， 主动关闭方需要等待2MSL是为了，<strong>防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号</strong>。（若重发的又没到，客户端就关闭了，server最后就会异常关闭连接，把链接错误问题报告给高层）</p>
<h3 id="2-9-已经建立连接，但客户端故障怎么办？"><a href="#2-9-已经建立连接，但客户端故障怎么办？" class="headerlink" title="2.9 已经建立连接，但客户端故障怎么办？"></a>2.9 已经建立连接，但客户端故障怎么办？</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p>
<p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是<strong>设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75</strong>秒发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="3-TCP-UDP-协议的区别⭐"><a href="#3-TCP-UDP-协议的区别⭐" class="headerlink" title="3.TCP/UDP 协议的区别⭐"></a>3.TCP/UDP 协议的区别⭐</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png" alt="img"></a></p>
<ul>
<li>TCP协议进行数据通信之前需要<strong>三次握手建立连接</strong>，UDP协议不需要建立连接即可发送数据。</li>
<li>TCP有<strong>确认</strong>机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。<strong>传输可靠性</strong>区别</li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li>
</ul>
<blockquote>
<p>UDP（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播、屏幕广播、DNS、多播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
</blockquote>
<h3 id="3-1-一个网络数据包包括哪些有了解吗？"><a href="#3-1-一个网络数据包包括哪些有了解吗？" class="headerlink" title="3.1 一个网络数据包包括哪些有了解吗？"></a>3.1 一个网络数据包包括哪些有了解吗？</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部（链路层）；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png" alt="img"></a></p>
<h3 id="3-2-每一层的数据叫什么名字？"><a href="#3-2-每一层的数据叫什么名字？" class="headerlink" title="3.2 每一层的数据叫什么名字？"></a>3.2 每一层的数据叫什么名字？</h3><p>我们把应用层交互的数据单元称为报文</p>
<p>传输层：TCP叫报文段，UDP叫用户数据报</p>
<p>网络层：把运输层的报文段或者用户数据报封装成分组或者包，也叫IP数据报（数据报）</p>
<p>链路层：帧</p>
<p>物理层：比特流</p>
<h3 id="3-3-TCP协议中的数据包分片与重组功能有了解吗？"><a href="#3-3-TCP协议中的数据包分片与重组功能有了解吗？" class="headerlink" title="3.3 TCP协议中的数据包分片与重组功能有了解吗？"></a>3.3 TCP协议中的数据包分片与重组功能有了解吗？</h3><p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。</p>
<ul>
<li><p>发送方：</p>
<p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p>
</li>
<li><p>接收方：</p>
<p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p>
</li>
</ul>
<blockquote>
<p>链路层MTU(Maximum Transmission Unit)：每一种物理网络都会规定链路层数据帧的最大长度。IP协议在传输数据包时，若IP数据报加上数据帧头部后长度大于MTU，则将数据报文分为若干分片进行传输，并在目标系统中进行重组。</p>
</blockquote>
<blockquote>
<p>MSS：是TCP数据包每次能够传输的最大报文分段。</p>
</blockquote>
<h3 id="3-4-TCP粘包"><a href="#3-4-TCP粘包" class="headerlink" title="3.4 TCP粘包"></a>3.4 TCP粘包</h3><p>TCP粘包是指一种发送方发送的数据包在接收方的缓冲区中粘成了一包，也就是出现了数据包首尾相接的现象。</p>
<ul>
<li>产生原因：主要是发送方使用了Nagle算法，或者接收方的处理速度小于数据包的接收速度，导致接收缓冲区中消息堆积。</li>
<li>解决方法：可以通过关闭Nagle算法或者规定每个数据包的具体格式和长度，在接收方的应用层来进行判断</li>
</ul>
<p>还有UDP是不会产生粘包现象的，因为数据包之间具有明确的消息保护边界。</p>
<h2 id="4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）"><a href="#4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）" class="headerlink" title="4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）"></a>4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）</h2><ul>
<li><p><strong>确认</strong>：</p>
<p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储哪些已发送但是未收到确认的报文段，以便重传。</p>
<p>TCP默认使用<strong>累计确认</strong>，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序</strong>到达的最后一个分组发送确认（中间没到的可能丢了也可能阻塞还没到），这就表示到这个分组为止的所有分组都已经正确收到了。（但是不会立即发送这个确认号的数据包，因为其有可能只是阻塞了还能到，会等到这个报文段设置的重传时间到了还没收到确认就重传）</p>
</li>
<li><p><strong>重传：</strong>两种事件会导致TCP对报文段的重传：超时和冗余ACK。</p>
<ul>
<li>超时：TCP每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还未收到确认，就重传。</li>
<li>冗余ACK：超时触发重传的周期往往太长。TCP规定每当比期望序号更大的失序报文段到达时，就发送一个冗余ACK（再次确认某个报文段的ACK，之前已经收到过），TCP规定当发送方接收到对同一报文段的3个冗余ACK时，可以认为这个报文段已经丢失，立即执行重传，也称<strong>快速重传</strong>。</li>
</ul>
</li>
<li><p><strong>序列号</strong>：TCP 给 每个字节的数据都进行了编号，即序列号。</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答， 也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发（对丢包的会重传）。接收方根据编号会丢弃重复编号的数据（如超时重传中若是因为应答信号丢失，则会再传重复的数据），把有序数据传送给应用层。</p>
</li>
<li><p><strong>校验和</strong>： 目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
</ul>
<blockquote>
<p>校验和的计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p>
<p>发送方：在发送数据之前计算检验和，并进行校验和的填充。</p>
<p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png" alt="img"></a></p>
<blockquote>
<p>如果接收方比对校验和与发送方不一致，数据一定传输有误。</p>
<p>如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
</blockquote>
<p>此外，TCP协议还通过</p>
<ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>ARQ协议</li>
</ul>
<p>保证传输的可靠性。</p>
<h3 id="4-1-TCP-流量控制"><a href="#4-1-TCP-流量控制" class="headerlink" title="4.1 TCP 流量控制"></a>4.1 TCP 流量控制</h3><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>TCP 利用滑动窗口实现流量控制，在三次握手阶段，双方互相将自己的<strong>数据接收缓冲池大小</strong>告诉对方。 <strong>接收方有即时窗口</strong>（滑动窗口）， 窗口大小的内容 实际上是接收端接收数据缓冲区的剩余大小，而且接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。 发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度， 如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p>那么<strong>发送方</strong>就可以维护一个称为<strong>接收窗口</strong>的变量实现流量控制。</p>
<h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p>发送方维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<blockquote>
<p>发送窗口的上限为接收窗口和拥塞窗口中较小的一个。</p>
</blockquote>
<p><strong>拥塞控制与流量控制的区别：</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1（最大一个报文段的长度），每经过一个传播轮次（即往返时间），cwnd加倍，指数型增长，一直到规定的慢开始门限，然后改用拥塞避免算法。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1，按照线性增长。（即加法增大）。当出现一次超时（网络拥塞时）。令慢开始门限为当前cwnd的一半，cwnd重置为1，执行慢开始算法（即乘法减小）</li>
<li><strong>快重传与快恢复FRR：</strong><ul>
<li>快重传：使用冗余ACK来检测丢包的发生。冗余ACK也用于网络拥塞的检测（丢包当然意味着网络可能出现了拥塞）。</li>
<li>快恢复：收到三个冗余ACK，执行乘法减小，把慢开始门限减为当前cwnd的一半，但是cwnd不置为1，置为新的慢开始门限值（即减半），然后执行加法增大。由于跳过了cwnd从1开始的慢开始过程所以称为快恢复。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong>：当发送方检测到超时的时候，采用慢开始+拥塞避免，当发送方接收到冗余ACK时，采用快重传+快恢复</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png" alt="img"></a></p>
<h3 id="4-3-ARQ协议"><a href="#4-3-ARQ协议" class="headerlink" title="4.3 ARQ协议"></a>4.3 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之一。使用了<strong>确认和超时</strong>的两个机制。</p>
<p>ARQ包括：</p>
<ul>
<li>停止等待ARQ协议</li>
<li>连续ARQ协议。</li>
</ul>
<blockquote>
<p>停止等待ARQ协议</p>
</blockquote>
<ul>
<li><p>停止等待协议：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
</li>
<li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点： 简单</li>
<li>缺点： 信道利用率低，等待时间长</li>
</ul>
</li>
<li><p>几种具体情况：</p>
<ul>
<li><p>无差错情况:</p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
</li>
<li><p>出现差错情况（超时重传）:</p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<ul>
<li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>连续 ARQ 协议</p>
</blockquote>
<p>可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认（过一段时间确认一次，发送方其实是按照顺序发送的，可能由于网络原因，包到达的顺序不一致），而发送方每接收到一个确认，窗口就向前滑动一定距离。</p>
<ul>
<li>优缺点：<ul>
<li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</li>
</ul>
<h2 id="5-在浏览器中输入url地址-—-gt-显示主页的过程"><a href="#5-在浏览器中输入url地址-—-gt-显示主页的过程" class="headerlink" title="5. 在浏览器中输入url地址 —&gt; 显示主页的过程"></a>5. 在浏览器中输入url地址 —&gt; 显示主页的过程</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png" alt="img"></a></p>
<blockquote>
<p>上图有一个错误，请注意，是OSPF不是OPSF。</p>
<p>OSPF（Open Shortest Path Fitst）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li><p><strong>DNS解析</strong></p>
<blockquote>
<p>域名解释：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>.</p>
</blockquote>
<ul>
<li>以最右边英文.开始，称为域名的根：注意最后一个com的后面有点这个就是根，实际用的时候最后加不加点都行</li>
<li>.下面这个名称就为顶级域名，代表服务器/网站的性质：<ul>
<li>com（商业性质）</li>
<li>edu（教育性质）</li>
<li>net（提供信息）</li>
<li>cn（中国）</li>
<li>org（组织）</li>
<li>gov（政府部门）</li>
</ul>
</li>
<li>二级域名：自己申请，比如baidu 完全限定域名：FQDN，比如<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>（后面的<a target="_blank" rel="noopener" href="http://baidu.com/">baidu.com</a>已经全球唯一）</li>
<li>三级域名：<a target="_blank" rel="noopener" href="http://kkk.baidu.com/">kkk.baidu.com</a>的kkk就是第三级，也可以四级五级。一般网站习惯用www，也有<a target="_blank" rel="noopener" href="http://mail.baidu.com/">mail.baidu.com</a>,也可以<a target="_blank" rel="noopener" href="http://wwww.baidu.com/">wwww.baidu.com</a>代表一个域名下的不同服务器，只要对应的IP配正确就可以 谷歌公司的DNS服务器0.0.0.0 电信公司的DNS服务器222.222.222.222）</li>
</ul>
<blockquote>
<p>客户端浏览器通过DNS解析到域名的IP地址。</p>
</blockquote>
<p>域名解析的过程：</p>
<ul>
<li><p>迭代查询：</p>
<p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器向根域名服务器发送请求, 根DNS服务器，不负责具体的域名解析，但是他知道负责解析顶级域名的服务器IP（知道哪个DNS服务器负责哪一块的域名解析），会返回这个IP。本地域名服务器收到这个IP后，联系负责解析该顶级域名的服务器，这个顶级域名的服务器如果自己无法解析就找管理这个二级域名解析的服务器IP地址给本地域名服务器，然后本地域名服务器就去联系这个服务器直到解析成功为止，并把这个IP缓存到本地，供下次查询使用。</p>
</li>
<li><p>转发查询：（递归）</p>
<p>DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。</p>
<p>若有多个合适的服务器，DNS服务器可以返回一个跟用户最接近的点的IP地址给用户。（DNS负载均衡）</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong></p>
<p>在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，对于客户端与服务器的TCP链接，必然要说的就是三次握手。</p>
</li>
<li><p><strong>浏览器向WEB服务器发起Http请求</strong></p>
<p>建立TCP连接之后，发起HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP80端口）</p>
<ul>
<li><strong>传输层</strong> 把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。</li>
<li><strong>网络层：</strong>添加源IP和目标IP。</li>
<li><strong>链路层：</strong>客户端的链路层，发送ARP请求查找下一跳MAC，跨网段是网关的MAC</li>
<li>HTTP请求报文由三部分组成：<ul>
<li>请求行（ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD）</li>
<li>请求头（ HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息）</li>
<li>请求正文（ 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器端处理请求并返回HTTP报文</strong></p>
<ul>
<li>服务器端收到请求后的由web服务器（如 Tomcat）处理请求。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</li>
<li>HTTP响应报文也是由三部分组成:<ul>
<li>状态码（[如下述问题](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/7">http://lihengxu.cn/2021/03/23/计网/7</a>. 常见HTTP状态码)）</li>
<li>响应报头</li>
<li>响应报文（ 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>浏览器解析渲染页面</strong></p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
</li>
<li><p><strong>关闭TCP链接</strong></p>
<p>四次挥手</p>
</li>
</ol>
<h2 id="6-Get和Post区别"><a href="#6-Get和Post区别" class="headerlink" title="6. Get和Post区别"></a>6. Get和Post区别</h2><ul>
<li>Get一般是从服务器上请求数据，Post一般是向服务器传送数据。</li>
<li>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。 POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制。</li>
<li>GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求。</li>
<li>GET 请求可被浏览器主动缓存， POST 请求不会除非手动设置 GET 请求保留在浏览器历史记录中， 可被收藏为书签； POST 请求不会保留在浏览器历史记录中， POST 不能被收藏为书签</li>
<li>GET 只接受ASCII字符， POST支持多种编码方式</li>
<li>GET产生一个TCP数据包， 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包， 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（ 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）。</li>
</ul>
<blockquote>
<p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议， HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</p>
</blockquote>
<h2 id="7-常见HTTP状态码"><a href="#7-常见HTTP状态码" class="headerlink" title="7. 常见HTTP状态码"></a>7. 常见HTTP状态码</h2><p>1xx：表示通知信息，例如表示收到或者是正在处理（临时响应）</p>
<p>2xx：表示成功，例如表示接受或知道了</p>
<p>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动</p>
<p>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成</p>
<p>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p>
<h2 id="8-HTTP协议和各种协议的关系"><a href="#8-HTTP协议和各种协议的关系" class="headerlink" title="8. HTTP协议和各种协议的关系"></a>8. HTTP协议和各种协议的关系</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png" alt="img"></a></p>
<h2 id="9-HTTP长连接-短连接"><a href="#9-HTTP长连接-短连接" class="headerlink" title="9. HTTP长连接,短连接"></a>9. HTTP长连接,短连接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:3">3]</a></p>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<blockquote>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</blockquote>
<p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>
<ul>
<li><p>使用场景：</p>
<ul>
<li><strong>短链接</strong>：像WEB网站的http服务一般都用短链接</li>
</ul>
<p>原因：长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<ul>
<li><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
</li>
</ul>
<h2 id="10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）"><a href="#10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）" class="headerlink" title="10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）"></a>10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）</h2><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>我们可以使用cookie和session来保持会话状态，</p>
<ul>
<li>会话：一次会话中包含多次请求和响应</li>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</li>
</ul>
<blockquote>
<p>cookie和session功能就是在一次会话的范围内的多次请求间，共享数据。</p>
</blockquote>
<ul>
<li>客户端会话技术：Cookie，将数据保存到客户端浏览器（cookie一般用于存出少量的不太敏感的数据或是在不登录的情况下，完成服务器对客户端的身份识别）；</li>
<li>服务器端会话技术：Session，将数据保存在服务器端的对象中，Session的实现是依赖于Cookie的。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。</li>
</ul>
<p>实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p>
<blockquote>
<p>Cookie 被禁用怎么办?</p>
</blockquote>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>
<p>参考回答：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png" alt="img"></a></p>
<h2 id="11-Cookie的作用是什么-和Session有什么区别？"><a href="#11-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="11. Cookie的作用是什么?和Session有什么区别？"></a>11. Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Session没有数据大小限制，Cookie有。</p>
<p>相对 Cookie 来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="12-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#12-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="12. HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>12. HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><ol>
<li>在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="13-URI和URL的区别是什么"><a href="#13-URI和URL的区别是什么" class="headerlink" title="13. URI和URL的区别是什么?"></a>13. URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URI就是在某一规则下能把一个资源独一无二地标识出来。如：身份证</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL就是用定位的方式实现的URI。 可认为由4部分组成：协议、主机、端口、路径 http:localhost:8080/index.jsp ( 对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息) 如：具体住址</li>
</ul>
<p> URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="14-HTTP-和-HTTPS-的区别？"><a href="#14-HTTP-和-HTTPS-的区别？" class="headerlink" title="14. HTTP 和 HTTPS 的区别？"></a>14. HTTP 和 HTTPS 的区别？</h2><ol>
<li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li>安全性和资源消耗：<ul>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文。</li>
<li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。（ HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。）所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li>
</ul>
</li>
</ol>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:1">↩</a></li>
<li>JavaGuide面试突袭v4.0，计算机网络 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">https://www.cnblogs.com/gotodsp/p/6366163.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:3">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" data-id="cknmwaip90006j4ubba6y4v33" data-title="计算机网络总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-BIO-AIO-NIO区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:32:28.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/">BIO_AIO_NIO区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote>
<p>简单对比：</p>
<ul>
<li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p>
<p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p>
<p>比如下面的一些理解（我认为是不对的）：</p>
<blockquote>
<p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p>
<p><del>在网络请求中，客户端会发出一个请求到服务端</del></p>
<ol>
<li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li>
<li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li>
<li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li>
<li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li>
</ol>
</blockquote>
<p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p>
<ul>
<li>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</li>
<li>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</li>
</ul>
<p>本文的讨论：</p>
<ul>
<li>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:2">2]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:4">4]</a></li>
<li>讨论Java中对应的编程模型</li>
<li>对比BIO/NIO的区别[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:3">3]</a></li>
</ul>
<h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1. Linux下的五种I/O模型"></a>1. Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li>blocking IO</li>
<li>nonblocking IO</li>
<li>IO multiplexing</li>
<li>signal driven IO</li>
<li>asynchronous IO</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<blockquote>
<p>IO发生时涉及的对象和步骤:</p>
<ul>
<li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul>
<li>一个是调用这个IO的process (or thread)</li>
<li>另一个就是系统内核(kernel)</li>
</ul>
</li>
<li>当一个read操作发生时，它会经历两个阶段：<br>1 等待数据准备 (Waiting for the data to be ready)<br>2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
<li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li>
</ul>
</blockquote>
<h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
</li>
</ul>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BIO阻塞代码</span><br><span class="line">public class ServerTcpSocket &#123;</span><br><span class="line">    static byte[] bytes &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocket连接</span><br><span class="line">            final ServerSocket serverSocket &#x3D; new ServerSocket();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 3.当前线程放弃cpu资源等待获取数据</span><br><span class="line">            System.out.println(&quot;等待获取数据...&quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                final Socket socket &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">                executorService.execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;获取到数据...&quot;);</span><br><span class="line">                            &#x2F;&#x2F; 4.读取数据</span><br><span class="line">                            int read &#x3D; socket.getInputStream().read(bytes); &#x2F;&#x2F; 会阻塞</span><br><span class="line">                            String result &#x3D; new String(bytes);</span><br><span class="line">                            System.out.println(result);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p>
<h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
</li>
</ul>
<p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p>
<p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NIO非阻塞式代码</span><br><span class="line">public class ServerNioTcpSocket &#123;</span><br><span class="line">    static ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(512);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocketChannel连接</span><br><span class="line">            final ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocketChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 设置为非阻塞式</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 非阻塞式</span><br><span class="line">            SocketChannel socketChannel &#x3D; serverSocketChannel.accept(); </span><br><span class="line">            if (socketChannel !&#x3D; null) &#123;</span><br><span class="line">                int j &#x3D; socketChannel.read(byteBuffer);  &#x2F;&#x2F; 此处不会阻塞</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    byte[] bytes &#x3D; Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());</span><br><span class="line">                    System.out.println(&quot;获取到数据&quot; + new String(bytes));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;程序执行完毕..&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p>
<p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p>
<p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p>
<h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p>
<p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png" alt="img"></a></p>
<p>这里用java的NIO示意select</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<blockquote>
<p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</blockquote>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png" alt="img"></a></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p>
<p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p>
<h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p>
<ol>
<li>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</li>
<li>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</li>
</ol>
<blockquote>
<p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png" alt="img"></a></p>
<p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p>
<p>Unix，Linux操作系统的一些基本知识：</p>
<ul>
<li>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</li>
<li>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</li>
</ul>
<blockquote>
<p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p>
<p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p>
<p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select（1984）</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll（1997）</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll（2002）</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>Java NIO当中是使用哪一种机制？</p>
<p>基于内核版本，可以查看DefaultSelectorProvider源码：</p>
<ul>
<li>windows下，WindowsSelectorProvider。</li>
<li>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</li>
</ul>
<h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote>
<p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p>
<p>编程模型最简单。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复习黑马文件上传的服务端BIO代码</span><br><span class="line">public class FileUpload_Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;服务器 启动..... &quot;);</span><br><span class="line">        &#x2F;&#x2F; 1. 创建服务端ServerSocket</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket(6666);</span><br><span class="line">        &#x2F;&#x2F; 2. 循环接收,建立连接</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket accept &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">            &#x2F;*</span><br><span class="line">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="line">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="line">            *&#x2F;</span><br><span class="line">            new Thread(() ‐&gt; &#123;</span><br><span class="line">                try (</span><br><span class="line">                    &#x2F;&#x2F;3.1 获取输入流对象</span><br><span class="line">                    BufferedInputStream bis &#x3D; new BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    &#x2F;&#x2F;3.2 创建输出流对象, 保存到本地 .</span><br><span class="line">                    FileOutputStream fis &#x3D; new FileOutputStream(System.currentTimeMillis() +</span><br><span class="line">                    &quot;.jpg&quot;);</span><br><span class="line">                    BufferedOutputStream bos &#x3D; new BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3.3 读写数据</span><br><span class="line">                    byte[] b &#x3D; new byte[1024 * 8];</span><br><span class="line">                    int len;</span><br><span class="line">                    while ((len &#x3D; bis.read(b)) !&#x3D; ‐1) &#123;</span><br><span class="line">                        bos.write(b, 0, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;4. 关闭 资源</span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(&quot;文件上传已保存&quot;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p>
<p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p>
<blockquote>
<p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p>
<p>编程模型最复杂。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<p>NIO非阻塞体现:</p>
<ul>
<li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li>
<li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li>
</ul>
<p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p>
<p>编程模型比较简单，但需要操作系统来支持异步服务。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码(了解)</span><br><span class="line">public class AIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        final AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open().bind(new InewSocketAddress(9000));</span><br><span class="line">        </span><br><span class="line">        serverChannel.accept(null, new CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousServerSocketChannel socketChannel, Object attachment)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    &#x2F;&#x2F; 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br><span class="line">                    serverChannel.accept(attachment, this);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                    socketChannel.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void completed(Integer result, ByteBuffer buffer)&#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(new String(buffer.array(), 0, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        @Override</span><br><span class="line">                        public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png" alt="img"></a></p>
<h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote>
<p>NIO重点:</p>
<p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="img"></a></p>
<blockquote>
<p>简单解释：</p>
</blockquote>
<ul>
<li>每一个channel对应一个buffer缓冲区。</li>
<li>channel会注册到selector。</li>
<li>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</li>
<li>selector对应一个或者多个线程。</li>
<li>buffer和channel都是可读可写的。</li>
</ul>
<h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p>
<p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p>
<p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p>
<p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p>
<ul>
<li>ByteBuffer：字节缓冲区</li>
<li>CharBuffer:字符缓冲区</li>
<li>ShortBuffer：短整型缓冲区</li>
<li>IntBuffer：整型缓冲区</li>
<li>LongBuffer:长整型缓冲区</li>
<li>FloatBuffer：浮点型缓冲区</li>
<li>DoubleBuffer：双精度浮点型缓冲区</li>
</ul>
<h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p>
<p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p>
<p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p>
<p>Channel有四种实现：</p>
<ul>
<li>FileChannel:是从文件中读取数据。</li>
<li>DatagramChannel:从UDP网络中读取或者写入数据。</li>
<li>SocketChannel:从TCP网络中读取或者写入数据。</li>
<li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li>
</ul>
<h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<p><strong>关键对象</strong></p>
<ul>
<li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li>
<li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li>
</ul>
<p><strong>监听注册</strong></p>
<p>监听注册在Selector</p>
<blockquote>
<p>socketChannel.register(selector, SelectionKey.OP_READ);</p>
</blockquote>
<p><strong>监听的事件有</strong></p>
<ul>
<li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li>
<li>OP_READ: 读取就绪，socketChannel使用</li>
<li>OP_WRITE: 写入就绪，socketChannel使用</li>
<li>OP_CONNECT: 连接就绪，socketChannel使用</li>
</ul>
<h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:1">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:3">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:4">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" data-id="cknmwaip80005j4ubhwrqb91f" data-title="BIO_AIO_NIO区别" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:30:54.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/">MySQL高级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>基于<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">MySQL高级</a>的学习笔记，由于有些讲得不够全，做了部分补充[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:2">2]</a></p>
<blockquote>
<p>内容说明：</p>
<p>MySQL 是目前最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 也是目前最好的 RDBMS 应用软件之一。随着淘宝去IOE(去除IBM小型机、Oracle数据库及EMC存储设备)化的推进，MySQL 数据库在当前的互联网应用中变得越来越重要。</p>
<p>包括的MySQL 高级知识：索引，如何避免索引失效，索引优化策略，innodb和myisam存储引擎，MySQL锁机制，配置MySQL主从复制，explain、show profile、慢查询日志等日常SQL诊断和性能分析策略。</p>
</blockquote>
<h2 id="1-MySQL的架构介绍"><a href="#1-MySQL的架构介绍" class="headerlink" title="1.MySQL的架构介绍"></a>1.MySQL的架构介绍</h2><h3 id="1-1-MySQL简介"><a href="#1-1-MySQL简介" class="headerlink" title="1.1 MySQL简介"></a>1.1 MySQL简介</h3><ul>
<li>概述：关系型数据库管理系统RDBMS</li>
<li>高级MySQL：完整的mysql优化需要很深的功底，大公司有专门的DBA<ul>
<li>数据库内部结构和原理</li>
<li>数据库建模优化</li>
<li>数据库索引建立</li>
<li>SQL语句优化</li>
<li>SQL编程</li>
<li>mysql服务器安装配置</li>
<li>数据库的性能监控分析与系统优化</li>
<li>各种参数常量设定</li>
<li>主从复制</li>
<li>分布式架构搭建、垂直切割和水平切割</li>
<li>数据迁移</li>
<li>容灾备份和恢复</li>
<li>shell或python等脚本语言开发</li>
<li>对开源数据库进行二次开发</li>
</ul>
</li>
</ul>
<h3 id="1-2-MysqlLinux版的安装（mysql5-5）"><a href="#1-2-MysqlLinux版的安装（mysql5-5）" class="headerlink" title="1.2 MysqlLinux版的安装（mysql5.5）"></a>1.2 MysqlLinux版的安装（mysql5.5）</h3><ul>
<li>下载地址：</li>
</ul>
<p>官网下载地址：<a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p>
<ul>
<li><p>拷贝&amp;解压缩</p>
</li>
<li><p>检查工作</p>
<ul>
<li><p>检查是否安装过mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 执行安装命令前，先执行查询命令</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line"># 如果存在mysql-libs的旧版本包如下：请先执行卸载命令</span><br><span class="line">rpm -e --nodeps  mysql-libs  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 &#x2F;tmp</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql的安装文件目录下执行：</span><br><span class="line">rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpmrpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看MySQL安装版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin --version</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>mysql服务的启+停</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">ps -ef|grep mysql # 查看服务是否开启</span><br><span class="line">service mysql stop</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>首次登陆</p>
<p>安装完成后会提示出如下的提示：在mysql首次登录前要给 root 账号设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务后，执行命令 </span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root  password &#39;123123&#39;</span><br><span class="line"># 登录 </span><br><span class="line">mysql -uroot -p123123  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>自启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig mysql on # 设置开机自启动</span><br><span class="line">chkconfig --list | grep mysql</span><br><span class="line">ntsysv # 看到[*]mysql这一行，表示开机后会自启动mysql</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>mysql的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep mysql # 在linux下查看安装目录</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>参数路径解释备注</p>
<ul>
<li>basedir: /usr/bin 相关命令目录mysqladmin mysqldump等命令</li>
<li>datadir: /var/lib/mysql/ mysql数据库文件的存放路径</li>
<li>plugin-dir: /usr/lib64/mysql/pluginmysql插件存放路径</li>
<li>log-error: /var/lib/mysql/jack.atguigu.errmysql错误日志路径</li>
<li>pid-file: /var/lib/mysql/jack.atguigu.pid进程pid文件</li>
<li>socket:/var/lib/mysql/mysql.sock本地连接时用的unix套接字文件</li>
<li>/usr/share/mysql 配置文件目录mysql脚本及配置文件</li>
<li>/etc/init.d/mysql服务启停相关脚本</li>
</ul>
</li>
<li><p>mysql修改字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查看字符集设置</span><br><span class="line">show variables like &#39;character%&#39;;</span><br><span class="line">show variables like &#39;%char%&#39;;</span><br><span class="line"># 默认的是客户端和服务器都用了latin1，所以会乱码</span><br><span class="line"></span><br><span class="line"># 2. 修改my.cnf</span><br><span class="line"># 在&#x2F;usr&#x2F;share&#x2F;mysql&#x2F; 中找到my.cnf的配置文件，拷贝其中的my-huge.cnf 到&#x2F;etc&#x2F;, 并命名为my.cnf mysql</span><br><span class="line"># 优先选中&#x2F;etc&#x2F;下的配置文件然后修改my.cnf:</span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8character_set_client&#x3D;utf8collation-server&#x3D;utf8_general_ci</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line"># 3. 重新启动mysql</span><br><span class="line"># 但是原库的设定不会发生变化，参数修改之对新建的数据库生效 </span><br><span class="line"></span><br><span class="line"># 4. 已生成的库表字符集如何变更修改数据库的字符集</span><br><span class="line">alter database mytest character set &#39;utf8&#39;;</span><br><span class="line"># 修改数据表的字符集</span><br><span class="line">alter table user convert to  character set &#39;utf8&#39;; </span><br><span class="line">但是原有的数据如果是用非&#39;utf8&#39;编码的话，数据本身不会发生改变。     </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-mysql配置文件"><a href="#1-3-mysql配置文件" class="headerlink" title="1.3 mysql配置文件"></a>1.3 mysql配置文件</h3><p>（先大致了解，混个眼熟）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="img"></a></p>
<h3 id="1-4-mysql逻辑框架简介"><a href="#1-4-mysql逻辑框架简介" class="headerlink" title="1.4 mysql逻辑框架简介"></a>1.4 mysql逻辑框架简介</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png" alt="img"></a></p>
<blockquote>
<p>和其它数据库相比，MySQL有点与众不同，<strong>它的架构可以在多种不同场景中应用并发挥良好作用</strong>。</p>
<p>主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。</p>
<p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p>
</blockquote>
<ul>
<li><p>连接层</p>
<p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层</p>
<ol>
<li>Management Serveices &amp; Utilities： 系统管理和控制工具</li>
<li>SQL Interface: SQL接口 接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li>
<li>Parser: 解析器 SQL命令传递到解析器的时候会被解析器验证和解析。</li>
<li>Optimizer: 查询优化器。 SQL语句在查询之前会使用查询优化器对查询进行优化。 用一个例子就可以理解： select uid,name from user where gender= 1; 优化器来决定先投影还是先过滤。</li>
<li>Cache和Buffer： 查询缓存。 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 缓存是负责读，缓冲负责写。</li>
</ol>
</li>
<li><p>引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p>
</li>
<li><p>存储层</p>
<p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<h3 id="1-5-mysql存储引擎"><a href="#1-5-mysql存储引擎" class="headerlink" title="1.5 mysql存储引擎"></a>1.5 mysql存储引擎</h3><h4 id="1-5-1-查看命令"><a href="#1-5-1-查看命令" class="headerlink" title="1.5.1 查看命令"></a>1.5.1 查看命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 看你的mysql现在已提供什么存储引擎</span><br><span class="line">show engines; </span><br><span class="line"># 看你的mysql当前默认的存储引擎:  </span><br><span class="line">show variables like &#39;%storage_engine%&#39;; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-MyISAM和InnoDB"><a href="#1-5-2-MyISAM和InnoDB" class="headerlink" title="1.5.2 MyISAM和InnoDB"></a>1.5.2 <strong>MyISAM和InnoDB</strong></h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png" alt="img"></a></p>
<h4 id="1-5-3-各个存储引擎介绍"><a href="#1-5-3-各个存储引擎介绍" class="headerlink" title="1.5.3 各个存储引擎介绍"></a>1.5.3 各个存储引擎介绍</h4><ol>
<li><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况</li>
<li><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li>
<li>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li>
<li>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li>
<li>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis)</li>
<li>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ol>
<h4 id="1-5-4-阿里巴巴、淘宝用哪个"><a href="#1-5-4-阿里巴巴、淘宝用哪个" class="headerlink" title="1.5.4 阿里巴巴、淘宝用哪个"></a>1.5.4 阿里巴巴、淘宝用哪个</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png" alt="img"></a></p>
<h2 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2. 索引优化分析"></a>2. 索引优化分析</h2><h3 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png" alt="img"></a></p>
<h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png" alt="img"></a></p>
<ul>
<li><p>SQL解析：机读顺序（先from）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png" alt="img"></a></p>
</li>
<li><p>Join图（重点，基本功一定要记住）：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png" alt="img"></a></p>
</li>
</ul>
<h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么（重点）"><a href="#2-3-1-索引是什么（重点）" class="headerlink" title="2.3.1 索引是什么（重点）"></a>2.3.1 索引是什么（重点）</h4><blockquote>
<p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
</blockquote>
<ul>
<li><p><strong>索引的本质</strong>：索引是数据结构</p>
</li>
<li><p>索引的目的：在于提高查询效率</p>
<p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
</li>
<li><p>简单理解： <strong>索引是排好序的快速查找数据结构</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png" alt="img"></a></p>
<ul>
<li>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。</li>
<li>B-TREE：(B:balance) 会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)</li>
<li>B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。</li>
<li>B+TREE：Innodb 所使用的索引</li>
</ul>
</li>
<li><p><strong>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引</strong>。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p>
</li>
</ul>
<h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ul>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
<h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ul>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的</li>
<li>虽然索引大大<strong>提高了查询速度</strong>，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
<li><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</strong></li>
</ul>
<h4 id="2-3-4-索引的分类"><a href="#2-3-4-索引的分类" class="headerlink" title="2.3.4 索引的分类"></a>2.3.4 索引的分类</h4><h5 id="2-3-4-1-单值索引"><a href="#2-3-4-1-单值索引" class="headerlink" title="2.3.4.1 单值索引"></a>2.3.4.1 单值索引</h5><blockquote>
<p>即一个索引只包含单个列，一个表可以有多个单列索引</p>
</blockquote>
<h5 id="2-3-4-2-唯一索引"><a href="#2-3-4-2-唯一索引" class="headerlink" title="2.3.4.2 唯一索引"></a>2.3.4.2 唯一索引</h5><blockquote>
<p>索引列的值必须唯一，但允许有空值</p>
</blockquote>
<h5 id="2-3-4-3-复合索引"><a href="#2-3-4-3-复合索引" class="headerlink" title="2.3.4.3 复合索引"></a>2.3.4.3 复合索引</h5><blockquote>
<p>即一个索引包含多个列</p>
</blockquote>
<h5 id="2-3-4-4-主键索引"><a href="#2-3-4-4-主键索引" class="headerlink" title="2.3.4.4 主键索引"></a>2.3.4.4 主键索引</h5><blockquote>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇（聚集）索引</p>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<h5 id="2-3-4-5-基本语法"><a href="#2-3-4-5-基本语法" class="headerlink" title="2.3.4.5 基本语法"></a>2.3.4.5 基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建</span><br><span class="line">CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))</span><br><span class="line">ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) </span><br><span class="line"></span><br><span class="line"># 2. 删除</span><br><span class="line">DROP INDEX [indexName] ON mytable</span><br><span class="line"></span><br><span class="line"># 3. 查看</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br><span class="line"></span><br><span class="line"># 4. 使用ALTER命令</span><br><span class="line"># 有四种方式来添加数据表的索引：</span><br><span class="line">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) # 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">ALTER TABLE tbl_name ADD UNIQUE index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次</span><br><span class="line">ALTER TABLE tbl_name ADD INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。</span><br><span class="line">ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) #该语句指定了索引为 FULLTEXT ，用于全文索引。 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-mysql索引结构⭐"><a href="#2-3-5-mysql索引结构⭐" class="headerlink" title="2.3.5 mysql索引结构⭐"></a>2.3.5 mysql索引结构⭐</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<ul>
<li><p>B-Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ul>
<li>d为大于1的一个正整数，称为B-Tree的度。</li>
<li>h为一个正整数，称为B-Tree的高度。</li>
<li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li>
<li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li>
<li>所有叶节点具有相同的深度，等于树高h。</li>
<li>key和指针互相间隔，节点两端是指针。</li>
<li>一个节点中的key从左到右非递减排列。</li>
<li>所有节点组成树结构。</li>
<li>每个指针要么为null，要么指向另外一个节点。</li>
<li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li>
<li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li>
<li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png" alt="img"></a></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    if(node &#x3D;&#x3D; null) return null;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node.key[i] &#x3D;&#x3D; key) return node.data[i];</span><br><span class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    return BTree_Search(point[i+1]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data &#x3D; BTree_Search(root, my_key);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p>
</li>
<li><p>B+Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ul>
<li>每个节点的指针上限为2d而不是2d+1。</li>
<li>内节点不存储data，只存储key；叶子节点不存储指针。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png" alt="img"></a></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p>
</li>
<li><p>带有顺序访问指针的B+Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p>
</li>
<li><p>为什么使用B-Tree（B+Tree）[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础</p>
<p>考虑到<strong>主存存取原理</strong>，<strong>磁盘存取原理</strong>，<strong>局部性原理与磁盘预读</strong>详细见[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li><p>一般使用磁盘I/O次数评价索引结构的优劣。</p>
</li>
<li><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<blockquote>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
</blockquote>
</li>
<li><p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(logdN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</strong></p>
</li>
<li><p>综上所述，用B-Tree作为索引结构效率是非常高的</p>
</li>
<li><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多</p>
</li>
</ul>
</li>
<li><p>B+Tree适合外存索引的原因[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a>：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png" alt="img"></a></p>
</li>
<li><p>B+Tree的索引id为什么设置为自增有益于索引维护</p>
<ul>
<li>可以避免<strong>页分裂</strong>和<strong>页合并</strong></li>
</ul>
</li>
<li><p>MyISAM索引实现[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png" alt="img"></a></p>
<blockquote>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<blockquote>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
</blockquote>
</li>
<li><p>InnoDB索引实现[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</li>
<li>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png" alt="img"></a></p>
<blockquote>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<ul>
<li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如下图为定义在Col3上的一个辅助索引</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。</p>
</blockquote>
<ul>
<li><p>聚簇索引和非聚簇索引的区别[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:10">10]</a></p>
<p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。详细见这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/alexdamiao/article/details/51934917">博客</a></p>
<ul>
<li>InnoDB按聚簇索引的形式存储数据</li>
<li>MyISAM按照非聚簇索引的形式存储数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_50_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_50_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
</li>
<li><p>回表</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_51_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_51_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
<h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<h4 id="2-3-7-哪些情况不需要创建索引"><a href="#2-3-7-哪些情况不需要创建索引" class="headerlink" title="2.3.7 哪些情况不需要创建索引"></a>2.3.7 哪些情况不需要创建索引</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<p>关于<strong>2.3.7.4</strong>的判断公式：<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<h3 id="2-4-索引性能分析"><a href="#2-4-索引性能分析" class="headerlink" title="2.4 索引性能分析"></a>2.4 索引性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png" alt="img"></a></p>
<h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png" alt="img"></a></p>
<h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 <strong>Explain</strong></h4><h5 id="2-4-3-1-Explain是什么"><a href="#2-4-3-1-Explain是什么" class="headerlink" title="2.4.3.1 Explain是什么"></a>2.4.3.1 Explain是什么</h5><blockquote>
<p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
</blockquote>
<p>官网介绍: <a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p>
<h5 id="2-4-3-2-Explain能干嘛"><a href="#2-4-3-2-Explain能干嘛" class="headerlink" title="2.4.3.2 Explain能干嘛"></a>2.4.3.2 Explain能干嘛</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png" alt="img"></a></p>
<h5 id="2-4-3-3-Explain怎么用"><a href="#2-4-3-3-Explain怎么用" class="headerlink" title="2.4.3.3 Explain怎么用"></a>2.4.3.3 Explain怎么用</h5><blockquote>
<p>Explain + SQL语句</p>
</blockquote>
<ul>
<li><p>执行计划包含的信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png" alt="img"></a></p>
</li>
</ul>
<h5 id="2-4-3-4-Explain执行计划各字段解释"><a href="#2-4-3-4-Explain执行计划各字段解释" class="headerlink" title="2.4.3.4 Explain执行计划各字段解释"></a>2.4.3.4 Explain执行计划各字段解释</h5><ul>
<li><p>id ⭐：</p>
<ul>
<li><p>含义：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的<strong>顺序</strong></p>
</li>
<li><p>三种情况：</p>
<ul>
<li><p>id相同：执行顺序由上至下</p>
</li>
<li><p>id不同：如果是子查询，id的序号会递增，<strong>id值越大优先级越高</strong>，越先被执行</p>
</li>
<li><p>id相同/不同，同时存在：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png" alt="img"></a></p>
<p>衍生表 = derived2 –&gt; derived + 2</p>
<p>（2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>select_type：</p>
<ul>
<li><p>包含：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png" alt="img"></a></p>
</li>
<li><p>查询的类型：</p>
<p>主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>table：显示这一行的数据是关于哪张表的</p>
</li>
<li><p>type⭐：</p>
<ul>
<li><p>包含：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png" alt="img"></a></p>
</li>
<li><p>type显示的是访问类型，是较为重要的一个指标</p>
</li>
<li><p><strong>结果值从最好到最坏依次是</strong>：</p>
<p>(system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL )</p>
<p><strong>简化版（记住）</strong>：<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> 一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>possible_keys：</p>
<ul>
<li>显示可能应用在这张表中的索引，一个或多个。</li>
<li>查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong></li>
</ul>
</li>
<li><p>key⭐：</p>
<ul>
<li>实际使用的索引。如果为NULL，则没有使用索引、索引失效</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</strong></li>
</ul>
</li>
<li><p>key_len：</p>
<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。不损失精度性的情况下，长度越短越好</li>
<li>key_len字段能够帮你检查是否充分的利用上了索引</li>
</ul>
</li>
<li><p>ref：</p>
<ul>
<li>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li>
</ul>
</li>
<li><p>rows⭐：</p>
<ul>
<li>rows列显示MySQL认为它执行查询时必须检查的行数。</li>
<li>越少越好</li>
</ul>
</li>
<li><p>Extra⭐：</p>
<ul>
<li><p>包含不适合在其他列中显示但十分重要的额外信息</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png" alt="img"></a></p>
</li>
<li><p><strong>覆盖索引</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p>
<p>①一个索引</p>
<p>②包含了(或覆盖了)[select子句]与查询条件[Where子句]中</p>
<p>③所有需要的字段就叫做<strong>覆盖索引</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
<p><strong>理解</strong>：</p>
<blockquote>
<p>select id , name from t_xxx where age=18;</p>
<p>有一个组合索引 idx_id_name_age_xxx 包含了(覆盖了) id,name,age三个字段。查询时直接将建立了索引的列读取出来了，而不需要去查找所在行的其他数据, 所以很高效。</p>
</blockquote>
<p>(个人认为：在数据量较大，固定字段查询情况多时可以使用这种方法。)</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-查询优化"><a href="#2-5-查询优化" class="headerlink" title="2.5 查询优化"></a>2.5 查询优化</h3><h4 id="2-5-1-索引优化"><a href="#2-5-1-索引优化" class="headerlink" title="2.5.1 索引优化"></a>2.5.1 索引优化</h4><h5 id="2-5-1-1-索引分析"><a href="#2-5-1-1-索引分析" class="headerlink" title="2.5.1.1 索引分析"></a>2.5.1.1 索引分析</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=209">单表分析案例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=210">多表分析案例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=211">三表分析案例</a><ul>
<li>尽可能减少Join语句的NextedLoop的循环总次数：永远用小结果集驱动大结果集</li>
<li>优先优化NestedLoop的内层循环</li>
<li><strong>保证Join语句中被驱动表上Join条件的字段已经被索引</strong></li>
<li>当无法保证被驱动表的Join条件字段被索引且内存充足的前提下，不要太吝啬JoinBuffer的设置</li>
</ul>
</li>
</ul>
<h5 id="2-5-1-2-索引失效"><a href="#2-5-1-2-索引失效" class="headerlink" title="2.5.1.2 索引失效"></a>2.5.1.2 <strong>索引失效</strong></h5><ul>
<li><p><strong>联合索引在B+Tree上的存储结构及数据查找方式.</strong></p>
<p>⭐，具体参考</p>
<p>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:3">3]</a></p>
<p>（基于底层去理解索引失效）</p>
<ul>
<li>这里贴一个简单的联合索引的结构图，具体看上面的帖子</li>
<li><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png" alt="img"></a></li>
</ul>
</li>
<li><p>索引失效案例</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png" alt="img"></a></p>
<ul>
<li><p>小总结：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="img"></a></p>
</li>
<li><p>（补充）覆盖索引、最左匹配、索引下推的理解⭐</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#%E5%9B%9E%E8%A1%A8">回表</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;zhansan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>第一次查询name的B+Tree，根据那么获取到主键id，然后再根据id去id的B+Tree找到行记录，这个回表过程会导致IO次数变多。</p>
</li>
<li><p>覆盖索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name from table where name&#x3D;zhansan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在进行检索是，直接更具那么去name的B+Tree获取到id，name两列的值，不需要回表，效率高，应该尽可能多的使用索引覆盖来代替回表，所以有时候，在复杂的sql中，可以考虑将不相关的列都设置为索引列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from table where name&#x3D;zhangsan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>这里name，age作为一个联合索引</p>
</li>
<li><p>最左匹配：</p>
<p>有一个表：id，name，age，gender（id是主键，name，age是联合索引）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;?           # 符合</span><br><span class="line">select * from table where name&#x3D;? and age&#x3D;? # 符合</span><br><span class="line">select * from table where age&#x3D;? &#x3D; name&#x3D;?   # 优化器会优化,使其符合最左匹配</span><br><span class="line">select * from table where age&#x3D;?            # 不符合</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>索引下推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;? and age&#x3D;?</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>在没有索引下推之前，先根据name去存储引擎中拉取符合结构的数据，返回到server层，在server层中对age的条件进行过滤</li>
<li>有了索引下推之后，根据name，age两个条件直接从存储引擎中拉去结果，不需要再server层做条件过滤</li>
<li>mysql5.7版本之后默认开启</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-5-1-3-一般性建议"><a href="#2-5-1-3-一般性建议" class="headerlink" title="2.5.1.3 一般性建议"></a>2.5.1.3 一般性建议</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png" alt="img"></a></p>
<h5 id="2-5-1-4-优化口诀"><a href="#2-5-1-4-优化口诀" class="headerlink" title="2.5.1.4 优化口诀"></a>2.5.1.4 优化口诀</h5><p>建议理解，不用背</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png" alt="img"></a></p>
<h4 id="2-5-2-查询优化"><a href="#2-5-2-查询优化" class="headerlink" title="2.5.2 查询优化"></a>2.5.2 查询优化</h4><blockquote>
<p>对于数据库分析</p>
<ol>
<li>观察，至少跑一天，看看生产的慢SQL情况。</li>
<li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li>
<li>explain+慢SQL分析</li>
<li>show profile</li>
<li>运维经理 or DBA来进行SQL数据库服务器的参数调优</li>
</ol>
</blockquote>
<p><strong>总结</strong>：</p>
<ul>
<li>慢查询开启并捕获</li>
<li>explain+慢SQL分析</li>
<li>show profile查询SQL再MySQL服务器里面的执行细节和生命周期情况</li>
<li>SQL数据库服务器参数调优</li>
</ul>
<p>关于下面2.5.2.1和2.5.2.3的优化原理见我后面写的<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/04/01/MySQL_Join%E4%BC%98%E5%8C%96/">Join优化</a></p>
<h5 id="2-5-2-1-小表驱动大表"><a href="#2-5-2-1-小表驱动大表" class="headerlink" title="2.5.2.1 小表驱动大表"></a>2.5.2.1 小表驱动大表</h5><ul>
<li><p>类似嵌套循环Nested Loop</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png" alt="img"></a></p>
</li>
<li><p>in/exists</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png" alt="img"></a></p>
</li>
</ul>
<h5 id="2-5-2-2-order-by关键字优化"><a href="#2-5-2-2-order-by关键字优化" class="headerlink" title="2.5.2.2 order by关键字优化"></a>2.5.2.2 order by关键字优化</h5><blockquote>
<p>尽量使用Index方式排序,避免使用FileSort方式排序</p>
</blockquote>
<ul>
<li>MySQL支持二种方式的排序，FileSort和Index<ul>
<li>Index效率高.它指MySQL扫描索引本身完成排序。</li>
</ul>
</li>
<li>FileSort方式效率较低。</li>
</ul>
<blockquote>
<p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
</blockquote>
<ul>
<li><p>ORDER BY满足两情况，会使用Index方式排序</p>
<ul>
<li>ORDER BY 语句使用索引最左前列</li>
<li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li>
<li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li>
</ul>
</li>
<li><p>小总结：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png" alt="img"></a></p>
</li>
</ul>
<blockquote>
<p>如果不在索引列上，filesort有两种算法：</p>
<p>mysql就要启动<strong>双路排序</strong>和<strong>单路排序</strong></p>
</blockquote>
<ul>
<li><p>双路排序</p>
<ul>
<li>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。（两次）</li>
<li><strong>缺点</strong>：取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li>
</ul>
</li>
<li><p>单路排序</p>
<ul>
<li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</li>
<li>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li>
<li>结论及引申出的问题：<ul>
<li>结论：由于单路是后出的，总体而言好过双路</li>
<li>问题：在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li>
</ul>
</li>
</ul>
</li>
<li><p>优化策略</p>
<ul>
<li><p>增大sort_buffer_size参数的设置</p>
</li>
<li><p>增大max_length_for_sort_data参数的设置</p>
</li>
<li><p>去掉select 后面不需要的字段</p>
</li>
<li><p>以上策略对应的原因：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-5-2-3-group-by关键字优化"><a href="#2-5-2-3-group-by关键字优化" class="headerlink" title="2.5.2.3 group by关键字优化"></a>2.5.2.3 group by关键字优化</h5><ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了。</li>
</ul>
<h5 id="2-5-2-4-关联查询优化"><a href="#2-5-2-4-关联查询优化" class="headerlink" title="2.5.2.4 关联查询优化"></a>2.5.2.4 关联查询优化</h5><ul>
<li>保证被驱动表的join字段已经被索引</li>
<li>left join 时，选择小表作为驱动表，大表作为被驱动表</li>
<li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表</li>
<li>子查询尽量不要放在被驱动表，有可能使用不到索引</li>
</ul>
<h5 id="2-5-2-5-子查询优化"><a href="#2-5-2-5-子查询优化" class="headerlink" title="2.5.2.5 子查询优化"></a>2.5.2.5 子查询优化</h5><ul>
<li>有索引的情况下 用 inner join 是最好的 其次是 in ，exists最糟糕</li>
<li>无索引的情况下用 小表驱动大表 因为join 方式需要distinct ，没有索引distinct消耗性能较大 所以 exists性能最佳 in其次 join性能最差</li>
<li>无索引的情况下大表驱动小表in 和 exists 的性能应该是接近的 都比较糟糕 exists稍微好一点 超不过5% 但是inner join 由于使用了 join buffer 所以快很多如果left join 则最慢</li>
</ul>
<h5 id="2-5-2-6-分页查询优化"><a href="#2-5-2-6-分页查询优化" class="headerlink" title="2.5.2.6 分页查询优化"></a>2.5.2.6 分页查询优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY deptno  LIMIT 10000,40</span><br><span class="line"># 优化后</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp INNER JOIN (SELECT id FROM emp e ORDER BY deptno LIMIT 10000,40) a ON a.id&#x3D;emp.id</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联（查询的数据量小了）</p>
</li>
<li><p>实践证明：</p>
<p>①、order by 后的字段（XXX）有索引</p>
<p>②、sql 中有 limit 时， 当 select id 或 XXX字段索引包含字段时 ，显示 using index 当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort</p>
</li>
</ul>
<h5 id="2-5-2-7-去重优化"><a href="#2-5-2-7-去重优化" class="headerlink" title="2.5.2.7 去重优化"></a>2.5.2.7 去重优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将产生重复数据</span><br><span class="line">select kcdz from t_mall_sku where id in( 3,4,5,6,8 )</span><br><span class="line"></span><br><span class="line"># 使用 distinct 关键字去重消耗性能优化</span><br><span class="line">select distinct kcdz from t_mall_sku where id in( 3,4,5,6,8 )</span><br><span class="line"></span><br><span class="line"># 能够利用到索引</span><br><span class="line">select  kcdz from t_mall_sku where id in( 3,4,5,6,8 )  group by kcdz </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量不要使用 distinct 关键字去重</li>
<li>group by能去重且利用索引</li>
</ul>
<h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3. 查询截取分析"></a>3. 查询截取分析</h2><h3 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h3><h4 id="3-1-1-慢查询日志介绍"><a href="#3-1-1-慢查询日志介绍" class="headerlink" title="3.1.1 慢查询日志介绍"></a>3.1.1 慢查询日志介绍</h4><ul>
<li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</li>
<li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</li>
<li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</li>
</ul>
<h4 id="3-1-2-慢查询日志使用"><a href="#3-1-2-慢查询日志使用" class="headerlink" title="3.1.2 慢查询日志使用"></a>3.1.2 慢查询日志使用</h4><blockquote>
<p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p>
</blockquote>
<ul>
<li><p>查看是否开启及如何开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看</span><br><span class="line">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br><span class="line"># 设置开启，只对当前数据库生效</span><br><span class="line">set global slow_query_log&#x3D;1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png" alt="img"></a></p>
</li>
<li><p>查看当前多少秒算慢, 以及修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看</span><br><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line"># 设置</span><br><span class="line">set global long_query_time&#x3D;1;</span><br><span class="line"># 需要重新连接或新开一个会话才能看到修改值</span><br><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line"></span><br><span class="line"># 改变当前session变量</span><br><span class="line">set session long_query_time&#x3D;1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#39;%Slow_queries%&#39;;  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-3-日志分析工具mysqldumpslow"><a href="#3-1-3-日志分析工具mysqldumpslow" class="headerlink" title="3.1.3 日志分析工具mysqldumpslow"></a>3.1.3 日志分析工具mysqldumpslow</h4><ul>
<li><p>工作常用参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png" alt="img"></a></p>
</li>
</ul>
<h3 id="3-2-批量数据脚本"><a href="#3-2-批量数据脚本" class="headerlink" title="3.2 批量数据脚本"></a>3.2 批量数据脚本</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png" alt="img"></a></p>
<ul>
<li><p>创建函数，假如报错：This function has none of DETERMINISTIC……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 由于开启过慢查询日志，因为我们开启了 bin-log, 我们就必须为我们的function指定一个参数。</span><br><span class="line">show variables like &#39;log_bin_trust_function_creators&#39;;</span><br><span class="line">set global log_bin_trust_function_creators&#x3D;1;</span><br><span class="line"></span><br><span class="line"># 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：</span><br><span class="line"># windows下: my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1</span><br><span class="line"># linux下: &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>创建函数,保证每条数据都不同</p>
<ul>
<li><p>随机产生字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN    ##方法开始 </span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT   &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;;  ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  </span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;; DECLARE i INT DEFAULT 0;  ##循环开始</span><br><span class="line">WHILE i &lt; n DO   </span><br><span class="line">SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));##concat 连接函数  ，substring(a,index,length) 从index处开始截取</span><br><span class="line">SET i &#x3D; i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END $$ </span><br><span class="line"># 假如要删除</span><br><span class="line"># drop function rand_string;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>随机产生部门编号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    DELIMITER $$</span><br><span class="line">    CREATE FUNCTION rand_num( ) RETURNS INT(5)</span><br><span class="line">BEGIN    </span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i &#x3D; FLOOR(100+RAND()*10);</span><br><span class="line">    RETURN i;</span><br><span class="line">    END $$  </span><br><span class="line">    # 假如要删除</span><br><span class="line">    # drop function rand_num;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建存储过程</p>
<ul>
<li><p>插入数据的存储过程(往emp表添加随机数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp10000(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN  </span><br><span class="line">DECLARE i INT DEFAULT 0;   #set autocommit &#x3D;0 把autocommit设置成0  ；提高执行效率 </span><br><span class="line">SET autocommit &#x3D; 0;     </span><br><span class="line">REPEAT  ##重复 </span><br><span class="line">SET i &#x3D; i + 1;   </span><br><span class="line">INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   </span><br><span class="line">UNTIL i &#x3D; max_num   ##直到  上面也是一个循环</span><br><span class="line">END REPEAT;  ##满足条件后结束循环 </span><br><span class="line">COMMIT;   ##执行完成后一起提交 </span><br><span class="line">END $$ </span><br><span class="line"># 删除</span><br><span class="line"># DELIMITER ;</span><br><span class="line"># drop PROCEDURE insert_emp; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>插入数据的存储过程(往dept表添加随机数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加随机数据</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN  </span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit &#x3D; 0;     </span><br><span class="line">REPEAT   </span><br><span class="line">SET i &#x3D; i + 1;   </span><br><span class="line">INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   </span><br><span class="line">UNTIL i &#x3D; max_num   </span><br><span class="line">END REPEAT;   </span><br><span class="line">COMMIT;   </span><br><span class="line">END $$  </span><br><span class="line">#删除</span><br><span class="line"># DELIMITER ; #将 结束标志换回 ;</span><br><span class="line"># drop PROCEDURE insert_dept;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用存储过程</p>
<ul>
<li><p>dept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ; #将 结束标志换回 ;</span><br><span class="line">CALL insert_dept(100,10); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>emp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往emp表添加50万条数据</span><br><span class="line">DELIMITER ;    #将 结束标志换回 ;</span><br><span class="line">CALL insert_emp(100001,500000);  </span><br><span class="line">CALL insert_emp10000(100001,10000);    </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-3-Show-Profile"><a href="#3-3-Show-Profile" class="headerlink" title="3.3 Show Profile"></a>3.3 Show Profile</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><blockquote>
<p>是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</blockquote>
<h4 id="3-3-2-官网介绍"><a href="#3-3-2-官网介绍" class="headerlink" title="3.3.2 官网介绍"></a>3.3.2 官网介绍</h4><p>官网：<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p>
<h4 id="3-3-3-默认设置"><a href="#3-3-3-默认设置" class="headerlink" title="3.3.3 默认设置"></a>3.3.3 默认设置</h4><blockquote>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</blockquote>
<h4 id="3-3-4-分析步骤"><a href="#3-3-4-分析步骤" class="headerlink" title="3.3.4 分析步骤"></a>3.3.4 分析步骤</h4><ul>
<li><p>看看当前的mysql版本是否支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Show variables like &#39;profiling&#39;; #  默认是关闭，使用前需要开启    </span><br><span class="line">set profiling&#x3D;1;  #  开启</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>运行SQL</p>
</li>
<li><p>查看结果，show profiles；</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png" alt="img"></a></p>
</li>
<li><p>诊断SQL，show profile cpu,block io for query n (n为上一步前面的问题SQL数字号码);</p>
<ul>
<li><p>查询命令的参数</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png" alt="img"></a></p>
</li>
<li><p>查询结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>日常开发需要注意的结论</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png" alt="img"></a></p>
<ul>
<li><p>创建临时表的性能耗费示例：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-全局查询日志"><a href="#3-4-全局查询日志" class="headerlink" title="3.4 全局查询日志"></a>3.4 全局查询日志</h3><h4 id="3-4-1-配置启用"><a href="#3-4-1-配置启用" class="headerlink" title="3.4.1 配置启用"></a>3.4.1 配置启用</h4><p>在mysql的my.cnf中，设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">general_log&#x3D;1  </span><br><span class="line"># 记录日志文件的路径</span><br><span class="line">general_log_file&#x3D;&#x2F;path&#x2F;logfile</span><br><span class="line"># 输出格式</span><br><span class="line">log_output&#x3D;FILE</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-编码启用"><a href="#3-4-2-编码启用" class="headerlink" title="3.4.2 编码启用"></a>3.4.2 编码启用</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png" alt="img"></a></p>
<blockquote>
<p><strong>特别的：尽量不要在生产环境开启这个功能</strong></p>
</blockquote>
<h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
</blockquote>
<h3 id="4-2-锁的分类"><a href="#4-2-锁的分类" class="headerlink" title="4.2 锁的分类"></a>4.2 锁的分类</h3><h4 id="4-2-1-从对数据操作的类型（读-写）分"><a href="#4-2-1-从对数据操作的类型（读-写）分" class="headerlink" title="4.2.1 从对数据操作的类型（读\写）分"></a>4.2.1 从对数据操作的类型（读\写）分</h4><ul>
<li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
<h4 id="4-2-2-从对数据操作的粒度分"><a href="#4-2-2-从对数据操作的粒度分" class="headerlink" title="4.2.2 从对数据操作的粒度分"></a>4.2.2 从对数据操作的粒度分</h4><ul>
<li>表锁</li>
<li>行锁</li>
</ul>
<h3 id="4-3-三锁"><a href="#4-3-三锁" class="headerlink" title="4.3 三锁"></a>4.3 三锁</h3><h4 id="4-3-1-表锁（偏读）"><a href="#4-3-1-表锁（偏读）" class="headerlink" title="4.3.1 表锁（偏读）"></a>4.3.1 表锁（偏读）</h4><blockquote>
<p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
</blockquote>
<ul>
<li><p>手动加读写锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tabel 表名 read(write), 表名2 read(write), ...;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看表上加过的锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show open tables;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>释放表锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png" alt="img"></a></p>
<p>补充：加读锁的session也不能修改加读锁的表。</p>
<p><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></p>
</li>
<li><p>如何分析表锁定</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png" alt="img"></a></p>
</li>
</ul>
<h4 id="4-3-2-行锁（偏写）"><a href="#4-3-2-行锁（偏写）" class="headerlink" title="4.3.2 行锁（偏写）"></a>4.3.2 行锁（偏写）</h4><blockquote>
<p>特点：</p>
<ol>
<li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li>
</ol>
</blockquote>
<ul>
<li><p>行锁支持事务，<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/#5-TCL%E8%AF%AD%E8%A8%80">复习初级部分知识⭐</a></p>
<ul>
<li><p>重点:事务特性、并发事务导致的问题、事务隔离级别等</p>
</li>
<li><p>补充：并发事务导致的问题（更新丢失）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p><strong>无索引(或者索引失效)行锁升级为表锁</strong></p>
</li>
<li><p>间隙锁的危害</p>
<ul>
<li><p><strong>间隙锁</strong>:</p>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。</p>
</li>
<li><p><strong>危害</strong>:</p>
<p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
</li>
</ul>
</li>
<li><p><strong>[面试题] 常考如何锁定一行</strong></p>
<p>事务显示加锁[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:9">9]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##在 MySQL 5.7 中</span><br><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line">排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br><span class="line"></span><br><span class="line">##在 MySQL 8.0 中</span><br><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... FOR SHARE</span><br><span class="line">排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE[NOWAIT|SKIP LOCKED]</span><br><span class="line">--NOWAIT:发现有锁等待后会立即返回错误，不用等待锁超时后报错。</span><br><span class="line">--SKIP LOCKED:跳过被锁定的行，直接更新其他行，但是这样要注意是否会造成更新结果不符合预期。</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="img"></a></p>
</li>
<li><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。</p>
</li>
<li><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
</li>
<li><p>如何分析行锁定</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png" alt="img"></a></p>
</li>
<li><p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>尽可能较少检索条件，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁</li>
<li>涉及相同表的事务，对于调用表的顺序尽量保持一致</li>
<li>在业务环境允许的情况下,尽可能低级别事务隔离</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-页锁（了解）"><a href="#4-3-2-页锁（了解）" class="headerlink" title="4.3.2 页锁（了解）"></a>4.3.2 页锁（了解）</h4><blockquote>
<p>开销和加锁时间界于表锁和行锁之间；</p>
<p>会出现死锁；</p>
<p>锁定粒度界于表锁和行锁之间，并发度一般。</p>
</blockquote>
<h2 id="5-主从复制⭐"><a href="#5-主从复制⭐" class="headerlink" title="5. 主从复制⭐"></a>5. 主从复制⭐</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="img"></a></p>
<h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="img"></a></p>
<h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><blockquote>
<p>延时</p>
</blockquote>
<h3 id="5-4-一主一从常见配置"><a href="#5-4-一主一从常见配置" class="headerlink" title="5.4 一主一从常见配置"></a>5.4 一主一从常见配置</h3><ul>
<li><p>mysql版本一致且后台以服务运行</p>
</li>
<li><p>主从都配置在[mysqld]结点下，都是小写</p>
</li>
<li><p>主机修改my.ini配置文件</p>
<ul>
<li>[必须]主服务器唯一ID<ul>
<li>server-id=1</li>
</ul>
</li>
</ul>
</li>
<li><p>[必须]启用二进制日志</p>
<ul>
<li>log-bin=自己本地的路径/data/mysqlbin<ul>
<li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li>
</ul>
</li>
<li>[可选]启用错误日志<ul>
<li>log-err=自己本地的路径/data/mysqlerr</li>
</ul>
</li>
<li>log-err=D:/devSoft/MySQLServer5.5/data/mys</li>
<li>[可选]根目录</li>
<li>basedir=”自己本地路径”<ul>
<li>basedir=”D:/devSoft/MySQLServer5.5/“</li>
</ul>
</li>
</ul>
</li>
<li><p>[可选]临时目录</p>
<ul>
<li>tmpdir=”自己本地路径”</li>
<li>tmpdir=”D:/devSoft/MySQLServer5.5/“</li>
<li>[可选]数据目录<ul>
<li>datadir=”自己本地路径/Data/“</li>
<li>datadir=”D:/devSoft/MySQLServer5.5/Data/“</li>
</ul>
</li>
</ul>
</li>
<li><p>read-only=0</p>
<ul>
<li>主机，读写都可以</li>
<li>[可选]设置不要复制的数据库</li>
<li>binlog-ignore-db=mysql</li>
<li>[可选]设置需要复制的数据库<ul>
<li>binlog-do-db=需要复制的主数据库名字</li>
</ul>
</li>
</ul>
</li>
<li><p>从机修改my.cnf配置文件</p>
<ul>
<li>[必须]从服务器唯一ID</li>
<li>[可选]启用二进制日志</li>
</ul>
</li>
<li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p>
</li>
<li><p>主机从机都关闭防火墙</p>
<ul>
<li>windows手动关闭</li>
<li>关闭虚拟机linux防火墙 service iptables stop</li>
</ul>
</li>
<li><p>在Windows主机上建立帐户并授权slave</p>
<ul>
<li><p>在主机mysql中执行授权命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.授权</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line"># 2.执行结束后刷新</span><br><span class="line">flush privileges;</span><br><span class="line"># 3.查询主机状态</span><br><span class="line">show master status;</span><br><span class="line"># 4.记录下File和Position的值</span><br><span class="line"># 5.执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在Linux从机上配置需要复制的主机</p>
<ul>
<li><p>在从机mysql中执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;zhangsan&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,MASTER_LOG_POS&#x3D;Position数字;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>启动从服务器复制功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看从机状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>下面两个参数都是Yes，则说明主从配置成功!</p>
<p>Slave_IO_Running: Yes</p>
<p>Slave_SQL_Running: Yes</p>
</li>
</ul>
</li>
<li><p>主机新建库、新建表、insert记录，从机复制</p>
</li>
<li><p>如何停止从服务复制功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意停止后，重新授权需要重新查看主机状态，记录下File和Position的值</p>
</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:1">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">https://www.bilibili.com/video/BV12b411K7Zu?p=179</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:3">↩</a></li>
<li>Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:4">↩</a></li>
<li>Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:5">↩</a></li>
<li>D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:6">↩</a></li>
<li>Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:7">↩</a></li>
<li>MySQL5.1参考手册 - <a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:8">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33033819/article/details/106445880">https://blog.csdn.net/qq_33033819/article/details/106445880</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:9">↩</a></li>
<li>《数据库原理》 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:10">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/" data-id="cknmwaipb0008j4ub23hl6rhj" data-title="MySQL高级" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:29:31.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/JDBC/">JDBC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><strong>JDBC</strong>直接访问数据库</li>
<li><strong>JDO</strong>技术（Java Data Object）</li>
<li>第三方O/R工具，如Hibernate, Mybatis 等</li>
</ul>
<p><strong>JDBC</strong>是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p>
<h3 id="1-1-JDBC介绍"><a href="#1-1-JDBC介绍" class="headerlink" title="1.1 JDBC介绍"></a>1.1 JDBC介绍</h3><blockquote>
<p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p>
</blockquote>
<p><strong>作用</strong>：</p>
<ul>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
</ul>
<p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png" alt="img"></a></p>
<p>而通过JDBC可以如下访问：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png" alt="img"></a></p>
<blockquote>
<p>总结：</p>
<p>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p>
</blockquote>
<h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png" alt="img"></a></p>
<h3 id="1-3-JDBC程序编写步骤"><a href="#1-3-JDBC程序编写步骤" class="headerlink" title="1.3 JDBC程序编写步骤"></a>1.3 JDBC程序编写步骤</h3><ul>
<li>注册驱动</li>
<li>获取连接</li>
<li>执行增删改查</li>
<li>释放资源</li>
</ul>
<h2 id="2-快速使用JDBC"><a href="#2-快速使用JDBC" class="headerlink" title="2. 快速使用JDBC"></a>2. 快速使用JDBC</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar <a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/">MySQL的驱动下载地址</a></li>
<li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li>
<li>右键–&gt;Add As Library</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JDBC快速入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JdbcDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 导入驱动jar包</span><br><span class="line">        &#x2F;&#x2F;2.注册驱动</span><br><span class="line">        &#x2F;&#x2F; Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#x2F;&#x2F;3.获取数据库连接对象</span><br><span class="line">        &#x2F;&#x2F; Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">        Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">        &#x2F;&#x2F;4.定义sql语句</span><br><span class="line">        &#x2F;&#x2F;String sql &#x3D; &quot;update account set balance &#x3D; 2000 where id &#x3D; 1&quot;;</span><br><span class="line">        String sql &#x3D; &quot;update account set balance &#x3D; 2000&quot;;</span><br><span class="line">        &#x2F;&#x2F;5.获取执行sql的对象 Statement</span><br><span class="line">        Statement stmt &#x3D; conn.createStatement();</span><br><span class="line">        &#x2F;&#x2F;6.执行sql</span><br><span class="line">        int count &#x3D; stmt.executeUpdate(sql);</span><br><span class="line">        &#x2F;&#x2F;7.处理结果</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        &#x2F;&#x2F;8.释放资源</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-3-详解各个对象："><a href="#2-3-详解各个对象：" class="headerlink" title="2.3 详解各个对象："></a>2.3 详解各个对象：</h3><h4 id="2-3-1-DriverManager：驱动管理对象"><a href="#2-3-1-DriverManager：驱动管理对象" class="headerlink" title="2.3.1 DriverManager：驱动管理对象"></a>2.3.1 DriverManager：驱动管理对象</h4><ul>
<li><p>功能</p>
<ul>
<li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p>
<p>static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager</p>
<p>写代码使用： Class.forName(“com.mysql.jdbc.Driver”);</p>
<p>通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p>
<p>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  static &#123;</span><br><span class="line">  	try &#123;</span><br><span class="line">  		java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">  	&#125; catch (SQLException E) &#123;</span><br><span class="line">  		throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p>
</li>
<li><p>获取数据库连接：</p>
<ul>
<li><p>方法：static Connection getConnection(String url, String user, String password)</p>
</li>
<li><p>参数：</p>
<p><strong>JDBC URL</strong> 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由协议，子协议，子名称三部分组成，各部分间用冒号分隔。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png" alt="img"></a></p>
<p>参数url：指定连接的路径</p>
<ol>
<li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li>
<li>例子：jdbc:mysql://localhost:3306/db3</li>
<li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li>
</ol>
<p>user：用户名<br>password：密码</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-Connection：数据库连接对象"><a href="#2-3-2-Connection：数据库连接对象" class="headerlink" title="2.3.2 Connection：数据库连接对象"></a>2.3.2 Connection：数据库连接对象</h4><ul>
<li>功能<ul>
<li>获取执行sql 的对象</li>
<li>Statement createStatement()</li>
<li>PreparedStatement prepareStatement(String sql)</li>
</ul>
</li>
<li>管理事务：<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit()</li>
<li>回滚事务：rollback()</li>
</ul>
</li>
</ul>
<h4 id="2-3-3-Statement：执行sql的对象"><a href="#2-3-3-Statement：执行sql的对象" class="headerlink" title="2.3.3 Statement：执行sql的对象"></a>2.3.3 Statement：执行sql的对象</h4><ul>
<li><p>执行sql</p>
<ul>
<li>boolean execute(String sql) ：可以执行任意的sql 了解</li>
<li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li>
<li>ResultSet executeQuery(String sql) ：执行DQL（select)语句</li>
<li>PreparedStatement prepareStatement(String sql)</li>
</ul>
</li>
<li><p>代码: 对account表完成增删改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Statement stmt &#x3D; null;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2. 定义sql(增删改)</span><br><span class="line">            String sql &#x3D; &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;</span><br><span class="line">            &#x2F;&#x2F;String sql  &#x3D; &quot;update account set balance &#x3D; 1500 where id &#x3D; 3&quot;;</span><br><span class="line">            &#x2F;&#x2F;String sql  &#x3D; &quot;delete from account where id &#x3D; 3&quot;;</span><br><span class="line">            &#x2F;&#x2F;3.获取Connection对象</span><br><span class="line">            conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql的对象 Statement</span><br><span class="line">            stmt &#x3D; conn.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            int count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;影响的行数</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            if(count &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;添加成功！&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;添加失败！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;stmt.close();</span><br><span class="line">            &#x2F;&#x2F;7. 释放资源</span><br><span class="line">            &#x2F;&#x2F;避免空指针异常</span><br><span class="line">            if(stmt !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(conn !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit()</li>
<li>回滚事务：rollback()</li>
</ul>
</li>
</ul>
<h4 id="2-3-4-ResultSet：结果集对象-封装查询结果"><a href="#2-3-4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="2.3.4 ResultSet：结果集对象,封装查询结果"></a>2.3.4 ResultSet：结果集对象,封装查询结果</h4><ul>
<li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p>
</li>
<li><p>getXxx(参数):获取数据</p>
<ul>
<li>Xxx：代表数据类型 如： int getInt() , String getString()</li>
<li>参数：<ol>
<li>int：代表列的编号, 从1开始 如: getString(1)</li>
<li>String：代表列名称, 如: getDouble(“balance”)</li>
</ol>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><p>使用步骤：</p>
<ul>
<li>游标向下移动一行</li>
<li>判断是否有数据</li>
<li>获取数据</li>
</ul>
</li>
<li><p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(rs.next())&#123;</span><br><span class="line">	&#x2F;&#x2F;获取数据</span><br><span class="line">	int id &#x3D; rs.getInt(1);</span><br><span class="line">	String name &#x3D; rs.getString(&quot;name&quot;);</span><br><span class="line">	double balance &#x3D; rs.getDouble(3);</span><br><span class="line">	System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);</span><br><span class="line">	&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-3-5-PreparedStatement：执行sql的对象"><a href="#2-3-5-PreparedStatement：执行sql的对象" class="headerlink" title="2.3.5 PreparedStatement：执行sql的对象"></a>2.3.5 PreparedStatement：执行sql的对象</h4><ul>
<li><p>SQL注入问题: 在拼接sql时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题</p>
<ul>
<li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li>
<li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</li>
</ul>
</li>
<li><p>解决sql注入问题：使用PreparedStatement对象来解决</p>
</li>
<li><p>预编译的SQL：参数使用 ? 作为占位符</p>
</li>
<li><p>步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用PreparedStatement实现登录方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean login(String username ,String password)&#123;</span><br><span class="line">    if(username &#x3D;&#x3D; null || password &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;连接数据库判断是否登录成功</span><br><span class="line">    Connection conn &#x3D; null;</span><br><span class="line">    PreparedStatement pstmt &#x3D;  null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;1.获取连接</span><br><span class="line">    try &#123;</span><br><span class="line">        conn &#x3D;  JDBCUtils.getConnection();</span><br><span class="line">        &#x2F;&#x2F;2.定义sql</span><br><span class="line">        String sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ?&quot;;</span><br><span class="line">        &#x2F;&#x2F;3.获取执行sql的对象</span><br><span class="line">        pstmt &#x3D; conn.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;给?赋值</span><br><span class="line">        pstmt.setString(1,username);</span><br><span class="line">        pstmt.setString(2,password);</span><br><span class="line">        &#x2F;&#x2F;4.执行查询,不需要传递sql</span><br><span class="line">        rs &#x3D; pstmt.executeQuery();</span><br><span class="line">        &#x2F;&#x2F;5.判断</span><br><span class="line">        &#x2F;* if(rs.next())&#123;&#x2F;&#x2F;如果有下一行，则返回true</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;*&#x2F;</span><br><span class="line">        return rs.next();&#x2F;&#x2F;如果有下一行，则返回true</span><br><span class="line"></span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        JDBCUtils.close(rs,pstmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p>
<ul>
<li>可以防止SQL注入</li>
<li>效率更高</li>
</ul>
</li>
</ul>
<h3 id="2-4-PreparedStatement-Statement-对比"><a href="#2-4-PreparedStatement-Statement-对比" class="headerlink" title="2.4 PreparedStatement/Statement 对比"></a>2.4 PreparedStatement/Statement 对比</h3><blockquote>
<p><strong>Blob类型的数据</strong> (了解)</p>
<ol>
<li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li>
<li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li>
<li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
</ol>
<p>注意：如果存储的文件过大，数据库的性能会下降</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png" alt="img"></a></p>
<p><strong>两者区别</strong></p>
<ul>
<li>代码的可读性和可维护性. Statement的sql拼接是个难题。</li>
<li>PreparedStatement 可以防止 SQL 注入</li>
<li>PreparedStatement 可以处理Blob类型的数据</li>
<li>PreparedStatement 能最大可能提高性能<ul>
<li>Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高</li>
<li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行</li>
</ul>
</li>
</ul>
<h2 id="3-JDBCUtils-抽取JDBC工具类"><a href="#3-JDBCUtils-抽取JDBC工具类" class="headerlink" title="3. JDBCUtils: 抽取JDBC工具类"></a>3. JDBCUtils: 抽取JDBC工具类</h2><ul>
<li><p>目的：简化书写</p>
</li>
<li><p>分析：</p>
<ol>
<li><p>注册驱动也抽取</p>
</li>
<li><p>抽取一个方法获取连接对象</p>
<ul>
<li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性。</p>
</li>
<li><p>解决：配置文件</p>
<p>jdbc.properties<br>url=<br>user=<br>password=</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>抽取一个方法释放资源</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JDBC工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtils &#123;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String user;</span><br><span class="line">    private static String password;</span><br><span class="line">    private static String driver;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static&#123;</span><br><span class="line">        &#x2F;&#x2F;读取资源文件，获取值。</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 创建Properties集合类。</span><br><span class="line">            Properties pro &#x3D; new Properties();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br><span class="line">            ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();</span><br><span class="line">            URL res  &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;);</span><br><span class="line">            String path &#x3D; res.getPath();</span><br><span class="line">           &#x2F;&#x2F; System.out.println(path);&#x2F;&#x2F;&#x2F;D:&#x2F;IdeaProjects&#x2F;itcast&#x2F;out&#x2F;production&#x2F;day04_jdbc&#x2F;jdbc.properties</span><br><span class="line">            &#x2F;&#x2F;2. 加载文件</span><br><span class="line">           &#x2F;&#x2F; pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br><span class="line">            pro.load(new FileReader(path));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;3. 获取数据，赋值</span><br><span class="line">            url &#x3D; pro.getProperty(&quot;url&quot;);</span><br><span class="line">            user &#x3D; pro.getProperty(&quot;user&quot;);</span><br><span class="line">            password &#x3D; pro.getProperty(&quot;password&quot;);</span><br><span class="line">            driver &#x3D; pro.getProperty(&quot;driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;4. 注册驱动</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接</span><br><span class="line">     * @return 连接对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        return DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     * @param stmt</span><br><span class="line">     * @param conn</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">        if( stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if( conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     * @param stmt</span><br><span class="line">     * @param conn</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;</span><br><span class="line">        if( rs !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="4-JDBC控制事务"><a href="#4-JDBC控制事务" class="headerlink" title="4. JDBC控制事务"></a>4. JDBC控制事务</h2><ol>
<li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
</li>
<li><p>操作：</p>
<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li><p>使用Connection对象来管理事务</p>
<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit()<ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback()<ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 事务操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        PreparedStatement pstmt1 &#x3D; null;</span><br><span class="line">        PreparedStatement pstmt2 &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.获取连接</span><br><span class="line">            conn &#x3D; JDBCUtils.getConnection();</span><br><span class="line">            &#x2F;&#x2F;开启事务</span><br><span class="line">            conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;2.定义sql</span><br><span class="line">            &#x2F;&#x2F;2.1 张三 - 500</span><br><span class="line">            String sql1 &#x3D; &quot;update account set balance &#x3D; balance - ? where id &#x3D; ?&quot;;</span><br><span class="line">            &#x2F;&#x2F;2.2 李四 + 500</span><br><span class="line">            String sql2 &#x3D; &quot;update account set balance &#x3D; balance + ? where id &#x3D; ?&quot;;</span><br><span class="line">            &#x2F;&#x2F;3.获取执行sql对象</span><br><span class="line">            pstmt1 &#x3D; conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 &#x3D; conn.prepareStatement(sql2);</span><br><span class="line">            &#x2F;&#x2F;4. 设置参数</span><br><span class="line">            pstmt1.setDouble(1,500);</span><br><span class="line">            pstmt1.setInt(2,1);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(1,500);</span><br><span class="line">            pstmt2.setInt(2,2);</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            &#x2F;&#x2F; 手动制造异常</span><br><span class="line">            int i &#x3D; 3&#x2F;0;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            &#x2F;&#x2F;提交事务</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;事务回滚</span><br><span class="line">            try &#123;</span><br><span class="line">                if(conn !&#x3D; null) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-批处理"><a href="#5-批处理" class="headerlink" title="5. 批处理"></a>5. 批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p>
<blockquote>
<p>注意:</p>
<ol>
<li>不是所用版本的mysql都支持</li>
<li><strong>JDBC</strong>连接MySQL时，如果要使用批处理功能，请再ur中加参数?rewriteBatchedStatements=true</li>
<li><strong>PreparedStatement</strong>作批处理插入时使用values（使用value没有效果）</li>
</ol>
</blockquote>
<h3 id="5-1-JDBC的批量处理语句包括下面方法："><a href="#5-1-JDBC的批量处理语句包括下面方法：" class="headerlink" title="5.1 JDBC的批量处理语句包括下面方法："></a>5.1 JDBC的批量处理语句包括下面方法：</h3><ul>
<li><strong>addBatch</strong>()：添加需要批量处理的SQL语句或参数</li>
<li><strong>executeBatch</strong>()：执行批量处理语句；</li>
<li><strong>clearBatch</strong>():清空批处理包的语句</li>
</ul>
<h3 id="5-2-批量执行SQL语句的两种情况"><a href="#5-2-批量执行SQL语句的两种情况" class="headerlink" title="5.2 批量执行SQL语句的两种情况"></a>5.2 批量执行SQL语句的两种情况</h3><ul>
<li><p>多条SQL语句的批量处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Statement st &#x3D; conn.createStatement();</span><br><span class="line">st.addBatch(sql1);</span><br><span class="line">st.addBatch(sql2);</span><br><span class="line">...</span><br><span class="line">st.addBatch(sqln);</span><br><span class="line">st.executeBatch();</span><br><span class="line">st.clearBatch();</span><br><span class="line">...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一个SQL语句的批量传参</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PreparedStatement pst &#x3D; conn.prepareStatement(sql);</span><br><span class="line">for(int i &#x3D; 100; i &lt; 1001; i++)&#123;</span><br><span class="line">	pst.setInt(1, i);</span><br><span class="line">	...</span><br><span class="line">	pst.addBatch();</span><br><span class="line">&#125;</span><br><span class="line">pst.executeBatch();</span><br><span class="line">st.clearBatch();</span><br><span class="line">...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-Blob类型数据的读写（了解）"><a href="#6-Blob类型数据的读写（了解）" class="headerlink" title="6. Blob类型数据的读写（了解）"></a>6. Blob类型数据的读写（了解）</h2><ul>
<li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li>
<li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降</li>
</ul>
<p>写入：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png" alt="img"></a></p>
<p>读取：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png" alt="img"></a></p>
<h2 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h2><ol>
<li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p>好处：</p>
<ul>
<li>节约资源</li>
<li>用户访问高效</li>
</ul>
</li>
<li><p>实现：</p>
</li>
</ol>
<ul>
<li><p>标准接口：DataSource javax.sql包下的</p>
<p>方法：</p>
<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ul>
<li>C3P0：数据库连接池技术</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li>
</ul>
</li>
</ul>
<ol>
<li>C3P0：数据库连接池技术</li>
</ol>
<ul>
<li>步骤：</li>
</ul>
<ol>
<li>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，<ul>
<li>不要忘记导入数据库驱动jar包</li>
</ul>
</li>
<li>定义配置文件：<ul>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ul>
</li>
<li>创建核心对象 数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接： getConnection</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * c3p0的演示</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class C3P0Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建数据库连接池对象</span><br><span class="line">        DataSource ds  &#x3D; new ComboPooledDataSource();</span><br><span class="line">        &#x2F;&#x2F;2. 获取连接对象</span><br><span class="line">        Connection conn &#x3D; ds.getConnection();</span><br><span class="line">        &#x2F;&#x2F;3. 打印</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<ol>
<li>步骤：<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * Druid演示</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public class DruidDemo &#123;</span><br><span class="line">      public static void main(String[] args) throws Exception &#123;</span><br><span class="line">          &#x2F;&#x2F;1.导入jar包</span><br><span class="line">        &#x2F;&#x2F;2.定义配置文件</span><br><span class="line">        &#x2F;&#x2F;3.加载配置文件</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        &#x2F;&#x2F;4.获取连接池对象</span><br><span class="line">        DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#x2F;&#x2F;5.获取连接</span><br><span class="line">        Connection conn &#x3D; ds.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>定义工具类</p>
<ol>
<li><p>定义一个类 JDBCUtils</p>
</li>
<li><p>提供静态代码块加载配置文件，初始化连接池对象</p>
</li>
<li><p>提供方法</p>
<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池的方法</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Druid连接池的工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtils &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.定义成员变量 DataSource</span><br><span class="line">    private static DataSource ds ;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.加载配置文件</span><br><span class="line">            Properties pro &#x3D; new Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">            &#x2F;&#x2F;2.获取DataSource</span><br><span class="line">            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">        return ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">       close(null,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;</span><br><span class="line">        if(rs !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();&#x2F;&#x2F;归还连接</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接池方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static DataSource getDataSource()&#123;</span><br><span class="line">        return  ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）"><a href="#8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）" class="headerlink" title="8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）"></a>8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）</h2><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li><p>update():执行DML语句。增、删、改语句</p>
</li>
<li><p>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p>
<p>注意：这个方法查询的结果集长度只能是1</p>
</li>
<li><p>queryForList():查询结果将结果集封装为list集合</p>
<p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p>
</li>
<li><p>query():查询结果，将结果封装为JavaBean对象</p>
</li>
<li><p>query的参数：RowMapper</p>
</li>
</ul>
</li>
<li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p>
</li>
<li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p>
<ul>
<li><p>queryForObject：查询结果，将结果封装为对象</p>
<p>一般用于聚合函数的查询</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jdbctemplate;</span><br><span class="line">import cn.itcast.utils.JDBCUtils;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * JdbcTemplate入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JdbcTemplateDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.导入jar包</span><br><span class="line">        &#x2F;&#x2F;2.创建JDBCTemplate对象</span><br><span class="line">        JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">        &#x2F;&#x2F;3.调用方法</span><br><span class="line">        String sql &#x3D; &quot;update account set balance &#x3D; 5000 where id &#x3D; ?&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 3);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jdbctemplate;</span><br><span class="line"></span><br><span class="line">import cn.itcast.domain.Emp;</span><br><span class="line">import cn.itcast.utils.JDBCUtils;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">import java.sql.Date;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JdbcTemplateDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Junit单元测试，可以让方法独立执行</span><br><span class="line">    &#x2F;&#x2F;1. 获取JDBCTemplate对象</span><br><span class="line">    private JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2. 定义sql</span><br><span class="line">        String sql &#x3D; &quot;update emp set salary &#x3D; 10000 where id &#x3D; 1001&quot;;</span><br><span class="line">        &#x2F;&#x2F;3. 执行sql</span><br><span class="line">        int count &#x3D; template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 2. 添加一条记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        String sql &#x3D; &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 1015, &quot;郭靖&quot;, 10);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3.删除刚才添加的记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        String sql &#x3D; &quot;delete from emp where id &#x3D; ?&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 1015);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="line">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp where id &#x3D; ? or id &#x3D; ?&quot;;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; template.queryForMap(sql, 1001,1002);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        &#x2F;&#x2F;&#123;id&#x3D;1001, ename&#x3D;孙悟空, job_id&#x3D;4, mgr&#x3D;1004, joindate&#x3D;2000-12-17, salary&#x3D;10000.00, bonus&#x3D;null, dept_id&#x3D;20&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 5. 查询所有记录，将其封装为List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list &#x3D; template.query(sql, new RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;</span><br><span class="line">                Emp emp &#x3D; new Emp();</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);</span><br><span class="line">                String ename &#x3D; rs.getString(&quot;ename&quot;);</span><br><span class="line">                int job_id &#x3D; rs.getInt(&quot;job_id&quot;);</span><br><span class="line">                int mgr &#x3D; rs.getInt(&quot;mgr&quot;);</span><br><span class="line">                Date joindate &#x3D; rs.getDate(&quot;joindate&quot;);</span><br><span class="line">                double salary &#x3D; rs.getDouble(&quot;salary&quot;);</span><br><span class="line">                double bonus &#x3D; rs.getDouble(&quot;bonus&quot;);</span><br><span class="line">                int dept_id &#x3D; rs.getInt(&quot;dept_id&quot;);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                return emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6_2()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list &#x3D; template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 7. 查询总记录数</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test7()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select count(id) from emp&quot;;</span><br><span class="line">        Long total &#x3D; template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>表与JavaBean的关系</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png" alt="img"></a></p>
</li>
</ul>
<h2 id="9-DAO层"><a href="#9-DAO层" class="headerlink" title="9. DAO层"></a>9. DAO层</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/JDBC/" data-id="cknmwaip40001j4ub03xt4214" data-title="JDBC" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/">juc学习</a>
          </li>
        
          <li>
            <a href="/2021/04/07/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">redis集群与企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/">redis高级</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>