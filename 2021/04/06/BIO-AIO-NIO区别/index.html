<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>BIO_AIO_NIO区别 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="BIO_AIO_NIO区别 简单对比：  BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。 NIO 是 Java 1.4 引入的 java.nio 包，提供了">
<meta property="og:type" content="article">
<meta property="og:title" content="BIO_AIO_NIO区别">
<meta property="og:url" content="http://example.com/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="BIO_AIO_NIO区别 简单对比：  BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。 NIO 是 Java 1.4 引入的 java.nio 包，提供了">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png">
<meta property="article:published_time" content="2021-04-06T11:32:28.000Z">
<meta property="article:modified_time" content="2021-04-06T11:32:54.474Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-BIO-AIO-NIO区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:32:28.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      BIO_AIO_NIO区别
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote>
<p>简单对比：</p>
<ul>
<li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p>
<p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p>
<p>比如下面的一些理解（我认为是不对的）：</p>
<blockquote>
<p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p>
<p><del>在网络请求中，客户端会发出一个请求到服务端</del></p>
<ol>
<li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li>
<li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li>
<li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li>
<li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li>
</ol>
</blockquote>
<p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p>
<ul>
<li>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</li>
<li>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</li>
</ul>
<p>本文的讨论：</p>
<ul>
<li>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:2">2]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:4">4]</a></li>
<li>讨论Java中对应的编程模型</li>
<li>对比BIO/NIO的区别[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:3">3]</a></li>
</ul>
<h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1. Linux下的五种I/O模型"></a>1. Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li>blocking IO</li>
<li>nonblocking IO</li>
<li>IO multiplexing</li>
<li>signal driven IO</li>
<li>asynchronous IO</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<blockquote>
<p>IO发生时涉及的对象和步骤:</p>
<ul>
<li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul>
<li>一个是调用这个IO的process (or thread)</li>
<li>另一个就是系统内核(kernel)</li>
</ul>
</li>
<li>当一个read操作发生时，它会经历两个阶段：<br>1 等待数据准备 (Waiting for the data to be ready)<br>2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
<li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li>
</ul>
</blockquote>
<h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
</li>
</ul>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BIO阻塞代码</span><br><span class="line">public class ServerTcpSocket &#123;</span><br><span class="line">    static byte[] bytes &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocket连接</span><br><span class="line">            final ServerSocket serverSocket &#x3D; new ServerSocket();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 3.当前线程放弃cpu资源等待获取数据</span><br><span class="line">            System.out.println(&quot;等待获取数据...&quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                final Socket socket &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">                executorService.execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;获取到数据...&quot;);</span><br><span class="line">                            &#x2F;&#x2F; 4.读取数据</span><br><span class="line">                            int read &#x3D; socket.getInputStream().read(bytes); &#x2F;&#x2F; 会阻塞</span><br><span class="line">                            String result &#x3D; new String(bytes);</span><br><span class="line">                            System.out.println(result);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p>
<h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
</li>
</ul>
<p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p>
<p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NIO非阻塞式代码</span><br><span class="line">public class ServerNioTcpSocket &#123;</span><br><span class="line">    static ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(512);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocketChannel连接</span><br><span class="line">            final ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocketChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 设置为非阻塞式</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 非阻塞式</span><br><span class="line">            SocketChannel socketChannel &#x3D; serverSocketChannel.accept(); </span><br><span class="line">            if (socketChannel !&#x3D; null) &#123;</span><br><span class="line">                int j &#x3D; socketChannel.read(byteBuffer);  &#x2F;&#x2F; 此处不会阻塞</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    byte[] bytes &#x3D; Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());</span><br><span class="line">                    System.out.println(&quot;获取到数据&quot; + new String(bytes));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;程序执行完毕..&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p>
<p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p>
<p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p>
<h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p>
<p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png" alt="img"></a></p>
<p>这里用java的NIO示意select</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<blockquote>
<p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</blockquote>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png" alt="img"></a></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p>
<p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p>
<h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p>
<ol>
<li>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</li>
<li>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</li>
</ol>
<blockquote>
<p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png" alt="img"></a></p>
<p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p>
<p>Unix，Linux操作系统的一些基本知识：</p>
<ul>
<li>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</li>
<li>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</li>
</ul>
<blockquote>
<p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p>
<p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p>
<p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select（1984）</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll（1997）</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll（2002）</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>Java NIO当中是使用哪一种机制？</p>
<p>基于内核版本，可以查看DefaultSelectorProvider源码：</p>
<ul>
<li>windows下，WindowsSelectorProvider。</li>
<li>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</li>
</ul>
<h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote>
<p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p>
<p>编程模型最简单。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复习黑马文件上传的服务端BIO代码</span><br><span class="line">public class FileUpload_Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;服务器 启动..... &quot;);</span><br><span class="line">        &#x2F;&#x2F; 1. 创建服务端ServerSocket</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket(6666);</span><br><span class="line">        &#x2F;&#x2F; 2. 循环接收,建立连接</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket accept &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">            &#x2F;*</span><br><span class="line">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="line">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="line">            *&#x2F;</span><br><span class="line">            new Thread(() ‐&gt; &#123;</span><br><span class="line">                try (</span><br><span class="line">                    &#x2F;&#x2F;3.1 获取输入流对象</span><br><span class="line">                    BufferedInputStream bis &#x3D; new BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    &#x2F;&#x2F;3.2 创建输出流对象, 保存到本地 .</span><br><span class="line">                    FileOutputStream fis &#x3D; new FileOutputStream(System.currentTimeMillis() +</span><br><span class="line">                    &quot;.jpg&quot;);</span><br><span class="line">                    BufferedOutputStream bos &#x3D; new BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3.3 读写数据</span><br><span class="line">                    byte[] b &#x3D; new byte[1024 * 8];</span><br><span class="line">                    int len;</span><br><span class="line">                    while ((len &#x3D; bis.read(b)) !&#x3D; ‐1) &#123;</span><br><span class="line">                        bos.write(b, 0, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;4. 关闭 资源</span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(&quot;文件上传已保存&quot;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p>
<p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p>
<blockquote>
<p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p>
<p>编程模型最复杂。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<p>NIO非阻塞体现:</p>
<ul>
<li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li>
<li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li>
</ul>
<p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p>
<p>编程模型比较简单，但需要操作系统来支持异步服务。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码(了解)</span><br><span class="line">public class AIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        final AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open().bind(new InewSocketAddress(9000));</span><br><span class="line">        </span><br><span class="line">        serverChannel.accept(null, new CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousServerSocketChannel socketChannel, Object attachment)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    &#x2F;&#x2F; 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br><span class="line">                    serverChannel.accept(attachment, this);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                    socketChannel.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void completed(Integer result, ByteBuffer buffer)&#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(new String(buffer.array(), 0, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        @Override</span><br><span class="line">                        public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png" alt="img"></a></p>
<h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote>
<p>NIO重点:</p>
<p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="img"></a></p>
<blockquote>
<p>简单解释：</p>
</blockquote>
<ul>
<li>每一个channel对应一个buffer缓冲区。</li>
<li>channel会注册到selector。</li>
<li>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</li>
<li>selector对应一个或者多个线程。</li>
<li>buffer和channel都是可读可写的。</li>
</ul>
<h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p>
<p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p>
<p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p>
<p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p>
<ul>
<li>ByteBuffer：字节缓冲区</li>
<li>CharBuffer:字符缓冲区</li>
<li>ShortBuffer：短整型缓冲区</li>
<li>IntBuffer：整型缓冲区</li>
<li>LongBuffer:长整型缓冲区</li>
<li>FloatBuffer：浮点型缓冲区</li>
<li>DoubleBuffer：双精度浮点型缓冲区</li>
</ul>
<h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p>
<p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p>
<p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p>
<p>Channel有四种实现：</p>
<ul>
<li>FileChannel:是从文件中读取数据。</li>
<li>DatagramChannel:从UDP网络中读取或者写入数据。</li>
<li>SocketChannel:从TCP网络中读取或者写入数据。</li>
<li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li>
</ul>
<h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<p><strong>关键对象</strong></p>
<ul>
<li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li>
<li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li>
</ul>
<p><strong>监听注册</strong></p>
<p>监听注册在Selector</p>
<blockquote>
<p>socketChannel.register(selector, SelectionKey.OP_READ);</p>
</blockquote>
<p><strong>监听的事件有</strong></p>
<ul>
<li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li>
<li>OP_READ: 读取就绪，socketChannel使用</li>
<li>OP_WRITE: 写入就绪，socketChannel使用</li>
<li>OP_CONNECT: 连接就绪，socketChannel使用</li>
</ul>
<h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:1">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:3">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:4">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" data-id="cknmwaip80005j4ubhwrqb91f" data-title="BIO_AIO_NIO区别" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          计算机网络总结
        
      </div>
    </a>
  
  
    <a href="/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">MySQL高级</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/">juc学习</a>
          </li>
        
          <li>
            <a href="/2021/04/07/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">redis集群与企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/">redis高级</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>