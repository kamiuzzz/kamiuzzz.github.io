<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机网络总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="计算机网络总结本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结[1][2]以及少量的补充 1. OSI与TCP&#x2F;IP各层的结构与功能,都有哪些协议? 1.1 应用层1.1.1 应用层 应用层：直接为用户的应用进程提供网络服务。  应用层协议： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络总结">
<meta property="og:url" content="http://example.com/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="计算机网络总结本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结[1][2]以及少量的补充 1. OSI与TCP&#x2F;IP各层的结构与功能,都有哪些协议? 1.1 应用层1.1.1 应用层 应用层：直接为用户的应用进程提供网络服务。  应用层协议： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png">
<meta property="article:published_time" content="2021-04-06T11:33:18.000Z">
<meta property="article:modified_time" content="2021-04-06T11:33:53.282Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机网络总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:33:18.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机网络总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><p>本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:2">2]</a>以及少量的补充</p>
<h2 id="1-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1. OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1. OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png" alt="img"></a></p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><blockquote>
<p><strong>应用层</strong>：直接为用户的应用进程提供网络服务。</p>
</blockquote>
<p><strong>应用层协议</strong>： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候像应用层协议就可以规定这些数据的格式要满足什么形式。</p>
<p>在互联网中应用层协议很多，如</p>
<ul>
<li>域名系统<strong>DNS</strong></li>
</ul>
<blockquote>
<p>域名系统DNS：</p>
<p>是因特网的一项核心服务，他作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，不用去记住能够背极其直接读取的IP数串。</p>
</blockquote>
<ul>
<li>支持万维网应用的 <strong>HTTP</strong>协议</li>
</ul>
<blockquote>
<p>HTTP协议:</p>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<ul>
<li>支持电子邮件的 <strong>SMTP</strong>协议</li>
<li>文件传输 <strong>FTP</strong>等等</li>
</ul>
<p>我们把应用层交互的数据单元称为报文。</p>
<h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><blockquote>
<p><strong>表示层</strong>：在满足用户需求的基础上，尽可能的节省传输费用而设置的，表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p>
</blockquote>
<p>表示层的<strong>数据转换</strong>包括:</p>
<ul>
<li>数据加密</li>
<li>数据压缩</li>
<li>数据格式转换等。</li>
</ul>
<p>比如传输压缩文件，jpeg或者加密文件等格式。</p>
<h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><blockquote>
<p>会话层：<strong>管理</strong>主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话。</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><blockquote>
<p><strong>运输层</strong>：为应用进程之间提供端到端的逻辑通讯。</p>
</blockquote>
<h4 id="1-2-1-运输层协议⭐"><a href="#1-2-1-运输层协议⭐" class="headerlink" title="1.2.1 运输层协议⭐"></a>1.2.1 运输层协议⭐</h4><p><strong>运输层协议</strong>: IP协议是<strong>主机之间</strong>的通信，TCP和UDP是进程之间的通信。</p>
<ul>
<li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）</p>
<p>提供面向连接的，可靠的数据传输服务</p>
<ul>
<li>客户端和服务器之间要保持一个会话直到传输结束</li>
<li>分段传输建立会话可靠传输流量控制（发送窗口大小根据接收窗口大小确定）</li>
<li>流量控制、拥塞控制，全双工</li>
<li>每一条TCP连接有两个端点（套接字：IP+端口号）</li>
</ul>
</li>
<li><p>用户数据协议 <strong>UDP</strong>（User Datagram Protocol）</p>
<p>提供无连接的，尽最大努力的数据传输服务</p>
<ul>
<li>不保证数据传输的可靠性</li>
<li>不分段</li>
<li>支持一对一，一对多，多对一通信</li>
</ul>
</li>
<li><p>TCP和UDP对比[见问题三](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/3.TCP/UDP">http://lihengxu.cn/2021/03/23/计网/3.TCP/UDP</a> 协议的区别⭐)</p>
</li>
</ul>
<h4 id="1-2-2-本层加端口号"><a href="#1-2-2-本层加端口号" class="headerlink" title="1.2.2 本层加端口号"></a>1.2.2 本层加端口号</h4><p>常见端口：</p>
<ul>
<li>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制；</li>
<li>Telnet（远程登录协议）：23；</li>
<li>DNS（域名解析服务）：53；</li>
<li>TFTP（简单文件传输协议）：69；</li>
<li>HTTP（超文本传输协议）：80</li>
</ul>
<h4 id="1-2-3-传输层进行差错检测"><a href="#1-2-3-传输层进行差错检测" class="headerlink" title="1.2.3 传输层进行差错检测"></a>1.2.3 传输层进行差错检测</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png" alt="img"></a></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><blockquote>
<p><strong>网络层</strong>（网际层/IP层）：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。(<strong>路径选择、路由及逻辑寻址</strong>)</p>
</blockquote>
<ul>
<li><p><strong>协议</strong>：ARP IP ICMP IGMP(ARP为IP提供服务，IP为ICMP和IGMP提供服务）</p>
<ul>
<li>由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 IP 数据报 ，简称<strong>数据报</strong></li>
<li>无论是哪一层的数据单元都可以笼统的用”分组“表示，主要不要混淆”用户数据包UDP“和网络层的”IP数据报“</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png" alt="img"></a></p>
</li>
<li><p><strong>特点</strong>：网络层不管发的顺序也不管丢数据不（对方传输层负责），根据目标地址选择合适路径转发。</p>
</li>
<li><p><strong>本层加源IP地址与目标IP地址，构成IP数据报。</strong> <strong>IP协议非常简单，仅仅提供不可靠、无连接的传送服务</strong>。 IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p>
</li>
<li><p><strong>路由器工作在网络层</strong>，在不同网段转发数据。</p>
</li>
</ul>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><blockquote>
<p>数据链路层：数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
</blockquote>
<ul>
<li>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <strong>IP 数据报组装成帧</strong>，进行传送。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。</li>
<li>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。</li>
<li>封装成帧（帧头、帧尾、物理地址、校验值） 透明传输（字节填充法，传输数据出现控制字符前面插入一个转义字符） 差错校验（循环冗余检验CRC）</li>
</ul>
<blockquote>
<p><strong>数据链路层协议</strong>(了解)：</p>
</blockquote>
<ul>
<li>PPP（点到点信道） （拨号电话线接入因特网就是PPP）</li>
<li>CSMA/CD(带冲突检测的载波监听多路访问协议）（使用广播信道）（局域网）</li>
<li>多路访问：多个设备可以同时访问介质（多个设备在同一信道发送信号协议），一个设备发送的帧也可以被多个设备接收。</li>
<li>载波监听：每一个设备发送数据前，对信道侦听，空闲才可以发送，如果有其他设备正在发暂时不发避免碰撞。</li>
<li>碰撞检测：设备边发数据边检测信道上电压大小，一旦出现碰撞，立即停止发送，等待一段时间后再发。 这个协议只能<strong>半双工</strong>通信。</li>
</ul>
<blockquote>
<p><strong>以太网</strong>（ 全球使用最广泛的局域网技术）拓扑结构为总线型</p>
</blockquote>
<p>以太网的标准<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91">拓扑</a>结构为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91">总线型拓扑</a>，但目前的快速以太网为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CSMA%2FCD">CSMA/CD</a>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png" alt="img"></a></p>
<blockquote>
<p>网桥交换机：网桥设备（可以连接集线器）</p>
</blockquote>
<p>网桥既有过滤帧的功能。当网桥收到一个帧的时候，并不是像所有接口发此帧，而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口。</p>
<ul>
<li>网桥口越来越多了就变成了交换机（直接连计算机）</li>
<li>交换机前身为网桥</li>
<li>交换机口可以存储转发，基于MAC地址转发，通过学习构建MAC地址表</li>
</ul>
<p><strong>本层加MAC地址</strong></p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><blockquote>
<p>物理层：实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p>
</blockquote>
<ul>
<li>在物理层上传送比特流</li>
<li>频分复用，时分复用</li>
</ul>
<blockquote>
<p>集线器：多接口转发器，工作在物理层</p>
</blockquote>
<h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>发送端：</p>
<ul>
<li><p>应用程序准备传输的文件</p>
</li>
<li><p>传输层 将文件分段 并编号</p>
</li>
<li><p>网络层 添加目标IP地址源IP地址</p>
</li>
<li><p>数据链路层 两种情况</p>
<p>使用自己的子网掩码 判断自己在那个网段</p>
<p>使用自己的子网掩码 判断目标地址在哪个网段</p>
<ul>
<li>如果是同一个网段 arp协议广播解析目标IP地址的MAC</li>
<li>如果不是同一个网段 则mac写网关地址</li>
</ul>
</li>
</ul>
<hr>
<p>一些帮助理解的解释：</p>
<ul>
<li><p>ARP发送的广播包，目标MAC是全1（48位），交换机会给所有出口转发。得到MAC地址后会缓存，过一段时间不和目标地址通信了，这个缓存会删除掉。</p>
</li>
<li><p>交换机根据mac地址转发数据</p>
</li>
<li><p>每个计算机配有网关（知道自己所在子网的路由网口地址）</p>
</li>
<li><p>点到点信道，物理层地址固定为FF（因为只能这个传给对方，不用看地址）</p>
</li>
<li><p>IP地址决定了数据的起点与终点，MAC地址决定了本点和下一跳给谁</p>
</li>
<li><p>集线器：</p>
<p>只负责把比特流传出去，并对信号进行加强，属于物理层设备（与网线差不多，只认比特流）</p>
</li>
<li><p>交换机（一个网段内转给其他计算机还是路由器）：</p>
<p>收完比特流，存储，看目标mac地址，选择出口，工作在第二层数据链路层设备，存储转发（只能看懂mac地址看不懂IP地址）</p>
</li>
<li><p>路由器：</p>
<p>有网卡（接口）接收比特流，可以看懂mac，判断是不是给自己，然后会把mac地址去掉，剩下IP数据报，根据数据报的目标地址按照路由表选择出口（路由器看不懂具体传的数据），出口写上新的MAC地址，为三层设备网络设备</p>
<p>路由器–网关–交换机三层结构：</p>
<p>知道IP地址，想知道具体是哪个物理PC机</p>
<ul>
<li>首先要通过IP地址的网段查找到是哪个网关的</li>
<li>然后在网关ARP表中查找mac地址和交换机位置</li>
<li>然后通过MAC表查找到物理PC机。</li>
<li>即IP地址-网关-MAC地址-交换机-port-PC机</li>
</ul>
<blockquote>
<p><strong>mac表</strong>：记录交换机接口（端口）和终端MAC的对应关系，即说明交换机哪个端口和终端的哪个MAC地址对应，指的是物理层面的连接关系，存在于交换机当中。</p>
<p><strong>ARP缓存表</strong>：记录主机的IP地址和MAC地址的对应关系，对于同一台PC机，IP地址是可变的，但是MAC地址是物理网卡的地址，是网卡特有的信息，是不可变的。这个缓存表一般不存在交换机里面，而是在交换机上一层的仪器中，即网关中。这个表里面只能知道IP地址和MAC的对应关系，以及在哪个交换机上连接着，并不能知道在交换机的哪个端口，需要和mac表相结合才能知道。</p>
<p><strong>路由表</strong>：记录路由器掌握的所有目的地网段，以及到达这些目的的最佳路径</p>
</blockquote>
</li>
<li><p>工作在哪一层指的最高能看懂那一层的内容</p>
</li>
<li><p>对方物理层收到比特流后，数据链路层看目标mac地址是给自己的，然后到网络层去掉mac地址剩下IP数据报，然后数据报把IP地址去掉（IP地址）给传输层，传输层排序检查丢包后给应用层</p>
</li>
</ul>
<hr>
<p>病毒是一个代码，也会分段传，路由器只能看到每一段所以中不了病毒，交换机以及集线器也不会</p>
<h3 id="1-7-TCP-IP协议有了解吗？"><a href="#1-7-TCP-IP协议有了解吗？" class="headerlink" title="1.7 TCP/IP协议有了解吗？"></a>1.7 TCP/IP协议有了解吗？</h3><p>TCP/IP 协议不是TCP 和IP 这两个协议的合称，而是指因特网整个TCP/IP 协议族，是一系列网络协议的总称。</p>
<p>TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为</p>
<ul>
<li><strong>应用层</strong></li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong></li>
<li><strong>链路层</strong></li>
</ul>
<h2 id="2-TCP-三次握手和四次挥手⭐"><a href="#2-TCP-三次握手和四次挥手⭐" class="headerlink" title="2. TCP 三次握手和四次挥手⭐"></a>2. TCP 三次握手和四次挥手⭐</h2><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p>
<h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><ul>
<li>第一次握手：主机A 发送syn＝1,随机产生seq=x(如1234567) 的数据包到服务器，主机B由SYN=1 知道，A 要求建立联机；</li>
<li>第二次握手： 主机B 收到请求后要确认联机信息， 向A 发送ack=( 主机A 的seq+1),syn=1,ack=1,随机产生seq=y(如7654321） 的包</li>
<li>第三次握手：主机A 收到后检查ack是否正确，即第一次发送的seq +1,以及位码ACK是否为1，若正确，主机A 会再发送ack =(主机B 的seq+1),ACK=1，主机B 收到后确认</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png" alt="img"></a></p>
<p><strong>序列号</strong>：TCP缓存中字节流分数据段发，序号是这个数据段的第一个字节是整个文件的第几个字节（ 如果传输的数据字节为0，即只有首部，那序列号还增加吗？当syn 或 fin被置1，虽然报文里长度为0（应用层的数据叫报文），计算ack时我们可以认为其长度为1。其他情况（如只有ack）不增加）</p>
<p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的<strong>握手信号</strong>。</p>
<p><strong>确认号ack</strong>：根据收到的数据包的最后一个字节，给信号说下一个该发哪个字节了，这个确认号就是下一个该发得字节号</p>
<p><strong>ACK</strong>：0确认号无效，1确认号有效</p>
<blockquote>
<p>状态变化:</p>
<ul>
<li>客户端: Close-&gt;SYN_SENT-&gt;ESTABLISHED</li>
<li>服务端: Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED</li>
</ul>
</blockquote>
<h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收是正常的。 <strong>核心思想</strong>：<strong>让双方都证实对方能发收</strong>。</p>
<ul>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-两次握手可以么？"><a href="#2-3-两次握手可以么？" class="headerlink" title="2.3 两次握手可以么？"></a>2.3 两次握手可以么？</h3><p>不可以</p>
<blockquote>
<p>假如只有前面两次握手，那么服务器在接收到第一次握手信号，发出第二次握手信号后就会开始工作。</p>
</blockquote>
<ol>
<li>服务器角度：可能客户端发送的第一次握手请求传输过程中阻塞，客户端会再次发送一个请求，这个时候服务器先后接收到两次请求，并持续等两个客户端请求发送数据，其实只有一个，服务端却有两个响应，极端情况可能N个，会造成资源浪费。</li>
<li>客户端角度：假如发送建立连接的请求阻塞，过了一段时间发现没回复，然后再发一个（这次很快到达），然后给确认也很快， 就开始发数据。过了一会第一个阻塞的建立连接的请求也到了，再给一个确认给A，结果A不认了，刚已经收到确认了，就不理了，然后B就得等着传数据（没收到数据过一段就释放了），会造成资源浪费，所以需要第三个数据包的确认</li>
</ol>
<h3 id="2-4-第2次握手传回了ACK，为什么还要传回SYN？"><a href="#2-4-第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="2.4 第2次握手传回了ACK，为什么还要传回SYN？"></a>2.4 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。</p>
<p>而回传SYN则是为了建立并确认从服务端到客户端的通信，还要客户端确认我的发送是否正常（SYN=1了ack才为seq+1）。</p>
<h3 id="2-5-四次挥手"><a href="#2-5-四次挥手" class="headerlink" title="2.5 四次挥手"></a>2.5 四次挥手</h3><ul>
<li>第一次：主机A 请求断开连接 发送FIN=1 seq=u后，进入终止等待状态1，</li>
<li>第二次： 服务端对客户端的请求应答：ACK=1,ack=u+1,seq=v，然后服务器B 就进入关闭等待状态，此时TCP 服务器进程就通知高层应用进程，因而从A 到B 的连接就释放了。此时是“半关闭”状态。即A 不可以发送给B，但是B 可以发送给A。</li>
<li>第三次：此时，若B 没有数据报要发送给A 了，其应用进程就通知TCP 释放连接， 服务端请求断开连接：FIN=1，ACK=1,seq=w,ack=u+1，并等待确认。</li>
<li>第四次： 客户端对服务端的请求应答： ACK=1，seq=u+1，ack=w+1，A 进入时间等待，注意，此时TCP 连接还没有释放掉，然后经过时间等待计时器设置的2MSL 后，A 才进入到关闭状态。</li>
</ul>
<p>（FIN：finish）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png" alt="img"></a></p>
<blockquote>
<p>状态变化：</p>
<p>客户端：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p>
<p>服务端：ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p>
</blockquote>
<h3 id="2-7-为什么要四次挥手？"><a href="#2-7-为什么要四次挥手？" class="headerlink" title="2.7 为什么要四次挥手？"></a>2.7 为什么要四次挥手？</h3><p>我们可以看出服务端响应断开连接的请求时，其<strong>ACK和FIN包并不是一起发送给客户端的</strong>，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h3 id="2-8-四次挥手主动方为什么需要等待2MSL"><a href="#2-8-四次挥手主动方为什么需要等待2MSL" class="headerlink" title="2.8 四次挥手主动方为什么需要等待2MSL?"></a>2.8 四次挥手主动方为什么需要等待2MSL?</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p>
<blockquote>
<p>MSL（Maximum Segment Lifetime）：</p>
<p>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。（ 去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)=2MSL）</p>
</blockquote>
<p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了， 主动关闭方需要等待2MSL是为了，<strong>防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号</strong>。（若重发的又没到，客户端就关闭了，server最后就会异常关闭连接，把链接错误问题报告给高层）</p>
<h3 id="2-9-已经建立连接，但客户端故障怎么办？"><a href="#2-9-已经建立连接，但客户端故障怎么办？" class="headerlink" title="2.9 已经建立连接，但客户端故障怎么办？"></a>2.9 已经建立连接，但客户端故障怎么办？</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p>
<p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是<strong>设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75</strong>秒发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="3-TCP-UDP-协议的区别⭐"><a href="#3-TCP-UDP-协议的区别⭐" class="headerlink" title="3.TCP/UDP 协议的区别⭐"></a>3.TCP/UDP 协议的区别⭐</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png" alt="img"></a></p>
<ul>
<li>TCP协议进行数据通信之前需要<strong>三次握手建立连接</strong>，UDP协议不需要建立连接即可发送数据。</li>
<li>TCP有<strong>确认</strong>机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。<strong>传输可靠性</strong>区别</li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li>
</ul>
<blockquote>
<p>UDP（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播、屏幕广播、DNS、多播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
</blockquote>
<h3 id="3-1-一个网络数据包包括哪些有了解吗？"><a href="#3-1-一个网络数据包包括哪些有了解吗？" class="headerlink" title="3.1 一个网络数据包包括哪些有了解吗？"></a>3.1 一个网络数据包包括哪些有了解吗？</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部（链路层）；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png" alt="img"></a></p>
<h3 id="3-2-每一层的数据叫什么名字？"><a href="#3-2-每一层的数据叫什么名字？" class="headerlink" title="3.2 每一层的数据叫什么名字？"></a>3.2 每一层的数据叫什么名字？</h3><p>我们把应用层交互的数据单元称为报文</p>
<p>传输层：TCP叫报文段，UDP叫用户数据报</p>
<p>网络层：把运输层的报文段或者用户数据报封装成分组或者包，也叫IP数据报（数据报）</p>
<p>链路层：帧</p>
<p>物理层：比特流</p>
<h3 id="3-3-TCP协议中的数据包分片与重组功能有了解吗？"><a href="#3-3-TCP协议中的数据包分片与重组功能有了解吗？" class="headerlink" title="3.3 TCP协议中的数据包分片与重组功能有了解吗？"></a>3.3 TCP协议中的数据包分片与重组功能有了解吗？</h3><p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。</p>
<ul>
<li><p>发送方：</p>
<p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p>
</li>
<li><p>接收方：</p>
<p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p>
</li>
</ul>
<blockquote>
<p>链路层MTU(Maximum Transmission Unit)：每一种物理网络都会规定链路层数据帧的最大长度。IP协议在传输数据包时，若IP数据报加上数据帧头部后长度大于MTU，则将数据报文分为若干分片进行传输，并在目标系统中进行重组。</p>
</blockquote>
<blockquote>
<p>MSS：是TCP数据包每次能够传输的最大报文分段。</p>
</blockquote>
<h3 id="3-4-TCP粘包"><a href="#3-4-TCP粘包" class="headerlink" title="3.4 TCP粘包"></a>3.4 TCP粘包</h3><p>TCP粘包是指一种发送方发送的数据包在接收方的缓冲区中粘成了一包，也就是出现了数据包首尾相接的现象。</p>
<ul>
<li>产生原因：主要是发送方使用了Nagle算法，或者接收方的处理速度小于数据包的接收速度，导致接收缓冲区中消息堆积。</li>
<li>解决方法：可以通过关闭Nagle算法或者规定每个数据包的具体格式和长度，在接收方的应用层来进行判断</li>
</ul>
<p>还有UDP是不会产生粘包现象的，因为数据包之间具有明确的消息保护边界。</p>
<h2 id="4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）"><a href="#4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）" class="headerlink" title="4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）"></a>4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）</h2><ul>
<li><p><strong>确认</strong>：</p>
<p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储哪些已发送但是未收到确认的报文段，以便重传。</p>
<p>TCP默认使用<strong>累计确认</strong>，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序</strong>到达的最后一个分组发送确认（中间没到的可能丢了也可能阻塞还没到），这就表示到这个分组为止的所有分组都已经正确收到了。（但是不会立即发送这个确认号的数据包，因为其有可能只是阻塞了还能到，会等到这个报文段设置的重传时间到了还没收到确认就重传）</p>
</li>
<li><p><strong>重传：</strong>两种事件会导致TCP对报文段的重传：超时和冗余ACK。</p>
<ul>
<li>超时：TCP每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还未收到确认，就重传。</li>
<li>冗余ACK：超时触发重传的周期往往太长。TCP规定每当比期望序号更大的失序报文段到达时，就发送一个冗余ACK（再次确认某个报文段的ACK，之前已经收到过），TCP规定当发送方接收到对同一报文段的3个冗余ACK时，可以认为这个报文段已经丢失，立即执行重传，也称<strong>快速重传</strong>。</li>
</ul>
</li>
<li><p><strong>序列号</strong>：TCP 给 每个字节的数据都进行了编号，即序列号。</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答， 也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发（对丢包的会重传）。接收方根据编号会丢弃重复编号的数据（如超时重传中若是因为应答信号丢失，则会再传重复的数据），把有序数据传送给应用层。</p>
</li>
<li><p><strong>校验和</strong>： 目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
</ul>
<blockquote>
<p>校验和的计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p>
<p>发送方：在发送数据之前计算检验和，并进行校验和的填充。</p>
<p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png" alt="img"></a></p>
<blockquote>
<p>如果接收方比对校验和与发送方不一致，数据一定传输有误。</p>
<p>如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
</blockquote>
<p>此外，TCP协议还通过</p>
<ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>ARQ协议</li>
</ul>
<p>保证传输的可靠性。</p>
<h3 id="4-1-TCP-流量控制"><a href="#4-1-TCP-流量控制" class="headerlink" title="4.1 TCP 流量控制"></a>4.1 TCP 流量控制</h3><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>TCP 利用滑动窗口实现流量控制，在三次握手阶段，双方互相将自己的<strong>数据接收缓冲池大小</strong>告诉对方。 <strong>接收方有即时窗口</strong>（滑动窗口）， 窗口大小的内容 实际上是接收端接收数据缓冲区的剩余大小，而且接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。 发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度， 如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p>那么<strong>发送方</strong>就可以维护一个称为<strong>接收窗口</strong>的变量实现流量控制。</p>
<h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p>发送方维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<blockquote>
<p>发送窗口的上限为接收窗口和拥塞窗口中较小的一个。</p>
</blockquote>
<p><strong>拥塞控制与流量控制的区别：</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1（最大一个报文段的长度），每经过一个传播轮次（即往返时间），cwnd加倍，指数型增长，一直到规定的慢开始门限，然后改用拥塞避免算法。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1，按照线性增长。（即加法增大）。当出现一次超时（网络拥塞时）。令慢开始门限为当前cwnd的一半，cwnd重置为1，执行慢开始算法（即乘法减小）</li>
<li><strong>快重传与快恢复FRR：</strong><ul>
<li>快重传：使用冗余ACK来检测丢包的发生。冗余ACK也用于网络拥塞的检测（丢包当然意味着网络可能出现了拥塞）。</li>
<li>快恢复：收到三个冗余ACK，执行乘法减小，把慢开始门限减为当前cwnd的一半，但是cwnd不置为1，置为新的慢开始门限值（即减半），然后执行加法增大。由于跳过了cwnd从1开始的慢开始过程所以称为快恢复。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong>：当发送方检测到超时的时候，采用慢开始+拥塞避免，当发送方接收到冗余ACK时，采用快重传+快恢复</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png" alt="img"></a></p>
<h3 id="4-3-ARQ协议"><a href="#4-3-ARQ协议" class="headerlink" title="4.3 ARQ协议"></a>4.3 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之一。使用了<strong>确认和超时</strong>的两个机制。</p>
<p>ARQ包括：</p>
<ul>
<li>停止等待ARQ协议</li>
<li>连续ARQ协议。</li>
</ul>
<blockquote>
<p>停止等待ARQ协议</p>
</blockquote>
<ul>
<li><p>停止等待协议：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
</li>
<li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点： 简单</li>
<li>缺点： 信道利用率低，等待时间长</li>
</ul>
</li>
<li><p>几种具体情况：</p>
<ul>
<li><p>无差错情况:</p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
</li>
<li><p>出现差错情况（超时重传）:</p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<ul>
<li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>连续 ARQ 协议</p>
</blockquote>
<p>可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认（过一段时间确认一次，发送方其实是按照顺序发送的，可能由于网络原因，包到达的顺序不一致），而发送方每接收到一个确认，窗口就向前滑动一定距离。</p>
<ul>
<li>优缺点：<ul>
<li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</li>
</ul>
<h2 id="5-在浏览器中输入url地址-—-gt-显示主页的过程"><a href="#5-在浏览器中输入url地址-—-gt-显示主页的过程" class="headerlink" title="5. 在浏览器中输入url地址 —&gt; 显示主页的过程"></a>5. 在浏览器中输入url地址 —&gt; 显示主页的过程</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png" alt="img"></a></p>
<blockquote>
<p>上图有一个错误，请注意，是OSPF不是OPSF。</p>
<p>OSPF（Open Shortest Path Fitst）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li><p><strong>DNS解析</strong></p>
<blockquote>
<p>域名解释：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>.</p>
</blockquote>
<ul>
<li>以最右边英文.开始，称为域名的根：注意最后一个com的后面有点这个就是根，实际用的时候最后加不加点都行</li>
<li>.下面这个名称就为顶级域名，代表服务器/网站的性质：<ul>
<li>com（商业性质）</li>
<li>edu（教育性质）</li>
<li>net（提供信息）</li>
<li>cn（中国）</li>
<li>org（组织）</li>
<li>gov（政府部门）</li>
</ul>
</li>
<li>二级域名：自己申请，比如baidu 完全限定域名：FQDN，比如<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>（后面的<a target="_blank" rel="noopener" href="http://baidu.com/">baidu.com</a>已经全球唯一）</li>
<li>三级域名：<a target="_blank" rel="noopener" href="http://kkk.baidu.com/">kkk.baidu.com</a>的kkk就是第三级，也可以四级五级。一般网站习惯用www，也有<a target="_blank" rel="noopener" href="http://mail.baidu.com/">mail.baidu.com</a>,也可以<a target="_blank" rel="noopener" href="http://wwww.baidu.com/">wwww.baidu.com</a>代表一个域名下的不同服务器，只要对应的IP配正确就可以 谷歌公司的DNS服务器0.0.0.0 电信公司的DNS服务器222.222.222.222）</li>
</ul>
<blockquote>
<p>客户端浏览器通过DNS解析到域名的IP地址。</p>
</blockquote>
<p>域名解析的过程：</p>
<ul>
<li><p>迭代查询：</p>
<p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器向根域名服务器发送请求, 根DNS服务器，不负责具体的域名解析，但是他知道负责解析顶级域名的服务器IP（知道哪个DNS服务器负责哪一块的域名解析），会返回这个IP。本地域名服务器收到这个IP后，联系负责解析该顶级域名的服务器，这个顶级域名的服务器如果自己无法解析就找管理这个二级域名解析的服务器IP地址给本地域名服务器，然后本地域名服务器就去联系这个服务器直到解析成功为止，并把这个IP缓存到本地，供下次查询使用。</p>
</li>
<li><p>转发查询：（递归）</p>
<p>DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。</p>
<p>若有多个合适的服务器，DNS服务器可以返回一个跟用户最接近的点的IP地址给用户。（DNS负载均衡）</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong></p>
<p>在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，对于客户端与服务器的TCP链接，必然要说的就是三次握手。</p>
</li>
<li><p><strong>浏览器向WEB服务器发起Http请求</strong></p>
<p>建立TCP连接之后，发起HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP80端口）</p>
<ul>
<li><strong>传输层</strong> 把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。</li>
<li><strong>网络层：</strong>添加源IP和目标IP。</li>
<li><strong>链路层：</strong>客户端的链路层，发送ARP请求查找下一跳MAC，跨网段是网关的MAC</li>
<li>HTTP请求报文由三部分组成：<ul>
<li>请求行（ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD）</li>
<li>请求头（ HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息）</li>
<li>请求正文（ 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器端处理请求并返回HTTP报文</strong></p>
<ul>
<li>服务器端收到请求后的由web服务器（如 Tomcat）处理请求。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</li>
<li>HTTP响应报文也是由三部分组成:<ul>
<li>状态码（[如下述问题](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/7">http://lihengxu.cn/2021/03/23/计网/7</a>. 常见HTTP状态码)）</li>
<li>响应报头</li>
<li>响应报文（ 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>浏览器解析渲染页面</strong></p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
</li>
<li><p><strong>关闭TCP链接</strong></p>
<p>四次挥手</p>
</li>
</ol>
<h2 id="6-Get和Post区别"><a href="#6-Get和Post区别" class="headerlink" title="6. Get和Post区别"></a>6. Get和Post区别</h2><ul>
<li>Get一般是从服务器上请求数据，Post一般是向服务器传送数据。</li>
<li>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。 POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制。</li>
<li>GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求。</li>
<li>GET 请求可被浏览器主动缓存， POST 请求不会除非手动设置 GET 请求保留在浏览器历史记录中， 可被收藏为书签； POST 请求不会保留在浏览器历史记录中， POST 不能被收藏为书签</li>
<li>GET 只接受ASCII字符， POST支持多种编码方式</li>
<li>GET产生一个TCP数据包， 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包， 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（ 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）。</li>
</ul>
<blockquote>
<p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议， HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</p>
</blockquote>
<h2 id="7-常见HTTP状态码"><a href="#7-常见HTTP状态码" class="headerlink" title="7. 常见HTTP状态码"></a>7. 常见HTTP状态码</h2><p>1xx：表示通知信息，例如表示收到或者是正在处理（临时响应）</p>
<p>2xx：表示成功，例如表示接受或知道了</p>
<p>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动</p>
<p>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成</p>
<p>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p>
<h2 id="8-HTTP协议和各种协议的关系"><a href="#8-HTTP协议和各种协议的关系" class="headerlink" title="8. HTTP协议和各种协议的关系"></a>8. HTTP协议和各种协议的关系</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png" alt="img"></a></p>
<h2 id="9-HTTP长连接-短连接"><a href="#9-HTTP长连接-短连接" class="headerlink" title="9. HTTP长连接,短连接"></a>9. HTTP长连接,短连接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:3">3]</a></p>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<blockquote>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</blockquote>
<p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>
<ul>
<li><p>使用场景：</p>
<ul>
<li><strong>短链接</strong>：像WEB网站的http服务一般都用短链接</li>
</ul>
<p>原因：长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<ul>
<li><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
</li>
</ul>
<h2 id="10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）"><a href="#10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）" class="headerlink" title="10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）"></a>10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）</h2><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>我们可以使用cookie和session来保持会话状态，</p>
<ul>
<li>会话：一次会话中包含多次请求和响应</li>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</li>
</ul>
<blockquote>
<p>cookie和session功能就是在一次会话的范围内的多次请求间，共享数据。</p>
</blockquote>
<ul>
<li>客户端会话技术：Cookie，将数据保存到客户端浏览器（cookie一般用于存出少量的不太敏感的数据或是在不登录的情况下，完成服务器对客户端的身份识别）；</li>
<li>服务器端会话技术：Session，将数据保存在服务器端的对象中，Session的实现是依赖于Cookie的。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。</li>
</ul>
<p>实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p>
<blockquote>
<p>Cookie 被禁用怎么办?</p>
</blockquote>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>
<p>参考回答：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png" alt="img"></a></p>
<h2 id="11-Cookie的作用是什么-和Session有什么区别？"><a href="#11-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="11. Cookie的作用是什么?和Session有什么区别？"></a>11. Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Session没有数据大小限制，Cookie有。</p>
<p>相对 Cookie 来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="12-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#12-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="12. HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>12. HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><ol>
<li>在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="13-URI和URL的区别是什么"><a href="#13-URI和URL的区别是什么" class="headerlink" title="13. URI和URL的区别是什么?"></a>13. URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URI就是在某一规则下能把一个资源独一无二地标识出来。如：身份证</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL就是用定位的方式实现的URI。 可认为由4部分组成：协议、主机、端口、路径 http:localhost:8080/index.jsp ( 对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息) 如：具体住址</li>
</ul>
<p> URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="14-HTTP-和-HTTPS-的区别？"><a href="#14-HTTP-和-HTTPS-的区别？" class="headerlink" title="14. HTTP 和 HTTPS 的区别？"></a>14. HTTP 和 HTTPS 的区别？</h2><ol>
<li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li>安全性和资源消耗：<ul>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文。</li>
<li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。（ HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。）所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li>
</ul>
</li>
</ol>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:1">↩</a></li>
<li>JavaGuide面试突袭v4.0，计算机网络 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">https://www.cnblogs.com/gotodsp/p/6366163.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:3">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" data-id="ckn6tieao00061kub7fj3bc1o" data-title="计算机网络总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/06/redis%E5%9F%BA%E7%A1%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          redis基础
        
      </div>
    </a>
  
  
    <a href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">BIO_AIO_NIO区别</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/07/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">redis集群与企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/">redis高级</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E5%9F%BA%E7%A1%80/">redis基础</a>
          </li>
        
          <li>
            <a href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">计算机网络总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>