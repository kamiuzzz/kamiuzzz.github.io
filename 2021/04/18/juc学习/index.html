<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>juc学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="并发编程笔记黑马java并发编程教程教学视频的笔记（转载nyimac，再转一篇学习学习，等看一遍《java并发编程的艺术》后，再整理自己的学习note吧） 一、基本概念1、进程与线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。 当一个程序被运行，从磁">
<meta property="og:type" content="article">
<meta property="og:title" content="juc学习">
<meta property="og:url" content="http://example.com/2021/04/18/juc%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="并发编程笔记黑马java并发编程教程教学视频的笔记（转载nyimac，再转一篇学习学习，等看一遍《java并发编程的艺术》后，再整理自己的学习note吧） 一、基本概念1、进程与线程进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。 当一个程序被运行，从磁">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png">
<meta property="og:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png">
<meta property="article:published_time" content="2021-04-18T08:11:13.000Z">
<meta property="article:modified_time" content="2021-04-18T08:13:33.841Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-juc学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T08:11:13.000Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      juc学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010"><strong>黑马java并发编程教程</strong></a>教学视频的笔记（转载<a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">nyimac</a>，再转一篇学习学习，等看一遍《java并发编程的艺术》后，再整理自己的学习note吧）</p>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li>
</ul>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享<ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h4 id="进程和线程的切换"><a href="#进程和线程的切换" class="headerlink" title="进程和线程的切换"></a>进程和线程的切换</h4><p><strong>上下文切换</strong></p>
<p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p>
<ul>
<li>通用目的寄存器</li>
<li>浮点寄存器</li>
<li>程序计数器</li>
<li>用户栈</li>
<li>状态寄存器</li>
<li>内核栈</li>
<li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li>
</ul>
<p><strong>进程切换和线程切换的主要区别</strong></p>
<p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p>
<p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p>
<p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p>
<p><strong>为什么TLB能加快访问速度</strong></p>
<p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p>
<h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p>
<p>并行是多个CPU同时处理不同的线程。</p>
<p>引用 Rob Pike 的一段描述：</p>
<ul>
<li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li>
</ul>
<h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<ol>
<li>设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</li>
<li>结论</li>
</ol>
<ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li>
<li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li>
</ul>
<p>结论</p>
<ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li>
</ol>
<h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：通过继承Thread创建线程"><a href="#方法一：通过继承Thread创建线程" class="headerlink" title="方法一：通过继承Thread创建线程"></a>方法一：通过继承Thread创建线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class CreateThread &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Thread myThread &#x3D; new MyThread();</span><br><span class="line">        &#x2F;&#x2F; 启动线程</span><br><span class="line">		myThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void run() &#123;</span><br><span class="line">		System.out.println(&quot;my thread running...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>使用继承方式的好处是，在run（）方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread（）方法；不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建线程任务</span><br><span class="line">		Runnable r &#x3D; new Runnable() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		&#x2F;&#x2F;将Runnable对象传给Thread</span><br><span class="line">		Thread t &#x3D; new Thread(r);</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CreateThread2 &#123;</span><br><span class="line">   private static class MyRunnable implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         System.out.println(&quot;my runnable running...&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      MyRunnable myRunnable &#x3D; new MyRunnable();</span><br><span class="line">      Thread thread &#x3D; new Thread(myRunnable);</span><br><span class="line">      thread.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>通过实现Runnable接口，并且实现run()方法。在创建线程时作为参数传入该类的实例即可</p>
<h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p>
<p>所以方法二中的代码可以被简化为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F;创建线程任务</span><br><span class="line">		Runnable r &#x3D; () -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;直接写方法体即可</span><br><span class="line">			System.out.println(&quot;Runnable running&quot;);</span><br><span class="line">			System.out.println(&quot;Hello Thread&quot;);</span><br><span class="line">		&#125;;</span><br><span class="line">		&#x2F;&#x2F;将Runnable对象传给Thread</span><br><span class="line">		Thread t &#x3D; new Thread(r);</span><br><span class="line">		&#x2F;&#x2F;启动线程</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以再Runnable上使用Alt+Enter</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" alt="img"></a></p>
<h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p>
<ul>
<li>方法1 是把线程和任务合并在了一起</li>
<li>方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">	public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;需要传入一个Callable对象</span><br><span class="line">		FutureTask&lt;Integer&gt; task &#x3D; new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public Integer call() throws Exception &#123;</span><br><span class="line">				System.out.println(&quot;线程执行!&quot;);</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">				return 100;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		Thread r1 &#x3D; new Thread(task, &quot;t2&quot;);</span><br><span class="line">		r1.start();</span><br><span class="line">		&#x2F;&#x2F;获取线程中方法执行后的返回结果</span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class UseFutureTask &#123;</span><br><span class="line">   public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">      FutureTask&lt;String&gt; futureTask &#x3D; new FutureTask&lt;&gt;(new MyCall());</span><br><span class="line">      Thread thread &#x3D; new Thread(futureTask);</span><br><span class="line">      thread.start();</span><br><span class="line">      &#x2F;&#x2F; 获得线程运行后的返回值</span><br><span class="line">      System.out.println(futureTask.get());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyCall implements Callable&lt;String&gt; &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String call() throws Exception &#123;</span><br><span class="line">      return &quot;hello world&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。<strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p>
<h3 id="（常用）查看进程线程方法⭐"><a href="#（常用）查看进程线程方法⭐" class="headerlink" title="（常用）查看进程线程方法⭐"></a>（常用）查看进程线程方法⭐</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JUC_1_20210417.png" alt="img"></a></p>
<h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p>
<ul>
<li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 有更高优先级的线程需要运行</li>
<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p>
<h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol>
<li><p>调用 sleep 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p>
</li>
<li><p>其它线程可以使用 <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行</p>
</li>
<li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;休眠一秒</span><br><span class="line">TimeUnit.SECONDS.sleep(1);</span><br><span class="line">&#x2F;&#x2F;休眠一分钟</span><br><span class="line">TimeUnit.MINUTES.sleep(1);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol>
<li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul>
<li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
</li>
<li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
</li>
<li><p>设置方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); &#x2F;&#x2F;设置为优先级最高</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread &#x3D; new Thread();</span><br><span class="line">&#x2F;&#x2F;等待thread线程执行结束</span><br><span class="line">thread.join();</span><br><span class="line">&#x2F;&#x2F;最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span><br><span class="line">thread.join(1000);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为true。</li>
<li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用于查看打断标记，返回值被boolean类型</span><br><span class="line">t1.isInterrupted();Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while(true) &#123;</span><br><span class="line">    if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" alt="img"></a></p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">                    &#x2F;&#x2F;判断当前线程是否被打断了</span><br><span class="line">					if(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">                        &#x2F;&#x2F;终止线程执行</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">						&#x2F;&#x2F;如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span><br><span class="line">						Thread.currentThread().interrupt();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul>
<li>stop方法 停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li>
<li>suspend（暂停线程）/resume（恢复线程）方法</li>
</ul>
<h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将线程设置为守护线程, 默认为false</span><br><span class="line">monitor.setDaemon(true); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>守护线程的应用</strong></p>
<ul>
<li>垃圾回收器线程就是一种守护线程</li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li>
</ul>
<h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" alt="img"></a></p>
<ul>
<li>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</li>
<li>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</li>
<li>【运行状态】指获取了 CPU 时间片运行中的状态<ul>
<li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】<ul>
<li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】</li>
<li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li>
<li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</li>
</ul>
</li>
<li>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</li>
</ul>
<h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" alt="img"></a></p>
<ul>
<li><strong>NEW</strong> 线程刚被创建，但是还没有调用 start() 方法</li>
<li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行）</li>
<li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。</li>
<li><strong>TERMINATED</strong> 当线程代码运行结束</li>
</ul>
<h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static int counter &#x3D; 0;</span><br><span class="line"> </span><br><span class="line">static void increment() </span><br><span class="line">&#x2F;&#x2F; 临界区 </span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void decrement() </span><br><span class="line">&#x2F;&#x2F; 临界区 </span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li>阻塞式的解决方案：synchronized，Lock</li>
<li>非阻塞式的解决方案：原子变量</li>
</ul>
<p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象) &#123;</span><br><span class="line">	&#x2F;&#x2F;临界区</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int counter &#x3D; 0; </span><br><span class="line">&#x2F;&#x2F;创建一个公共对象，作为对象锁的对象</span><br><span class="line">static final Object room &#x3D; new Object();</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;    </span><br><span class="line">	Thread t1 &#x3D; new Thread(() -&gt; &#123;        </span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5000; i++) &#123;            </span><br><span class="line">        synchronized (room) &#123;     </span><br><span class="line">        counter++;            </span><br><span class="line">       	 &#125;       </span><br><span class="line"> 	   &#125;    </span><br><span class="line">    &#125;, &quot;t1&quot;);</span><br><span class="line"> </span><br><span class="line">    Thread t2 &#x3D; new Thread(() -&gt; &#123;       </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5000; i++) &#123;         </span><br><span class="line">            synchronized (room) &#123;            </span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, &quot;t2&quot;);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(&quot;&#123;&#125;&quot;,counter); </span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul>
<li><p>加在成员方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">	&#x2F;&#x2F;在方法上加上synchronized关键字</span><br><span class="line">	public synchronized void test() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;等价于</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		synchronized(this) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>加在静态方法上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">	&#x2F;&#x2F;在静态方法上加上synchronized关键字</span><br><span class="line">	public synchronized static void test() &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;等价于</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		synchronized(Demo.class) &#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>但局部变量引用的对象则未必 （要看该对象</p>
<p>是否被共享</p>
<p>且被执行了读写操作）</p>
<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
<li><p>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" alt="img"></a></p>
<ul>
<li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" alt="img"></a></p>
<ul>
<li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" alt="img"></a></p>
<h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuﬀer</li>
<li>Random</li>
<li>Vector （List的线程安全实现类）</li>
<li>Hashtable （Hash的线程安全实现类）</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p>
<ul>
<li>它们的每个方法是原子的（都被加上了synchronized）</li>
<li>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" alt="img"></a></p>
<h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p>
<p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p>
<p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p>
<h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" alt="img"></a></p>
<ul>
<li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p>
<ul>
<li><p>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</p>
</li>
<li><p>如果</p>
<p>已经绑定</p>
<p>，则会去查询该Monitor是否已经有了Owner</p>
<ul>
<li>如果没有，则Owner与将当前线程绑定</li>
<li>如果有，则放入EntryList，进入阻塞状态(blocked)</li>
</ul>
</li>
</ul>
</li>
<li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p>
</li>
<li><p><strong>注意</strong>：</p>
<ul>
<li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li>
<li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li>
</ul>
</li>
</ul>
<h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" alt="img"></a></p>
<h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p>
<ul>
<li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" alt="img"></a></p>
</li>
<li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" alt="img"></a></p>
<ul>
<li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" alt="img"></a></p>
<h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul>
<li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" alt="img"></a></p>
<ul>
<li><p>此时便会给对象加上重量级锁（使用Monitor）</p>
<ul>
<li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p>
</li>
<li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p>
<ul>
<li>第一种情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" alt="img"></a></p>
<ul>
<li>第二种情况</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" alt="img"></a></p>
<h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p>
<p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" alt="img"></a></p>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul>
<li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li>
<li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li>
<li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li>
<li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" alt="img"></a></p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li>
<li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li>
</ul>
<h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p>
<ul>
<li>调用对象的hashCode方法</li>
<li>多个线程使用该对象</li>
<li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li>
</ul>
<h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul>
<li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul>
<li>重偏向会重置Thread ID</li>
</ul>
</li>
<li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li>
</ul>
<h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p>
<h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" alt="img"></a></p>
<ul>
<li><p>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</p>
</li>
<li><p>处于BLOCKED和WAITING状态的线程都为</p>
<p>阻塞</p>
<p>状态，CPU都不会分给他们时间片。但是有所区别：</p>
<ul>
<li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li>
<li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li>
</ul>
</li>
<li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</p>
</li>
</ul>
<p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Test1 &#123;</span><br><span class="line">	final static Object LOCK &#x3D; new Object();</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F;只有在对象被锁住后才能调用wait方法</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			LOCK.wait();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p>
<ul>
<li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li>
<li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li>
<li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>阻塞状态都为<strong>TIMED_WAITING</strong></li>
</ul>
<h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p>
<ul>
<li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li>
</ul>
<p><strong>使用wait/notify需要注意什么</strong></p>
<ul>
<li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">synchronized (LOCK) &#123;</span><br><span class="line">	while(&#x2F;&#x2F;不满足条件，一直等待，避免虚假唤醒) &#123;</span><br><span class="line">		LOCK.wait();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;满足条件后再运行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">synchronized (LOCK) &#123;</span><br><span class="line">	&#x2F;&#x2F;唤醒所有等待线程</span><br><span class="line">	LOCK.notifyAll();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" alt="img"></a></p>
<h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		String hello &#x3D; &quot;hello thread!&quot;;</span><br><span class="line">		Guarded guarded &#x3D; new Guarded();</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;想要得到结果&quot;);</span><br><span class="line">			synchronized (guarded) &#123;</span><br><span class="line">				System.out.println(&quot;结果是：&quot;+guarded.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到结果&quot;);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;设置结果&quot;);</span><br><span class="line">			synchronized (guarded) &#123;</span><br><span class="line">				guarded.setResponse(hello);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Guarded &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 要返回的结果</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private Object response;</span><br><span class="line">	</span><br><span class="line">    &#x2F;&#x2F;优雅地使用wait&#x2F;notify</span><br><span class="line">	public Object getResponse() &#123;</span><br><span class="line">		&#x2F;&#x2F;如果返回结果为空就一直等待，避免虚假唤醒</span><br><span class="line">		while(response &#x3D;&#x3D; null) &#123;</span><br><span class="line">			synchronized (this) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					this.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return response;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setResponse(Object response) &#123;</span><br><span class="line">		this.response &#x3D; response;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			&#x2F;&#x2F;唤醒休眠的线程</span><br><span class="line">			this.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Guarded&#123;&quot; +</span><br><span class="line">				&quot;response&#x3D;&quot; + response +</span><br><span class="line">				&#39;&#125;&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>带超时判断的暂停</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public Object getResponse(long time) &#123;</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			&#x2F;&#x2F;获取开始时间</span><br><span class="line">			long currentTime &#x3D; System.currentTimeMillis();</span><br><span class="line">			&#x2F;&#x2F;用于保存已经等待了的时间</span><br><span class="line">			long passedTime &#x3D; 0;</span><br><span class="line">			while(response &#x3D;&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;看经过的时间-开始时间是否超过了指定时间</span><br><span class="line">				long waitTime &#x3D; time -passedTime;</span><br><span class="line">				if(waitTime &lt;&#x3D; 0) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">				try &#123;</span><br><span class="line">                   	&#x2F;&#x2F;等待剩余时间</span><br><span class="line">					this.wait(waitTime);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F;获取当前时间</span><br><span class="line">				passedTime &#x3D; System.currentTimeMillis()-currentTime		</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return response;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void join(long millis)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">        long base &#x3D; System.currentTimeMillis();</span><br><span class="line">        long now &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        if (millis &lt; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (millis &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                wait(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (isAlive()) &#123;</span><br><span class="line">                long delay &#x3D; millis - now;</span><br><span class="line">                if (delay &lt;&#x3D; 0) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now &#x3D; System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;暂停线程运行</span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;恢复线程运行</span><br><span class="line">LockSupport.unpark(thread);Copy</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Thread thread &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;park&quot;);</span><br><span class="line">            &#x2F;&#x2F;暂停线程运行</span><br><span class="line">			LockSupport.park();</span><br><span class="line">			System.out.println(&quot;resume&quot;);</span><br><span class="line">		&#125;, &quot;t1&quot;);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		System.out.println(&quot;unpark&quot;);</span><br><span class="line">    	&#x2F;&#x2F;恢复线程运行</span><br><span class="line">		LockSupport.unpark(thread);</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p>
<ul>
<li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li>
<li>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</li>
<li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li>
<li><strong>park不会释放锁</strong>，而wait会释放锁</li>
</ul>
<h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象**_counter, _cond,__mutex**组成</p>
<ul>
<li><p>先调用park再调用unpark时</p>
<ul>
<li><p>先调用park</p>
<ul>
<li>线程运行时，会将Park对象中的**_counter的值设为0**；</li>
<li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li>
<li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li>
</ul>
</li>
<li><p>然后调用unpark</p>
<ul>
<li><p>调用unpark方法后，会将counter的值设置为1</p>
</li>
<li><p>去唤醒阻塞队列cond中的线程</p>
</li>
<li><p>线程继续运行并将counter的值设为0</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" alt="img"></a></p>
<ul>
<li>先调用unpark，再调用park<ul>
<li>调用unpark<ul>
<li>会将counter设置为1（运行时0）</li>
</ul>
</li>
<li>调用park方法<ul>
<li>查看counter是否为0</li>
<li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" alt="img"></a></p>
<h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" alt="img"></a></p>
<h3 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h3><ul>
<li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE</li>
</ul>
<h3 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul>
<li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li><p>当前线程</p>
<p>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING</p>
<ul>
<li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h3><ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h3><p>t 线程用 synchronized(obj) 获取了对象锁后</p>
<ul>
<li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul>
<li>竞争锁成功，t 线程从 TIMED_WAITING –&gt; RUNNABLE</li>
<li>竞争锁失败，t 线程从 TIMED_WAITING –&gt; BLOCKED</li>
</ul>
</li>
</ul>
<h3 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li><p>当前线程调用 t.join</p>
<p>(long n</p>
<p>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING</p>
<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</p>
</li>
</ul>
<h3 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li>
</ul>
<h3 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h3><ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING</li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li>
</ul>
<h3 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h3><ul>
<li>t 线程用 synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从 RUNNABLE –&gt; BLOCKED</li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然 BLOCKED</li>
</ul>
<h3 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h3><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p>
<h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class BigRoom &#123;</span><br><span class="line">    &#x2F;&#x2F;额外创建对象来作为锁</span><br><span class="line">	private final Object studyRoom &#x3D; new Object();</span><br><span class="line">	private final Object bedRoom &#x3D; new Object();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p>
<h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p>
<p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		final Object A &#x3D; new Object();</span><br><span class="line">		final Object B &#x3D; new Object();</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			synchronized (A) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(2000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (B) &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			synchronized (B) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					Thread.sleep(1000);</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				synchronized (A) &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h4><ul>
<li>互斥条件<ul>
<li>在一段时间内，一种资源只能被一个进程所使用</li>
</ul>
</li>
<li>请求和保持条件<ul>
<li>进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源</li>
</ul>
</li>
<li>不可抢占条件<ul>
<li>进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放</li>
</ul>
</li>
<li>循环等待条件<ul>
<li>发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
</li>
</ul>
<h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul>
<li><p>jps+jstack ThreadID</p>
<ul>
<li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" alt="img"></a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">F:\Thread_study&gt;jps</span><br><span class="line">20672 RemoteMavenServer36</span><br><span class="line">22880 Jps</span><br><span class="line">4432 Launcher</span><br><span class="line">5316 Test5</span><br><span class="line">20184 KotlinCompileDaemon</span><br><span class="line">11132</span><br><span class="line"></span><br><span class="line">F:\Thread_study&gt;jstack 5316 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>打印的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;找到一个java级别的死锁</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&quot;Thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000017f40de8 (object 0x00000000d6188880, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-0&quot;</span><br><span class="line">&quot;Thread-0&quot;:</span><br><span class="line">  waiting to lock monitor 0x0000000017f43678 (object 0x00000000d6188890, a java.lang.Object),</span><br><span class="line">  which is held by &quot;Thread-1&quot; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>jconsole检测死锁</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" alt="img"></a></p>
</li>
</ul>
<h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" alt="img"></a></p>
<h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" alt="img"></a></p>
<h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p>
<h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p>
<h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li>
</ul>
<h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p>
<p>在使用顺序加锁时，可能会出现饥饿现象</p>
<h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁 (先到先得)</li>
<li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li>
</ul>
<p><strong>基本语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取ReentrantLock对象</span><br><span class="line">private ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">&#x2F;&#x2F;加锁</span><br><span class="line">lock.lock();</span><br><span class="line">try &#123;</span><br><span class="line">	&#x2F;&#x2F;需要执行的代码</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">	&#x2F;&#x2F;释放锁</span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul>
<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p>
<p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F;加锁，可打断锁</span><br><span class="line">				lock.lockInterruptibly();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">                &#x2F;&#x2F;被打断，返回，不再向下执行</span><br><span class="line">				return;</span><br><span class="line">			&#125;finally &#123;</span><br><span class="line">				&#x2F;&#x2F;释放锁</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">			&#x2F;&#x2F;打断</span><br><span class="line">			t1.interrupt();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p>
<p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p>
<p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p>
<p>不设置等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F;未设置等待时间，一旦获取失败，直接返回false</span><br><span class="line">			if(!lock.tryLock()) &#123;</span><br><span class="line">				System.out.println(&quot;获取失败&quot;);</span><br><span class="line">                &#x2F;&#x2F;获取失败，不再向下执行，返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到了锁&quot;);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>设置等待时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">		Thread t1 &#x3D; new Thread(()-&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				&#x2F;&#x2F;判断获取锁是否成功，最多等待1秒</span><br><span class="line">				if(!lock.tryLock(1, TimeUnit.SECONDS)) &#123;</span><br><span class="line">					System.out.println(&quot;获取失败&quot;);</span><br><span class="line">					&#x2F;&#x2F;获取失败，不再向下执行，直接返回</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				&#x2F;&#x2F;被打断，不再向下执行，直接返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;得到了锁&quot;);</span><br><span class="line">			&#x2F;&#x2F;释放锁</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			&#x2F;&#x2F;打断等待</span><br><span class="line">			t1.interrupt();</span><br><span class="line">			Thread.sleep(3000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;默认是不公平锁，需要在创建时指定为公平锁</span><br><span class="line">ReentrantLock lock &#x3D; new ReentrantLock(true); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li>await 前需要<strong>获得锁</strong></li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static Boolean judge &#x3D; false;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	ReentrantLock lock &#x3D; new ReentrantLock();</span><br><span class="line">	&#x2F;&#x2F;获得条件变量</span><br><span class="line">	Condition condition &#x3D; lock.newCondition();</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try&#123;</span><br><span class="line">			while(!judge) &#123;</span><br><span class="line">				System.out.println(&quot;不满足条件，等待...&quot;);</span><br><span class="line">				&#x2F;&#x2F;等待</span><br><span class="line">				condition.await();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			System.out.println(&quot;执行完毕！&quot;);</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(1);</span><br><span class="line">			judge &#x3D; true;</span><br><span class="line">			&#x2F;&#x2F;释放</span><br><span class="line">			condition.signal();</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="通过Lock与AQS实现可重入锁"><a href="#通过Lock与AQS实现可重入锁" class="headerlink" title="通过Lock与AQS实现可重入锁"></a>通过Lock与AQS实现可重入锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">public class MyLock implements Lock &#123;</span><br><span class="line">   private static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">      @Override</span><br><span class="line">      protected boolean tryAcquire(int arg) &#123;</span><br><span class="line">         if (getExclusiveOwnerThread() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (compareAndSetState(0, 1)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (getExclusiveOwnerThread() &#x3D;&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            int state &#x3D; getState();</span><br><span class="line">            compareAndSetState(state, state + 1);</span><br><span class="line">            return true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean tryRelease(int arg) &#123;</span><br><span class="line">         if (getState() &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (getExclusiveOwnerThread() !&#x3D; Thread.currentThread()) &#123;</span><br><span class="line">            throw new IllegalMonitorStateException();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         int state &#x3D; getState();</span><br><span class="line">         if (state &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            setExclusiveOwnerThread(null);</span><br><span class="line">            compareAndSetState(state, 0);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            compareAndSetState(state, state - 1);</span><br><span class="line">         &#125;</span><br><span class="line">         return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      protected boolean isHeldExclusively() &#123;</span><br><span class="line">         return getState() &gt;&#x3D; 1;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public Condition newCondition() &#123;</span><br><span class="line">         return new ConditionObject();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Sync sync &#x3D; new Sync();</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void lock() &#123;</span><br><span class="line">      sync.acquire(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void lockInterruptibly() throws InterruptedException &#123;</span><br><span class="line">      sync.acquireInterruptibly(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean tryLock() &#123;</span><br><span class="line">      return sync.tryAcquire(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">      return sync.tryAcquireNanos(1, time);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void unlock() &#123;</span><br><span class="line">      sync.release(1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public Condition newCondition() &#123;</span><br><span class="line">      return sync.newCondition();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">   static int num &#x3D; 0;</span><br><span class="line">   public static void main(String[] args) throws InterruptedException, IOException &#123;</span><br><span class="line">      MyLock lock &#x3D; new MyLock();</span><br><span class="line"></span><br><span class="line">      Object syncLock &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">      Thread t1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  try &#123;</span><br><span class="line">                     num++;</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                     lock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread t2 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; 10000; i++) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">               lock.lock();</span><br><span class="line">               try &#123;</span><br><span class="line">                  lock.lock();</span><br><span class="line">                  try &#123;</span><br><span class="line">                     num--;</span><br><span class="line">                  &#125; finally &#123;</span><br><span class="line">                     lock.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                  lock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      t1.join();</span><br><span class="line">      t2.join();</span><br><span class="line"></span><br><span class="line">      int x &#x3D; 0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static final Object LOCK &#x3D; new Object();</span><br><span class="line">&#x2F;&#x2F;判断先执行的内容是否执行完毕</span><br><span class="line">static Boolean judge &#x3D; false;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			while (!judge) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					LOCK.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;2&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		synchronized (LOCK) &#123;</span><br><span class="line">			System.out.println(&quot;1&quot;);</span><br><span class="line">			judge &#x3D; true;</span><br><span class="line">               &#x2F;&#x2F;执行完毕，唤醒所有等待线程</span><br><span class="line">			LOCK.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Test4 &#123;</span><br><span class="line">	static Symbol symbol &#x3D; new Symbol();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			symbol.run(&quot;a&quot;, 1, 2);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			symbol.run(&quot;b&quot;, 2, 3);</span><br><span class="line"></span><br><span class="line">		&#125;).start();</span><br><span class="line">		symbol.run(&quot;c&quot;, 3, 1);</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line"></span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Symbol &#123;</span><br><span class="line">	public synchronized void run(String str, int flag, int nextFlag) &#123;</span><br><span class="line">		for(int i&#x3D;0; i&lt;loopNumber; i++) &#123;</span><br><span class="line">			while(flag !&#x3D; this.flag) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					this.wait();</span><br><span class="line">				&#125; catch (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(str);</span><br><span class="line">			&#x2F;&#x2F;设置下一个运行的线程标记</span><br><span class="line">			this.flag &#x3D; nextFlag;</span><br><span class="line">			&#x2F;&#x2F;唤醒所有线程</span><br><span class="line">			this.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private int flag &#x3D; 1;</span><br><span class="line">	private int loopNumber &#x3D; 5;</span><br><span class="line"></span><br><span class="line">	public int getFlag() &#123;</span><br><span class="line">		return flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setFlag(int flag) &#123;</span><br><span class="line">		this.flag &#x3D; flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getLoopNumber() &#123;</span><br><span class="line">		return loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setLoopNumber(int loopNumber) &#123;</span><br><span class="line">		this.loopNumber &#x3D; loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>await/signal版本</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class Test5 &#123;</span><br><span class="line">	static AwaitSignal awaitSignal &#x3D; new AwaitSignal();</span><br><span class="line">	static Condition conditionA &#x3D; awaitSignal.newCondition();</span><br><span class="line">	static Condition conditionB &#x3D; awaitSignal.newCondition();</span><br><span class="line">	static Condition conditionC &#x3D; awaitSignal.newCondition();</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;a&quot;, conditionA, conditionB);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;b&quot;, conditionB, conditionC);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			awaitSignal.run(&quot;c&quot;, conditionC, conditionA);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125; catch (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		awaitSignal.lock();</span><br><span class="line">		try &#123;</span><br><span class="line">            &#x2F;&#x2F;唤醒一个等待的线程</span><br><span class="line">			conditionA.signal();</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			awaitSignal.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AwaitSignal extends ReentrantLock&#123;</span><br><span class="line">	public void run(String str, Condition thisCondition, Condition nextCondition) &#123;</span><br><span class="line">		for(int i&#x3D;0; i&lt;loopNumber; i++) &#123;</span><br><span class="line">			lock();</span><br><span class="line">			try &#123;</span><br><span class="line">                &#x2F;&#x2F;全部进入等待状态</span><br><span class="line">				thisCondition.await();</span><br><span class="line">				System.out.print(str);</span><br><span class="line">				nextCondition.signal();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; finally &#123;</span><br><span class="line">				unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int loopNumber&#x3D;5;</span><br><span class="line"></span><br><span class="line">	public int getLoopNumber() &#123;</span><br><span class="line">		return loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setLoopNumber(int loopNumber) &#123;</span><br><span class="line">		this.loopNumber &#x3D; loopNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="14、ThreadLocal"><a href="#14、ThreadLocal" class="headerlink" title="14、ThreadLocal"></a>14、ThreadLocal</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么<strong>访问这个变量的每个线程都会有这个变量的一个本地副本</strong>。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadLocalStudy &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 创建ThreadLocal变量</span><br><span class="line">      ThreadLocal&lt;String&gt; stringThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">      ThreadLocal&lt;User&gt; userThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建两个线程，分别使用上面的两个ThreadLocal变量</span><br><span class="line">      Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第一次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread1 stringThreadLocal first&quot;);</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第二次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread1 stringThreadLocal second&quot;);</span><br><span class="line">         &#x2F;&#x2F; userThreadLocal赋值</span><br><span class="line">         userThreadLocal.set(new User(&quot;Nyima&quot;, 20));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 取值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line">         System.out.println(userThreadLocal.get());</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; 移除</span><br><span class="line">		 userThreadLocal.remove();</span><br><span class="line">		 System.out.println(userThreadLocal.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      Thread thread2 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第一次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread2 stringThreadLocal first&quot;);</span><br><span class="line">         &#x2F;&#x2F; stringThreadLocal第二次赋值</span><br><span class="line">         stringThreadLocal.set(&quot;thread2 stringThreadLocal second&quot;);</span><br><span class="line">         &#x2F;&#x2F; userThreadLocal赋值</span><br><span class="line">         userThreadLocal.set(new User(&quot;Hulu&quot;, 20));</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 取值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line">         System.out.println(userThreadLocal.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 启动线程</span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class User &#123;</span><br><span class="line">   String name;</span><br><span class="line">   int age;</span><br><span class="line"></span><br><span class="line">   public User(String name, int age) &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      this.age &#x3D; age;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">      return &quot;User&#123;&quot; +</span><br><span class="line">            &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &quot;, age&#x3D;&quot; + age +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1 stringThreadLocal second</span><br><span class="line">thread2 stringThreadLocal second</span><br><span class="line">User&#123;name&#x3D;&#39;Nyima&#39;, age&#x3D;20&#125;</span><br><span class="line">User&#123;name&#x3D;&#39;Hulu&#39;, age&#x3D;20&#125;</span><br><span class="line">null </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>从运行结果可以看出</p>
<ul>
<li>每个线程中的ThreadLocal变量是每个线程私有的，而不是共享的<ul>
<li>从线程1和线程2的打印结果可以看出</li>
</ul>
</li>
<li>ThreadLocal其实就相当于其泛型类型的一个变量，只不过是每个线程私有的<ul>
<li>stringThreadLocal被赋值了两次，保存的是最后一次赋值的结果</li>
</ul>
</li>
<li>ThreadLocal可以进行以下几个操作<ul>
<li>set 设置值</li>
<li>get 取出值</li>
<li>remove 移除值</li>
</ul>
</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="Thread中的threadLocals"><a href="#Thread中的threadLocals" class="headerlink" title="Thread中的threadLocals"></a>Thread中的threadLocals</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Thread implements Runnable &#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 放在后面说</span><br><span class="line"> ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;Copy</span><br><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line">    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">        &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            super(k);</span><br><span class="line">            value &#x3D; v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以看出Thread类中有一个threadLocals和一个inheritableThreadLocals，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的Hashmap。在默认情况下，每个线程中的这两个变量都为null。此处先讨论threadLocals，inheritableThreadLocals放在后面讨论</p>
<h4 id="ThreadLocal中的方法"><a href="#ThreadLocal中的方法" class="headerlink" title="ThreadLocal中的方法"></a><strong>ThreadLocal中的方法</strong></h4><p><strong>set方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获得ThreadLocalMap对象 </span><br><span class="line">    &#x2F;&#x2F; 这里的get会返回Thread类中的threadLocals</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断map是否已经创建，没创建就创建并放入值，创建了就直接放入</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; ThreadLocal自生的引用作为key，传入的值作为value</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>如果未创建</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建的同时设置想放入的值</span><br><span class="line">    &#x2F;&#x2F; hreadLocal自生的引用作为key，传入的值作为value</span><br><span class="line">    t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>get方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public T get() &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取当前线程</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">	&#x2F;&#x2F; 获取当前线程的threadLocals变量</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断threadLocals是否被初始化了</span><br><span class="line">    if (map !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 已经初始化则直接返回</span><br><span class="line">        ThreadLocalMap.Entry e &#x3D; map.getEntry(this);</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            T result &#x3D; (T)e.value;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则就创建threadLocals</span><br><span class="line">    return setInitialValue();</span><br><span class="line">&#125;Copy</span><br><span class="line">private T setInitialValue() &#123;</span><br><span class="line">    &#x2F;&#x2F; 这个方法返回是null</span><br><span class="line">    T value &#x3D; initialValue();</span><br><span class="line">    Thread t &#x3D; Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 无论map创建与否，最终value的值都为null</span><br><span class="line">    if (map !&#x3D; null)</span><br><span class="line">        map.set(this, value);</span><br><span class="line">    else</span><br><span class="line">        createMap(t, value);</span><br><span class="line">    return value;</span><br><span class="line">&#125;Copy</span><br><span class="line">protected T initialValue() &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>remove方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void remove() &#123;</span><br><span class="line">    ThreadLocalMap m &#x3D; getMap(Thread.currentThread());</span><br><span class="line">    if (m !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 如果threadLocals已经被初始化，则移除</span><br><span class="line">        m.remove(this);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h4><p>在每个线程内部都有一个名为threadLocals的成员变量，该变量的类型为HashMap，其中<strong>key为我们定义的ThreadLocal变量的this引用，value则为我们使用set方法设置的值</strong>。每个线程的本地变量存放在线程自己的内存变量threadLocals中</p>
<p>只有当前线程<strong>第一次调用ThreadLocal的set或者get方法时才会创建threadLocals</strong>（inheritableThreadLocals也是一样）。其实每个线程的本地变量不是存放在ThreadLocal实例里面，而是存放在调用线程的threadLocals变量里面</p>
<h2 id="15、InheritableThreadLocal"><a href="#15、InheritableThreadLocal" class="headerlink" title="15、InheritableThreadLocal"></a>15、InheritableThreadLocal</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>从ThreadLocal的源码可以看出，无论是set、get、还是remove，都是相对于当前线程操作的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread()Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>所以ThreadLocal无法从父线程传向子线程，所以InheritableThreadLocal出现了，<strong>它能够让父线程中ThreadLocal的值传给子线程。</strong></p>
<p>也就是从main所在的线程，传给thread1或thread2</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ThreadLocal&lt;String&gt; stringThreadLocal &#x3D; new ThreadLocal&lt;&gt;();</span><br><span class="line">      InheritableThreadLocal&lt;String&gt; stringInheritable &#x3D; new InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 主线程赋对上面两个变量进行赋值</span><br><span class="line">      stringThreadLocal.set(&quot;this is threadLocal&quot;);</span><br><span class="line">      stringInheritable.set(&quot;this is inheritableThreadLocal&quot;);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建线程</span><br><span class="line">      Thread thread1 &#x3D; new Thread(()-&gt;&#123;</span><br><span class="line">         &#x2F;&#x2F; 获得ThreadLocal中存放的值</span><br><span class="line">         System.out.println(stringThreadLocal.get());</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 获得InheritableThreadLocal存放的值</span><br><span class="line">         System.out.println(stringInheritable.get());</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">this is inheritableThreadLocal </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>可以看出InheritableThreadLocal的值成功从主线程传入了子线程，而ThreadLocal则没有</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InheritableThreadLocal&lt;T&gt; extends ThreadLocal&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 传入父线程中的一个值，然后直接返回</span><br><span class="line">    protected T childValue(T parentValue) &#123;</span><br><span class="line">        return parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	&#x2F;&#x2F; 返回传入线程的inheritableThreadLocals</span><br><span class="line">    &#x2F;&#x2F; Thread中有一个inheritableThreadLocals变量</span><br><span class="line">    &#x2F;&#x2F; ThreadLocal.ThreadLocalMap inheritableThreadLocals &#x3D; null;</span><br><span class="line">    ThreadLocalMap getMap(Thread t) &#123;</span><br><span class="line">       return t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	&#x2F;&#x2F; 创建一个inheritableThreadLocals</span><br><span class="line">    void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">        t.inheritableThreadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>由如上代码可知，InheritableThreadLocal继承了ThreadLocal，并重写了三个方法。InheritableThreadLocal重写了<strong>createMap方法</strong>，那么现在当第一次调用set方法时，创建的是当前线程的inheritableThreadLocals变量的实例而不再是threadLocals。当调用<strong>getMap方法</strong>获取当前线程内部的map变量时，获取的是inheritableThreadLocals而不再是threadLocals</p>
<h4 id="childValue-T-parentValue-方法的调用"><a href="#childValue-T-parentValue-方法的调用" class="headerlink" title="childValue(T parentValue)方法的调用"></a>childValue(T parentValue)方法的调用</h4><p>在主函数运行时，会调用Thread的默认构造函数（<strong>创建主线程</strong>，也就是父线程），所以我们先看看Thread的默认构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public Thread() &#123;</span><br><span class="line">    init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);</span><br><span class="line">&#125;Copy</span><br><span class="line">private void init(ThreadGroup g, Runnable target, String name,</span><br><span class="line">                  long stackSize, AccessControlContext acc,</span><br><span class="line">                  boolean inheritThreadLocals) &#123;</span><br><span class="line">   	...</span><br><span class="line">        </span><br><span class="line">	&#x2F;&#x2F; 获得当前线程的，在这里是主线程</span><br><span class="line">    Thread parent &#x3D; currentThread();</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果父线程的inheritableThreadLocals存在</span><br><span class="line">    &#x2F;&#x2F; 我们在主线程中调用set和get时，会创建inheritableThreadLocals</span><br><span class="line">    if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals !&#x3D; null)</span><br><span class="line">        &#x2F;&#x2F; 设置子线程的inheritableThreadLocals</span><br><span class="line">        this.inheritableThreadLocals &#x3D;</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    </span><br><span class="line">    &#x2F;* Stash the specified stack size in case the VM cares *&#x2F;</span><br><span class="line">    this.stackSize &#x3D; stackSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Set thread ID *&#x2F;</span><br><span class="line">    tid &#x3D; nextThreadID();</span><br><span class="line">&#125;Copy</span><br><span class="line">static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    return new ThreadLocalMap(parentMap);</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在createInheritedMap内部使用父线程的inheritableThreadLocals变量作为构造函数创建了一个新的ThreadLocalMap变量，然后赋值给了子线程的inheritableThreadLocals变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private ThreadLocalMap(ThreadLocalMap parentMap) &#123;</span><br><span class="line">    Entry[] parentTable &#x3D; parentMap.table;</span><br><span class="line">    int len &#x3D; parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table &#x3D; new Entry[len];</span><br><span class="line"></span><br><span class="line">    for (int j &#x3D; 0; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e &#x3D; parentTable[j];</span><br><span class="line">        if (e !&#x3D; null) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">            ThreadLocal&lt;Object&gt; key &#x3D; (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            if (key !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里调用了 childValue 方法</span><br><span class="line">                &#x2F;&#x2F; 该方法会返回parent的值</span><br><span class="line">                Object value &#x3D; key.childValue(e.value);</span><br><span class="line">                </span><br><span class="line">                Entry c &#x3D; new Entry(key, value);</span><br><span class="line">                int h &#x3D; key.threadLocalHashCode &amp; (len - 1);</span><br><span class="line">                while (table[h] !&#x3D; null)</span><br><span class="line">                    h &#x3D; nextIndex(h, len);</span><br><span class="line">                table[h] &#x3D; c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在该构造函数内部把父线程的inheritableThreadLocals成员变量的值复制到新的ThreadLocalMap对象中</p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>InheritableThreadLocal类通过重写getMap和createMap，让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法设置变量时，就会创建当前线程的inheritableThreadLocals变量。</p>
<p><strong>当父线程创建子线程时，构造函数会把父线程中inheritableThreadLocals变量里面的本地变量复制一份保存到子线程的inheritableThreadLocals变量里面。</strong></p>
<h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p>
<p><strong>JMM体现在以下几个方面</strong></p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static Boolean run &#x3D; true;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt;&#123;</span><br><span class="line">			while (run) &#123;</span><br><span class="line">				&#x2F;&#x2F;如果run为真，则一直执行</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		System.out.println(&quot;改变run的值为false&quot;);</span><br><span class="line">		run &#x3D; false;</span><br><span class="line">	&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>为什么无法退出该循环</strong></p>
<ul>
<li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" alt="img"></a></p>
<ul>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" alt="img"></a></p>
<ul>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" alt="img"></a></p>
<p><strong>解决方法</strong></p>
<ul>
<li>使用<strong>volatile</strong>易变关键字</li>
<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用易变关键字</span><br><span class="line">volatile static Boolean run &#x3D; true;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">	new Thread(()-&gt;&#123;</span><br><span class="line">		while (run) &#123;</span><br><span class="line">			&#x2F;&#x2F;如果run为真，则一直执行</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;).start();</span><br><span class="line"></span><br><span class="line">	Thread.sleep(1000);</span><br><span class="line">	System.out.println(&quot;改变run的值为false&quot;);</span><br><span class="line">	run &#x3D; false;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p>
<ul>
<li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p>
</li>
<li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p>
</li>
<li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p>
<ul>
<li><p>因为使用了<strong>synchronized</strong>关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void println(String x) &#123;</span><br><span class="line">		&#x2F;&#x2F;使用了synchronized关键字</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            print(x);</span><br><span class="line">            newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否被终止了</span><br><span class="line">	private volatile boolean stop &#x3D; false;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">					if(stop) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						System.out.println(&quot;被打断了&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">        &#x2F;&#x2F;修改标记</span><br><span class="line">		stop &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong></p>
<p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong></p>
<ul>
<li>用一个标记来判断该任务是否已经被执行过了</li>
<li>需要避免线程安全问题<ul>
<li>加锁的代码块要尽量的小，以保证性能</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.nyima.day1;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author Chen Panwen</span><br><span class="line"> * @data 2020&#x2F;3&#x2F;26 16:11</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Test7 &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		Monitor monitor &#x3D; new Monitor();</span><br><span class="line">		monitor.start();</span><br><span class="line">		monitor.start();</span><br><span class="line">		Thread.sleep(3500);</span><br><span class="line">		monitor.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Monitor &#123;</span><br><span class="line"></span><br><span class="line">	Thread monitor;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否被终止了</span><br><span class="line">	private volatile boolean stop &#x3D; false;</span><br><span class="line">	&#x2F;&#x2F;设置标记，用于判断是否已经启动过了</span><br><span class="line">	private boolean starting &#x3D; false;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 启动监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		&#x2F;&#x2F;上锁，避免多线程运行时出现线程安全问题</span><br><span class="line">		synchronized (this) &#123;</span><br><span class="line">			if (starting) &#123;</span><br><span class="line">				&#x2F;&#x2F;已被启动，直接返回</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;启动监视器，改变标记</span><br><span class="line">			starting &#x3D; true;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;设置线控器线程，用于监控线程状态</span><br><span class="line">		monitor &#x3D; new Thread() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				&#x2F;&#x2F;开始不停的监控</span><br><span class="line">				while (true) &#123;</span><br><span class="line">					if(stop) &#123;</span><br><span class="line">						System.out.println(&quot;处理后续任务&quot;);</span><br><span class="line">						break;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(&quot;监控器运行中...&quot;);</span><br><span class="line">					try &#123;</span><br><span class="line">						&#x2F;&#x2F;线程休眠</span><br><span class="line">						Thread.sleep(1000);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						System.out.println(&quot;被打断了&quot;);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		monitor.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 	用于停止监控器线程</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		&#x2F;&#x2F;打断线程</span><br><span class="line">		monitor.interrupt();</span><br><span class="line">		stop &#x3D; true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul>
<li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" alt="img"></a></p>
<p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p>
<h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul>
<li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" alt="img"></a></p>
<ul>
<li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p>
</li>
<li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以重排的例子 </span><br><span class="line">int a &#x3D; 10; </span><br><span class="line">int b &#x3D; 20; </span><br><span class="line">System.out.println( a + b );</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不能重排的例子 </span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; a - 5; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" alt="img"></a></p>
<p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p>
<ul>
<li>禁止的是加volatile关键字变量之前的代码被重排序</li>
</ul>
<h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul>
<li>可见性<ul>
<li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中</li>
<li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据</li>
</ul>
</li>
<li>有序性<ul>
<li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后</li>
<li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li>
</ul>
</li>
</ul>
<h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令后会加入写屏障</li>
<li>对 volatile 变量的读指令前会加入读屏障</li>
</ul>
<h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul>
<li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" alt="img"></a></p>
</li>
<li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" alt="img"></a></p>
</li>
</ul>
<h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul>
<li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" alt="img"></a></p>
</li>
<li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" alt="img"></a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" alt="img"></a></p>
<p><strong>但是不能解决指令交错问题</strong></p>
<ul>
<li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去</li>
<li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li>
</ul>
<h3 id="实现原理之Lock前缀"><a href="#实现原理之Lock前缀" class="headerlink" title="实现原理之Lock前缀"></a>实现原理之Lock前缀</h3><p>在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance &#x3D; new Singleton(); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对应的汇编代码是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">... lock addl ... </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>有volatile变量修饰的共享变量进行写操作的时候会多出第二行汇编代码，通过查IA-32架构软件开发者手册可知，<strong>Lock前缀</strong>的指令在多核处理器下会引发了两件事</p>
<ul>
<li><p>Lock前缀指令会引起处理器</p>
<p>缓存回写到内存</p>
<ul>
<li>Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK #信号一般不锁总线，而是<strong>锁缓存</strong>，毕竟锁总线开销的比较大。使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，<strong>缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据</strong></li>
</ul>
</li>
<li><p>一个处理器的缓存回写到内存会</p>
<p>导致其他处理器的缓存无效</p>
<ul>
<li>在多核处理器系统中进行操作的时候，IA-32和Intel 64处理器能<strong>嗅探其他处理器访问系统内存和它们的内部缓存</strong>。处理器使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致</li>
</ul>
</li>
</ul>
<h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul>
<li><p>使用<strong>原子整数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger balance &#x3D; new AtomicInteger();Copy</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">interface Account &#123;</span><br><span class="line">	Integer getBalance();</span><br><span class="line"></span><br><span class="line">	void withdraw(Integer amount);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void demo(Account account) &#123;</span><br><span class="line">		List&lt;Thread&gt; ts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		long start &#x3D; System.nanoTime();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			ts.add(new Thread(() -&gt; &#123;</span><br><span class="line">				account.withdraw(10);</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		ts.forEach(Thread::start);</span><br><span class="line">		ts.forEach(t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		long end &#x3D; System.nanoTime();</span><br><span class="line">		System.out.println(account.getBalance() + &quot; cost: &quot; + (end - start) &#x2F; 1000_000 + &quot; ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程不安全的做法</span><br><span class="line">class AccountUnsafe implements Account &#123;</span><br><span class="line">	private Integer balance;</span><br><span class="line"></span><br><span class="line">	public AccountUnsafe(Integer balance) &#123;</span><br><span class="line">		this.balance &#x3D; balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Integer getBalance() &#123;</span><br><span class="line">		return this.balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized void withdraw(Integer amount) &#123;</span><br><span class="line">		balance -&#x3D; amount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Account.demo(new AccountUnsafe(10000));</span><br><span class="line">		Account.demo(new AccountCas(10000));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程安全的做法</span><br><span class="line">class AccountCas implements Account &#123;</span><br><span class="line">	&#x2F;&#x2F;使用原子整数</span><br><span class="line">	private AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">	public AccountCas(int balance) &#123;</span><br><span class="line">		this.balance &#x3D; new AtomicInteger(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Integer getBalance() &#123;</span><br><span class="line">		&#x2F;&#x2F;得到原子整数的值</span><br><span class="line">		return balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void withdraw(Integer amount) &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			&#x2F;&#x2F;获得修改前的值</span><br><span class="line">			int prev &#x3D; balance.get();</span><br><span class="line">			&#x2F;&#x2F;获得修改后的值</span><br><span class="line">			int next &#x3D; prev-amount;</span><br><span class="line">			&#x2F;&#x2F;比较并设值</span><br><span class="line">			if(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p>
<p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" alt="img"></a></p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul>
<li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul>
<li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li>
<li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</li>
<li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li>
</ul>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p>
<p><strong>注意</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">volatile 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性） </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果</p>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" alt="img"></a></p>
<p><strong>原因</strong></p>
<h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p>
<ul>
<li><p>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</p>
</li>
<li><p>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
</li>
<li><p>CAS 体现的是</p>
<p>无锁并发、无阻塞并发</p>
<p>，请仔细体会这两句话的意思</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
<p><strong>以 AtomicInteger 为例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> AtomicInteger i &#x3D; new AtomicInteger(0);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并自增（i &#x3D; 0, 结果 i &#x3D; 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 自增并获取（i &#x3D; 1, 结果 i &#x3D; 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 自减并获取（i &#x3D; 2, 结果 i &#x3D; 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并自减（i &#x3D; 1, 结果 i &#x3D; 0, 返回 1），类似于 i--</span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并加值（i &#x3D; 0, 结果 i &#x3D; 5, 返回 0） </span><br><span class="line">System.out.println(i.getAndAdd(5));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 加值并获取（i &#x3D; 5, 结果 i &#x3D; 0, 返回 0） </span><br><span class="line">System.out.println(i.addAndGet(-5));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并更新（i &#x3D; 0, p 为 i 的当前值, 结果 i &#x3D; -2, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - 2));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 更新并获取（i &#x3D; -2, p 为 i 的当前值, 结果 i &#x3D; 0, 返回 0）</span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 </span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + 2));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 获取并计算（i &#x3D; 0, p 为 i 的当前值, x 为参数1, 结果 i &#x3D; 10, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用 &#x2F;&#x2F; getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><br><span class="line">&#x2F;&#x2F; getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><br><span class="line">final System.out.println(i.getAndAccumulate(10, (p, x) -&gt; p + x));</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 计算并获取（i &#x3D; 10, p 为 i 的当前值, x 为参数1, 结果 i &#x3D; 0, 返回 0） </span><br><span class="line">&#x2F;&#x2F; 其中函数中的操作能保证原子，但函数需要无副作用</span><br><span class="line">System.out.println(i.accumulateAndGet(-10, (p, x) -&gt; p + x)); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public interface DecimalAccount &#123;</span><br><span class="line">	BigDecimal getBalance();</span><br><span class="line"></span><br><span class="line">	void withdraw(BigDecimal amount);</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作    </span><br><span class="line">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	static void demo(DecimalAccountImpl account) &#123;</span><br><span class="line">		List&lt;Thread&gt; ts &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		long start &#x3D; System.nanoTime();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">			ts.add(new Thread(() -&gt; &#123;</span><br><span class="line">				account.withdraw(BigDecimal.TEN);</span><br><span class="line">			&#125;));</span><br><span class="line">		&#125;</span><br><span class="line">		ts.forEach(Thread::start);</span><br><span class="line">		ts.forEach(t -&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				t.join();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		long end &#x3D; System.nanoTime();</span><br><span class="line">		System.out.println(account.getBalance() + &quot; cost: &quot; + (end - start) &#x2F; 1000_000 + &quot; ms&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DecimalAccountImpl implements DecimalAccount &#123;</span><br><span class="line">	&#x2F;&#x2F;原子引用，泛型类型为小数类型</span><br><span class="line">	AtomicReference&lt;BigDecimal&gt; balance;</span><br><span class="line"></span><br><span class="line">	public DecimalAccountImpl(BigDecimal balance) &#123;</span><br><span class="line">		this.balance &#x3D; new AtomicReference&lt;BigDecimal&gt;(balance);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public BigDecimal getBalance() &#123;</span><br><span class="line">		return balance.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void withdraw(BigDecimal amount) &#123;</span><br><span class="line">		while(true) &#123;</span><br><span class="line">			BigDecimal pre &#x3D; balance.get();</span><br><span class="line">			BigDecimal next &#x3D; pre.subtract(amount);</span><br><span class="line">			if(balance.compareAndSet(pre, next)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		DecimalAccount.demo(new DecimalAccountImpl(new BigDecimal(&quot;10000&quot;)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	static AtomicReference&lt;String&gt; str &#x3D; new AtomicReference&lt;&gt;(&quot;A&quot;);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.get();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C</span><br><span class="line">			System.out.println(&quot;change A-&gt;C &quot; + str.compareAndSet(pre, &quot;C&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change A-&gt;B &quot; + str.compareAndSet(&quot;A&quot;, &quot;B&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">		Thread.sleep(500);</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change B-&gt;A &quot; + str.compareAndSet(&quot;B&quot;, &quot;A&quot;));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" alt="img"></a></p>
<p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p>
<h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">	&#x2F;&#x2F;指定版本号</span><br><span class="line">	static AtomicStampedReference&lt;String&gt; str &#x3D; new AtomicStampedReference&lt;&gt;(&quot;A&quot;, 0);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.getReference();</span><br><span class="line">			&#x2F;&#x2F;获得版本号</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="line">			System.out.println(&quot;change A-&gt;C stamp &quot; + stamp + str.compareAndSet(pre, &quot;C&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change A-&gt;B stamp &quot; + stamp + str.compareAndSet(&quot;A&quot;, &quot;B&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">		Thread.sleep(500);</span><br><span class="line">		new Thread(()-&gt; &#123;</span><br><span class="line">			int stamp &#x3D; str.getStamp();</span><br><span class="line">			System.out.println(&quot;change B-&gt;A stamp &quot; + stamp +  str.compareAndSet(&quot;B&quot;, &quot;A&quot;, stamp, stamp+1));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" alt="img"></a></p>
<h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">	&#x2F;&#x2F;指定版本号</span><br><span class="line">	static AtomicMarkableReference&lt;String&gt; str &#x3D; new AtomicMarkableReference&lt;&gt;(&quot;A&quot;, true);</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			String pre &#x3D; str.getReference();</span><br><span class="line">			System.out.println(&quot;change&quot;);</span><br><span class="line">			try &#123;</span><br><span class="line">				other();</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			try &#123;</span><br><span class="line">				Thread.sleep(1000);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span><br><span class="line">			System.out.println(&quot;change A-&gt;C mark &quot; +  str.compareAndSet(pre, &quot;C&quot;, true, false));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static void other() throws InterruptedException &#123;</span><br><span class="line">		new Thread(() -&gt; &#123;</span><br><span class="line">			System.out.println(&quot;change A-&gt;A mark &quot; + str.compareAndSet(&quot;A&quot;, &quot;A&quot;, true, false));</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" alt="img"></a></p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ul>
<li><strong>AtomicStampedReference</strong> 需要我们传入<strong>整型变量</strong>作为版本号，来判定是否被更改过</li>
<li><strong>AtomicMarkableReference</strong>需要我们传入<strong>布尔变量</strong>作为标记，来判断是否被更改过</li>
</ul>
<h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<h3 id="lamba表达式的使用"><a href="#lamba表达式的使用" class="headerlink" title="lamba表达式的使用"></a>lamba表达式的使用</h3><ul>
<li>提供者<ul>
<li>无参又返回</li>
<li>()-&gt;返回结果</li>
</ul>
</li>
<li>方法<ul>
<li>有参有返回</li>
<li>(参数一…)-&gt;返回结果</li>
</ul>
</li>
<li>消费者<ul>
<li>有参无返回</li>
<li>(参数一…)-&gt;void</li>
</ul>
</li>
</ul>
<h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul>
<li>AtomicReferenceFieldUpdater // 域 字段</li>
<li>AtomicIntegerFieldUpdater</li>
<li>AtomicLongFieldUpdate</li>
</ul>
<p>原子更新器用于帮助我们改变某个对象中的某个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Student student &#x3D; new Student();</span><br><span class="line">       </span><br><span class="line">      &#x2F;&#x2F; 获得原子更新器</span><br><span class="line">      &#x2F;&#x2F; 泛型</span><br><span class="line">      &#x2F;&#x2F; 参数1 持有属性的类 参数2 被更新的属性的类</span><br><span class="line">      &#x2F;&#x2F; newUpdater中的参数：第三个为属性的名称</span><br><span class="line">      AtomicReferenceFieldUpdater&lt;Student, String&gt; updater &#x3D; AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, &quot;name&quot;);</span><br><span class="line">       </span><br><span class="line">      &#x2F;&#x2F; 修改</span><br><span class="line">      updater.compareAndSet(student, null, &quot;Nyima&quot;);</span><br><span class="line">      System.out.println(student);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student &#123;</span><br><span class="line">   volatile String name;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public String toString() &#123;</span><br><span class="line">      return &quot;Student&#123;&quot; +</span><br><span class="line">            &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">            &#39;&#125;&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="原子更新器初始化过程"><a href="#原子更新器初始化过程" class="headerlink" title="原子更新器初始化过程"></a>原子更新器初始化过程</h3><p>从上面的例子可以看出，原子更新器是通过newUpdater来获取实例的。其中传入了三个参数</p>
<ul>
<li>拥有属性的类的Class</li>
<li>属性的Class</li>
<li>属性的名称</li>
</ul>
<p>大概可以猜出来，<strong>初始化过程用到了反射</strong>，让我们看看源码来验证一下这个猜测。</p>
<h4 id="newUpdater方法"><a href="#newUpdater方法" class="headerlink" title="newUpdater方法"></a>newUpdater方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; newUpdater(Class&lt;U&gt; tclass,</span><br><span class="line">                                                                Class&lt;W&gt; vclass,</span><br><span class="line">                                                                String fieldName) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回了一个AtomicReferenceFieldUpdaterImpl实例</span><br><span class="line">    return new AtomicReferenceFieldUpdaterImpl&lt;U,W&gt;</span><br><span class="line">        (tclass, vclass, fieldName, Reflection.getCallerClass());</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>从newUpdater方法还并不能看出来具体的初始化过程</p>
<h4 id="内部实现类"><a href="#内部实现类" class="headerlink" title="内部实现类"></a>内部实现类</h4><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145006.png" alt="img"></a></p>
<p>AtomicReferenceFieldUpdater为抽象类，该类<strong>内部有一个自己的实现类AtomicReferenceFieldUpdaterImpl</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final class AtomicReferenceFieldUpdaterImpl&lt;T,V&gt;</span><br><span class="line">        extends AtomicReferenceFieldUpdater&lt;T,V&gt;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201020145119.png" alt="img"></a></p>
<p><strong>构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">AtomicReferenceFieldUpdaterImpl(final Class&lt;T&gt; tclass,</span><br><span class="line">                                final Class&lt;V&gt; vclass,</span><br><span class="line">                                final String fieldName,</span><br><span class="line">                                final Class&lt;?&gt; caller) &#123;</span><br><span class="line">    &#x2F;&#x2F; 用于保存要被修改的属性</span><br><span class="line">    final Field field;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 属性的Class</span><br><span class="line">    final Class&lt;?&gt; fieldClass;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; field的修饰符</span><br><span class="line">    final int modifiers;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 反射获得属性</span><br><span class="line">        field &#x3D; AccessController.doPrivileged(</span><br><span class="line">            new PrivilegedExceptionAction&lt;Field&gt;() &#123;</span><br><span class="line">                public Field run() throws NoSuchFieldException &#123;</span><br><span class="line">                    &#x2F;&#x2F; tclass为传入的属性的Class，可以通过它来获得属性</span><br><span class="line">                    return tclass.getDeclaredField(fieldName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得属性的修饰符，主要用于判断</span><br><span class="line">        &#x2F;&#x2F; 1、vclass 与 属性确切的类型是否匹配</span><br><span class="line">        &#x2F;&#x2F; 2、是否为引用类型</span><br><span class="line">        &#x2F;&#x2F; 3、被修改的属性是否加了volatile关键字</span><br><span class="line">        modifiers &#x3D; field.getModifiers();</span><br><span class="line">        sun.reflect.misc.ReflectUtil.ensureMemberAccess(</span><br><span class="line">            caller, tclass, null, modifiers);</span><br><span class="line">        ClassLoader cl &#x3D; tclass.getClassLoader();</span><br><span class="line">        ClassLoader ccl &#x3D; caller.getClassLoader();</span><br><span class="line">        if ((ccl !&#x3D; null) &amp;&amp; (ccl !&#x3D; cl) &amp;&amp;</span><br><span class="line">            ((cl &#x3D;&#x3D; null) || !isAncestor(cl, ccl))) &#123;</span><br><span class="line">            sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得属性类的Class</span><br><span class="line">        fieldClass &#x3D; field.getType();</span><br><span class="line">    &#125; catch (PrivilegedActionException pae) &#123;</span><br><span class="line">        throw new RuntimeException(pae.getException());</span><br><span class="line">    &#125; catch (Exception ex) &#123;</span><br><span class="line">        throw new RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (vclass !&#x3D; fieldClass)</span><br><span class="line">        throw new ClassCastException();</span><br><span class="line">    if (vclass.isPrimitive())</span><br><span class="line">        throw new IllegalArgumentException(&quot;Must be reference type&quot;);</span><br><span class="line"></span><br><span class="line">    if (!Modifier.isVolatile(modifiers))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Must be volatile type&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Access to protected field members is restricted to receivers only</span><br><span class="line">    &#x2F;&#x2F; of the accessing class, or one of its subclasses, and the</span><br><span class="line">    &#x2F;&#x2F; accessing class must in turn be a subclass (or package sibling)</span><br><span class="line">    &#x2F;&#x2F; of the protected member&#39;s defining class.</span><br><span class="line">    &#x2F;&#x2F; If the updater refers to a protected field of a declaring class</span><br><span class="line">    &#x2F;&#x2F; outside the current package, the receiver argument will be</span><br><span class="line">    &#x2F;&#x2F; narrowed to the type of the accessing class.</span><br><span class="line"> 	&#x2F;&#x2F; 对类中的属性进行初始化</span><br><span class="line">    this.cclass &#x3D; (Modifier.isProtected(modifiers) &amp;&amp;</span><br><span class="line">                   tclass.isAssignableFrom(caller) &amp;&amp;</span><br><span class="line">                   !isSamePackage(tclass, caller))</span><br><span class="line">                  ? caller : tclass;</span><br><span class="line">    this.tclass &#x3D; tclass;</span><br><span class="line">    this.vclass &#x3D; vclass;</span><br><span class="line">    &#x2F;&#x2F; 获得偏移量</span><br><span class="line">    this.offset &#x3D; U.objectFieldOffset(field);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>可以看出，原子引用更新器确实使用了反射</strong></p>
<h2 id="8、LongAdder原理"><a href="#8、LongAdder原理" class="headerlink" title="8、LongAdder原理"></a>8、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" alt="img"></a></p>
<p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" alt="img"></a></p>
<p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" alt="img"></a></p>
<p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p>
<ul>
<li>Core-0 要修改 Cell[0]</li>
<li>Core-1 要修改 Cell[1]</li>
</ul>
<p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p>
<p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p>
<p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" alt="img"></a></p>
<p><strong>累加主要调用以下方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void add(long x) &#123;</span><br><span class="line">       Cell[] as; long b, v; int m; Cell a;</span><br><span class="line">       if ((as &#x3D; cells) !&#x3D; null || !casBase(b &#x3D; base, b + x)) &#123;</span><br><span class="line">           boolean uncontended &#x3D; true;</span><br><span class="line">           if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||</span><br><span class="line">               (a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null ||</span><br><span class="line">               !(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)))</span><br><span class="line">               longAccumulate(x, null, uncontended);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>累加流程图</strong></p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" alt="img"></a></p>
<h2 id="9、Unsafe"><a href="#9、Unsafe" class="headerlink" title="9、Unsafe"></a>9、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class GetUnsafe &#123;</span><br><span class="line">	public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">		&#x2F;&#x2F; 通过反射获得Unsafe对象</span><br><span class="line">		Class unsafeClass &#x3D; Unsafe.class;</span><br><span class="line">		&#x2F;&#x2F; 获得构造函数，Unsafe的构造函数为私有的</span><br><span class="line">		Constructor constructor &#x3D; unsafeClass.getDeclaredConstructor();</span><br><span class="line">		&#x2F;&#x2F; 设置为允许访问私有内容</span><br><span class="line">		constructor.setAccessible(true);</span><br><span class="line">		&#x2F;&#x2F; 创建Unsafe对象</span><br><span class="line">		Unsafe unsafe &#x3D; (Unsafe) constructor.newInstance();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; 创建Person对象</span><br><span class="line">		Person person &#x3D; new Person();</span><br><span class="line">		&#x2F;&#x2F; 获得其属性 name 的偏移量</span><br><span class="line">		Field field &#x3D; Person.class.getDeclaredField(&quot;name&quot;);</span><br><span class="line">		long offset &#x3D; unsafe.objectFieldOffset(field);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 通过unsafe的CAS操作改变值</span><br><span class="line">		unsafe.compareAndSwapObject(person, offset, null, &quot;Nyima&quot;);</span><br><span class="line">		System.out.println(person);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    &#x2F;&#x2F; 配合CAS操作，必须用volatile修饰</span><br><span class="line"> 	volatile String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Person&#123;&quot; +</span><br><span class="line">				&quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line">				&#39;&#125;&#39;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p>
<h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    &#x2F;** The value is used for character storage. *&#x2F;</span><br><span class="line">    private final char value[];</span><br><span class="line"></span><br><span class="line">    &#x2F;** Cache the hash code for the string *&#x2F;</span><br><span class="line">    private int hash; &#x2F;&#x2F; Default to 0</span><br><span class="line">    </span><br><span class="line">   &#x2F;&#x2F;....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p>
<ul>
<li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li>
<li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li>
</ul>
<p>**保护性拷贝 **</p>
<p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String substring(int beginIndex) &#123;</span><br><span class="line">        if (beginIndex &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        int subLen &#x3D; value.length - beginIndex;</span><br><span class="line">        if (subLen &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(subLen);</span><br><span class="line">        &#125;</span><br><span class="line">    	&#x2F;&#x2F;返回的是一个新的对象</span><br><span class="line">        return (beginIndex &#x3D;&#x3D; 0) ? this : new String(value, beginIndex, subLen);</span><br><span class="line">    &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String(char value[], int offset, int count) &#123;</span><br><span class="line">        if (offset &lt; 0) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        if (count &lt;&#x3D; 0) &#123;</span><br><span class="line">            if (count &lt; 0) &#123;</span><br><span class="line">                throw new StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            if (offset &lt;&#x3D; value.length) &#123;</span><br><span class="line">                this.value &#x3D; &quot;&quot;.value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Note: offset or count might be near -1&gt;&gt;&gt;1.</span><br><span class="line">        if (offset &gt; value.length - count) &#123;</span><br><span class="line">            throw new StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        this.value &#x3D; Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">    &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p>
<h1 id="七、线程池"><a href="#七、线程池" class="headerlink" title="七、线程池"></a>七、线程池</h1><h2 id="1、自定义线程池"><a href="#1、自定义线程池" class="headerlink" title="1、自定义线程池"></a>1、自定义线程池</h2><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201021154837.png" alt="img"></a></p>
<ul>
<li>阻塞队列中维护了由主线程（或者其他线程）所产生的的任务</li>
<li>主线程类似于<strong>生产者</strong>，产生任务并放入阻塞队列中</li>
<li>线程池类似于<strong>消费者</strong>，得到阻塞队列中已有的任务并执行</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ThreadPool threadPool &#x3D; new ThreadPool(2,  TimeUnit.SECONDS, 1, 4);</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">         threadPool.execute(()-&gt;&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(10000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;任务正在执行!&quot;);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 自定义线程池</span><br><span class="line"> *&#x2F;</span><br><span class="line">class ThreadPool &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 自定义阻塞队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private BlockingQueue&lt;Runnable&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 核心线程数</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private int coreSize;</span><br><span class="line"></span><br><span class="line">   private HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 用于指定线程最大存活时间</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private TimeUnit timeUnit;</span><br><span class="line">   private long timeout;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 工作线程类</span><br><span class="line">    * 内部封装了Thread类，并且添加了一些属性</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private class Worker extends Thread &#123;</span><br><span class="line">      Runnable task;</span><br><span class="line"></span><br><span class="line">      public Worker(Runnable task) &#123;</span><br><span class="line">         System.out.println(&quot;初始化任务&quot;);</span><br><span class="line">         this.task &#x3D; task;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果有任务就执行</span><br><span class="line">         &#x2F;&#x2F; 如果阻塞队列中有任务，就继续执行</span><br><span class="line">         while (task !&#x3D; null || (task &#x3D; blockingQueue.take()) !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               System.out.println(&quot;执行任务&quot;);</span><br><span class="line">               task.run();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">               &#x2F;&#x2F; 任务执行完毕，设为空</span><br><span class="line">               System.out.println(&quot;任务执行完毕&quot;);</span><br><span class="line">               task &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 移除任务</span><br><span class="line">         synchronized (workers) &#123;</span><br><span class="line">            System.out.println(&quot;移除任务&quot;);</span><br><span class="line">            workers.remove(this);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public ThreadPool(int coreSize, TimeUnit timeUnit, long timeout, int capacity) &#123;</span><br><span class="line">      this.coreSize &#x3D; coreSize;</span><br><span class="line">      this.timeUnit &#x3D; timeUnit;</span><br><span class="line">      blockingQueue &#x3D; new BlockingQueue&lt;&gt;(capacity);</span><br><span class="line">      this.timeout &#x3D; timeout;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void execute(Runnable task) &#123;</span><br><span class="line">      synchronized (workers) &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建任务</span><br><span class="line">         &#x2F;&#x2F; 池中还有空余线程时，可以运行任务</span><br><span class="line">         &#x2F;&#x2F; 否则阻塞</span><br><span class="line">         if (workers.size() &lt; coreSize) &#123;</span><br><span class="line">            Worker worker &#x3D; new Worker(task);</span><br><span class="line">            workers.add(worker);</span><br><span class="line">            worker.start();</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;线程池中线程已用完，请稍等&quot;);</span><br><span class="line">            blockingQueue.put(task);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 阻塞队列</span><br><span class="line"> * 用于存放主线程或其他线程产生的任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">class BlockingQueue&lt;T&gt; &#123;</span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 阻塞队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private  Deque&lt;T&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 阻塞队列容量</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private int capacity;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 锁</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 条件队列</span><br><span class="line">    *&#x2F;</span><br><span class="line">   private Condition fullQueue;</span><br><span class="line">   private Condition emptyQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public BlockingQueue(int capacity) &#123;</span><br><span class="line">      blockingQueue &#x3D; new ArrayDeque&lt;&gt;(capacity);</span><br><span class="line">      lock &#x3D; new ReentrantLock();</span><br><span class="line">      fullQueue &#x3D; lock.newCondition();</span><br><span class="line">      emptyQueue &#x3D; lock.newCondition();</span><br><span class="line">      this.capacity &#x3D; capacity;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 获取任务的方法</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public T take() &#123;</span><br><span class="line">      &#x2F;&#x2F; 加锁</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果阻塞队列为空（没有任务），就一直等待</span><br><span class="line">         while (blockingQueue.isEmpty()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               emptyQueue.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; 获取任务并唤醒生产者线程</span><br><span class="line">         T task &#x3D; blockingQueue.removeFirst();</span><br><span class="line">         fullQueue.signalAll();</span><br><span class="line">         return task;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public T takeNanos(long timeout, TimeUnit unit) &#123;</span><br><span class="line">      &#x2F;&#x2F; 转换等待时间</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         long nanos &#x3D; unit.toNanos(timeout);</span><br><span class="line">         while (blockingQueue.isEmpty()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               &#x2F;&#x2F; awaitNanos会返回剩下的等待时间</span><br><span class="line">               nanos &#x3D; emptyQueue.awaitNanos(nanos);</span><br><span class="line">               if (nanos &lt; 0) &#123;</span><br><span class="line">                  return null;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         T task &#x3D; blockingQueue.removeFirst();</span><br><span class="line">         fullQueue.signalAll();</span><br><span class="line">         return task;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line">    * 放入任务的方法</span><br><span class="line">    * @param task 放入阻塞队列的任务</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void put(T task) &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         while (blockingQueue.size() &#x3D;&#x3D; capacity) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">               System.out.println(&quot;阻塞队列已满&quot;);</span><br><span class="line">               fullQueue.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         blockingQueue.add(task);</span><br><span class="line">         &#x2F;&#x2F; 唤醒等待的消费者</span><br><span class="line">         emptyQueue.signalAll();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public int getSize() &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      try &#123;</span><br><span class="line">         return blockingQueue.size();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>实现了一个简单的线程池</p>
<ul>
<li>阻塞队列BlockingQueue用于暂存来不及被线程执行的任务<ul>
<li>也可以说是平衡生产者和消费者执行速度上的差异</li>
<li>里面的获取任务和放入任务用到了<strong>生产者消费者模式</strong></li>
</ul>
</li>
<li>线程池中对线程Thread进行了再次的封装，封装为了Worker<ul>
<li>在调用任务的run方法时，线程会去执行该任务，执行完毕后还会<strong>到阻塞队列中获取新任务来执行</strong></li>
</ul>
</li>
<li>线程池中执行任务的主要方法为execute方法<ul>
<li>执行时要判断正在执行的线程数是否大于了线程池容量</li>
</ul>
</li>
</ul>
<h2 id="2、ThreadPoolExecutor"><a href="#2、ThreadPoolExecutor" class="headerlink" title="2、ThreadPoolExecutor"></a>2、ThreadPoolExecutor</h2><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022212832.png" alt="img"></a></p>
<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 线程池状态</span><br><span class="line">&#x2F;&#x2F; runState is stored in the high-order bits</span><br><span class="line">&#x2F;&#x2F; RUNNING 高3位为111</span><br><span class="line">private static final int RUNNING    &#x3D; -1 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; SHUTDOWN 高3位为000</span><br><span class="line">private static final int SHUTDOWN   &#x3D;  0 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 001</span><br><span class="line">private static final int STOP       &#x3D;  1 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 010</span><br><span class="line">private static final int TIDYING    &#x3D;  2 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 高3位 011</span><br><span class="line">private static final int TERMINATED &#x3D;  3 &lt;&lt; COUNT_BITS;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>状态名称</th>
<th>高3位的值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RUNNING</td>
<td>111</td>
<td>接收新任务，同时处理任务队列中的任务</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>000</td>
<td>不接受新任务，但是处理任务队列中的任务</td>
</tr>
<tr>
<td>STOP</td>
<td>001</td>
<td>中断正在执行的任务，同时抛弃阻塞队列中的任务</td>
</tr>
<tr>
<td>TIDYING</td>
<td>010</td>
<td>任务执行完毕，活动线程为0时，即将进入终结阶段</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>011</td>
<td>终结状态</td>
</tr>
</tbody></table>
<p>线程池状态和线程池中线程的数量<strong>由一个原子整型ctl来共同表示</strong></p>
<ul>
<li>使用一个数来表示两个值的主要原因是：<strong>可以通过一次CAS同时更改两个属性的值</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原子整数，前3位保存了线程池的状态，剩余位保存的是线程数量</span><br><span class="line">private final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 并不是所有平台的int都是32位。</span><br><span class="line">&#x2F;&#x2F; 去掉前三位保存线程状态的位数，剩下的用于保存线程数量</span><br><span class="line">&#x2F;&#x2F; 高3位为0，剩余位数全为1</span><br><span class="line">private static final int COUNT_BITS &#x3D; Integer.SIZE - 3;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2^COUNT_BITS次方，表示可以保存的最大线程数</span><br><span class="line">&#x2F;&#x2F; CAPACITY 的高3位为 0</span><br><span class="line">private static final int CAPACITY   &#x3D; (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>获取线程池状态、线程数量以及合并两个值的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Packing and unpacking ctl</span><br><span class="line">&#x2F;&#x2F; 获取运行状态</span><br><span class="line">&#x2F;&#x2F; 该操作会让除高3位以外的数全部变为0</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取运行线程数</span><br><span class="line">&#x2F;&#x2F; 该操作会让高3位为0</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计算ctl新值</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="线程池属性"><a href="#线程池属性" class="headerlink" title="线程池属性"></a>线程池属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 工作线程，内部封装了Thread</span><br><span class="line">private final class Worker</span><br><span class="line">        extends AbstractQueuedSynchronizer</span><br><span class="line">        implements Runnable &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 阻塞队列，用于存放来不及被核心线程执行的任务</span><br><span class="line">private final BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 锁</span><br><span class="line">private final ReentrantLock mainLock &#x3D; new ReentrantLock();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  用于存放核心线程的容器，只有当持有锁时才能够获取其中的元素（核心线程）</span><br><span class="line">private final HashSet&lt;Worker&gt; workers &#x3D; new HashSet&lt;Worker&gt;();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="构造方法极其参数"><a href="#构造方法极其参数" class="headerlink" title="构造方法极其参数"></a>构造方法极其参数</h3><p><strong>ThreadPoolExecutor最全面的构造方法</strong></p>
<p>也是构造自定义线程池的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                          int maximumPoolSize,</span><br><span class="line">                          long keepAliveTime,</span><br><span class="line">                          TimeUnit unit,</span><br><span class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                          ThreadFactory threadFactory,</span><br><span class="line">                          RejectedExecutionHandler handler)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a><strong>参数解释</strong></h4><ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数<ul>
<li>maximumPoolSize - corePoolSize = 救急线程数</li>
</ul>
</li>
<li>keepAliveTime：救急线程空闲时的最大生存时间</li>
<li>unit：时间单位</li>
<li>workQueue：阻塞队列（存放任务）<ul>
<li>有界阻塞队列 ArrayBlockingQueue</li>
<li>无界阻塞队列 LinkedBlockingQueue</li>
<li>最多只有一个同步元素的 SynchronousQueue</li>
<li>优先队列 PriorityBlockingQueue</li>
</ul>
</li>
<li>threadFactory：线程工厂（给线程取名字）</li>
<li>handler：拒绝策略</li>
</ul>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><ul>
<li>当一个任务传给线程池以后，可能有以下几种可能<ul>
<li>将任务分配给一个核心线程来执行</li>
<li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li>
<li>阻塞队列满了，使用救急线程来执行任务<ul>
<li>救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li>
</ul>
</li>
<li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li>
</ul>
</li>
</ul>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现</p>
<p><a target="_blank" rel="noopener" href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201022194718.png" alt="img"></a></p>
<ul>
<li>AbortPolicy：让调用者抛出 RejectedExecutionException 异常，<strong>这是默认策略</strong></li>
<li>CallerRunsPolicy：让调用者运行任务</li>
<li>DiscardPolicy：放弃本次任务</li>
<li>DiscardOldestPolicy：放弃队列中最早的任务，本任务取而代之</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br><span class="line">   static AtomicInteger threadId &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 手动创建线程池</span><br><span class="line">      &#x2F;&#x2F; 创建有界阻塞队列</span><br><span class="line">      ArrayBlockingQueue&lt;Runnable&gt; runnable &#x3D; new ArrayBlockingQueue&lt;Runnable&gt;(10);</span><br><span class="line">      &#x2F;&#x2F; 创建线程工厂</span><br><span class="line">      ThreadFactory threadFactory &#x3D; new ThreadFactory() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public Thread newThread(Runnable r) &#123;</span><br><span class="line">            Thread thread &#x3D; new Thread(r, &quot;working_thread_&quot;+threadId.getAndIncrement());</span><br><span class="line">            return thread;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 手动创建线程池</span><br><span class="line">      &#x2F;&#x2F; 拒绝策略采用默认策略</span><br><span class="line">      ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 7, 10, TimeUnit.SECONDS, runnable, threadFactory);</span><br><span class="line"></span><br><span class="line">      for (int i &#x3D; 0; i &lt; 20; i++) &#123;</span><br><span class="line">         executor.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">               System.out.println(Thread.currentThread());</span><br><span class="line">               try &#123;</span><br><span class="line">                  Thread.sleep(100000);</span><br><span class="line">               &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class TestFixedThreadPool &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      &#x2F;&#x2F; 自定义线程工厂</span><br><span class="line">      ThreadFactory factory &#x3D; new ThreadFactory() &#123;</span><br><span class="line">         AtomicInteger atomicInteger &#x3D; new AtomicInteger(1);</span><br><span class="line"></span><br><span class="line">         @Override</span><br><span class="line">         public Thread newThread(Runnable r) &#123;</span><br><span class="line">            return new Thread(r, &quot;myThread_&quot; + atomicInteger.getAndIncrement());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建核心线程数量为2的线程池</span><br><span class="line">      &#x2F;&#x2F; 通过 ThreadFactory可以给线程添加名字</span><br><span class="line"></span><br><span class="line">      ExecutorService executorService &#x3D; Executors.newFixedThreadPool(2, factory);</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 任务</span><br><span class="line">      Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(&quot;this is fixedThreadPool&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      executorService.execute(runnable);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>固定大小的线程池可以传入两个参数</p>
<ul>
<li>核心线程数：nThreads</li>
<li>线程工厂：threadFactory</li>
</ul>
<p>内部调用的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                              0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                              new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                              threadFactory);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>内部构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                              60L, TimeUnit.SECONDS,</span><br><span class="line">                              new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>没有核心线程，最大线程数为Integer.MAX_VALUE，<strong>所有创建的线程都是救急线程</strong>，空闲时生存时间为60秒</p>
</li>
<li><p>阻塞队列使用的是SynchronousQueue</p>
<ul>
<li><p>SynchronousQueue</p>
<p>是一种特殊的队列</p>
<ul>
<li><strong>没有容量</strong>，没有线程来取是放不进去的</li>
<li>只有当线程取任务时，才会将任务放入该阻塞队列中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="SingleThread"><a href="#SingleThread" class="headerlink" title="SingleThread"></a>SingleThread</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service &#x3D; Executors.newSingleThreadExecutor();</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>内部构造方法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new FinalizableDelegatedExecutorService</span><br><span class="line">    (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                            0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                            new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>内部调用了<strong>new ThreadPoolExecutor</strong>的构造方法，传入的corePoolSize和maximumPoolSize都为1。然后将该对象传给了FinalizableDelegatedExecutorService。该类修饰了ThreadPoolExecutor，让外部无法调用ThreadPoolExecutor内部的某些方法来修改所创建的线程池的大小。</p>
<h4 id="几个注意"><a href="#几个注意" class="headerlink" title="几个注意"></a>几个注意</h4><ul>
<li><p>SingleThread和自己创建一个线程来运行多个任务的区别</p>
<ul>
<li>当线程正在执行的任务发生错误时，如果是自己创建的线程，该任务和剩余的任务就无法再继续运行下去。而SingleThread会创建一个新线程，继续执行任务队列中剩余的任务。</li>
</ul>
</li>
<li><p>SingleThread和newFixedThreadPool(1)的区别</p>
<ul>
<li>newFixedThreadPool(1)传值为1，可以将FixedThreadPool强转为ThreadPoolExecutor，然后通过setCorePoolSize改变核心线程数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 强转为ThreadPoolExecutor</span><br><span class="line">ThreadPoolExecutor threadPool &#x3D; (ThreadPoolExecutor) Executors.newFixedThreadPool(1);</span><br><span class="line">&#x2F;&#x2F; 改变核心线程数</span><br><span class="line">threadPool.setCorePoolSize(2);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>而SingleThread无法修改核心线程数</li>
</ul>
</li>
</ul>
<h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute(Runnable command)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>传入一个Runnable对象，执行其中的run方法</p>
<p><strong>源码解析</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取ctl</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 判断当前启用的线程数是否小于核心线程数</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为该任务分配线程</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            &#x2F;&#x2F; 分配成功就返回</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 分配失败再次获取ctl</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 分配和信息线程失败以后</span><br><span class="line">    &#x2F;&#x2F; 如果池状态为RUNNING并且插入到任务队列成功</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 双重检测，可能在添加后线程池状态变为了非RUNNING</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果池状态为非RUNNING，则不会执行新来的任务</span><br><span class="line">        &#x2F;&#x2F; 将该任务从阻塞队列中移除</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            &#x2F;&#x2F; 调用拒绝策略，拒绝该任务的执行</span><br><span class="line">            reject(command);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果没有正在运行的线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            &#x2F;&#x2F; 就创建新线程来执行该任务</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果添加失败了（任务队列已满），就调用拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>其中调用了**addWoker()**方法，再看看看这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        int rs &#x3D; runStateOf(c);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Check if queue empty only if necessary.</span><br><span class="line">        &#x2F;&#x2F; 如果池状态为非RUNNING状态、线程池为SHUTDOWN且该任务为空 或者阻塞队列中已经有任务</span><br><span class="line">        if (rs &gt;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask &#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            &#x2F;&#x2F; 创建新线程失败</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            &#x2F;&#x2F; 获得当前工作线程数</span><br><span class="line">            int wc &#x3D; workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 参数中 core 为true</span><br><span class="line">            &#x2F;&#x2F; CAPACITY 为 1 &lt;&lt; COUNT_BITS-1，一般不会超过</span><br><span class="line">            &#x2F;&#x2F; 如果工作线程数大于了核心线程数，则创建失败</span><br><span class="line">            if (wc &gt;&#x3D; CAPACITY ||</span><br><span class="line">                wc &gt;&#x3D; (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            &#x2F;&#x2F; 通过CAS操作改变c的值</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                &#x2F;&#x2F; 更改成功就跳出多重循环，且不再运行循环</span><br><span class="line">                break retry;</span><br><span class="line">            &#x2F;&#x2F; 更改失败，重新获取ctl的值</span><br><span class="line">            c &#x3D; ctl.get();  &#x2F;&#x2F; Re-read ctl</span><br><span class="line">            if (runStateOf(c) !&#x3D; rs)</span><br><span class="line">                &#x2F;&#x2F; 跳出多重循环，且重新进入循环</span><br><span class="line">                continue retry;</span><br><span class="line">            &#x2F;&#x2F; else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于标记work中的任务是否成功执行</span><br><span class="line">    boolean workerStarted &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 用于标记worker是否成功加入了线程池中</span><br><span class="line">    boolean workerAdded &#x3D; false;</span><br><span class="line">    Worker w &#x3D; null;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建新线程来执行任务</span><br><span class="line">        w &#x3D; new Worker(firstTask);</span><br><span class="line">        final Thread t &#x3D; w.thread;</span><br><span class="line">        if (t !&#x3D; null) &#123;</span><br><span class="line">            final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">            &#x2F;&#x2F; 加锁</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; Recheck while holding lock.</span><br><span class="line">                &#x2F;&#x2F; Back out on ThreadFactory failure or if</span><br><span class="line">                &#x2F;&#x2F; shut down before lock acquired.</span><br><span class="line">                &#x2F;&#x2F; 加锁的同时再次检测</span><br><span class="line">                &#x2F;&#x2F; 避免在释放锁之前调用了shut down</span><br><span class="line">                int rs &#x3D; runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                if (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs &#x3D;&#x3D; SHUTDOWN &amp;&amp; firstTask &#x3D;&#x3D; null)) &#123;</span><br><span class="line">                    if (t.isAlive()) &#x2F;&#x2F; precheck that t is startable</span><br><span class="line">                        throw new IllegalThreadStateException();</span><br><span class="line">                    &#x2F;&#x2F; 将线程添加到线程池中</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    int s &#x3D; workers.size();</span><br><span class="line">                    if (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize &#x3D; s;</span><br><span class="line">                    &#x2F;&#x2F; 添加成功标志位变为true</span><br><span class="line">                    workerAdded &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 如果worker成功加入了线程池，就执行其中的任务</span><br><span class="line">            if (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                &#x2F;&#x2F; 启动成功</span><br><span class="line">                workerStarted &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果执行失败</span><br><span class="line">        if (! workerStarted)</span><br><span class="line">            &#x2F;&#x2F; 调用添加失败的函数</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    return workerStarted;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="submit-方法"><a href="#submit-方法" class="headerlink" title="submit()方法"></a>submit()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T&gt; submit(Callable&lt;T&gt; task) </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>传入一个Callable对象，用Future来<strong>捕获返回值</strong></p>
<p><strong>使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过submit执行Callable中的call方法</span><br><span class="line">&#x2F;&#x2F; 通过Future来捕获返回值</span><br><span class="line">Future&lt;String&gt; future &#x3D; threadPool.submit(new Callable&lt;String&gt;() &#123;</span><br><span class="line">   @Override</span><br><span class="line">   public String call() throws Exception &#123;</span><br><span class="line">      return &quot;hello submit&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看捕获的返回值</span><br><span class="line">System.out.println(future.get());</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 将线程池的状态改为 SHUTDOWN</span><br><span class="line">* 不再接受新任务，但是会将阻塞队列中的任务执行完</span><br><span class="line">*&#x2F;</span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 修改线程池状态为 SHUTDOWN</span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        </span><br><span class="line">  		&#x2F;&#x2F; 中断空闲线程（没有执行任务的线程）</span><br><span class="line">        &#x2F;&#x2F; Idle：空闲的</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 尝试终结，不一定成功</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;Copy</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 终结失败的条件</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为RUNNING</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为 RUNNING SHUTDOWN STOP （状态值大于TIDYING）</span><br><span class="line">        &#x2F;&#x2F; 线程池状态为SHUTDOWN，但阻塞队列中还有任务等待执行</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) &#x3D;&#x3D; SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果活跃线程数不为0</span><br><span class="line">        if (workerCountOf(c) !&#x3D; 0) &#123; &#x2F;&#x2F; Eligible to terminate</span><br><span class="line">            &#x2F;&#x2F; 中断空闲线程</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 处于可以终结的状态</span><br><span class="line">            &#x2F;&#x2F; 通过CAS将线程池状态改为TIDYING</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    &#x2F;&#x2F; 通过CAS将线程池状态改为TERMINATED</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 将线程池的状态改为 STOP</span><br><span class="line">* 不再接受新任务，也不会在执行阻塞队列中的任务</span><br><span class="line">* 会将阻塞队列中未执行的任务返回给调用者</span><br><span class="line">*&#x2F;</span><br><span class="line">public List&lt;Runnable&gt; shutdownNow() &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    final ReentrantLock mainLock &#x3D; this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 修改状态为STOP，不执行任何任务</span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 中断所有线程</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将未执行的任务从队列中移除，然后返回给调用者</span><br><span class="line">        tasks &#x3D; drainQueue();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 尝试终结，一定会成功，因为阻塞队列为空了</span><br><span class="line">    tryTerminate();</span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/18/juc%E5%AD%A6%E4%B9%A0/" data-id="cknmwaipm000aj4ub5yvl8f5c" data-title="juc学习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2021/04/07/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/04/18/juc%E5%AD%A6%E4%B9%A0/">juc学习</a>
          </li>
        
          <li>
            <a href="/2021/04/07/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%9B%86%E7%BE%A4%E4%B8%8E%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">redis集群与企业级解决方案</a>
          </li>
        
          <li>
            <a href="/2021/04/06/redis%E9%AB%98%E7%BA%A7/">redis高级</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>