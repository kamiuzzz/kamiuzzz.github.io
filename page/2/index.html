<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机网络总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:33:18.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/">计算机网络总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络总结"><a href="#计算机网络总结" class="headerlink" title="计算机网络总结"></a>计算机网络总结</h1><p>本复习总结完全参考教研室师姐（橘子姐）的笔记和JavaGuide总结[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:2">2]</a>以及少量的补充</p>
<h2 id="1-OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#1-OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="1. OSI与TCP/IP各层的结构与功能,都有哪些协议?"></a>1. OSI与TCP/IP各层的结构与功能,都有哪些协议?</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_1_network.png" alt="img"></a></p>
<h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><h4 id="1-1-1-应用层"><a href="#1-1-1-应用层" class="headerlink" title="1.1.1 应用层"></a>1.1.1 应用层</h4><blockquote>
<p><strong>应用层</strong>：直接为用户的应用进程提供网络服务。</p>
</blockquote>
<p><strong>应用层协议</strong>： 对于不同的网络应用需要不同的应用层协议。通俗的来讲就是应用层会借助TCP、UDP协议在各种各样的程序之间传递数据（邮件、文件等等）这时候像应用层协议就可以规定这些数据的格式要满足什么形式。</p>
<p>在互联网中应用层协议很多，如</p>
<ul>
<li>域名系统<strong>DNS</strong></li>
</ul>
<blockquote>
<p>域名系统DNS：</p>
<p>是因特网的一项核心服务，他作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，不用去记住能够背极其直接读取的IP数串。</p>
</blockquote>
<ul>
<li>支持万维网应用的 <strong>HTTP</strong>协议</li>
</ul>
<blockquote>
<p>HTTP协议:</p>
<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p>
</blockquote>
<ul>
<li>支持电子邮件的 <strong>SMTP</strong>协议</li>
<li>文件传输 <strong>FTP</strong>等等</li>
</ul>
<p>我们把应用层交互的数据单元称为报文。</p>
<h4 id="1-1-2-表示层"><a href="#1-1-2-表示层" class="headerlink" title="1.1.2 表示层"></a>1.1.2 表示层</h4><blockquote>
<p><strong>表示层</strong>：在满足用户需求的基础上，尽可能的节省传输费用而设置的，表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。</p>
</blockquote>
<p>表示层的<strong>数据转换</strong>包括:</p>
<ul>
<li>数据加密</li>
<li>数据压缩</li>
<li>数据格式转换等。</li>
</ul>
<p>比如传输压缩文件，jpeg或者加密文件等格式。</p>
<h4 id="1-1-3-会话层"><a href="#1-1-3-会话层" class="headerlink" title="1.1.3 会话层"></a>1.1.3 会话层</h4><blockquote>
<p>会话层：<strong>管理</strong>主机之间的<strong>会话进程</strong>，即负责建立、管理、终止进程之间的会话。</p>
</blockquote>
<h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><blockquote>
<p><strong>运输层</strong>：为应用进程之间提供端到端的逻辑通讯。</p>
</blockquote>
<h4 id="1-2-1-运输层协议⭐"><a href="#1-2-1-运输层协议⭐" class="headerlink" title="1.2.1 运输层协议⭐"></a>1.2.1 运输层协议⭐</h4><p><strong>运输层协议</strong>: IP协议是<strong>主机之间</strong>的通信，TCP和UDP是进程之间的通信。</p>
<ul>
<li><p>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）</p>
<p>提供面向连接的，可靠的数据传输服务</p>
<ul>
<li>客户端和服务器之间要保持一个会话直到传输结束</li>
<li>分段传输建立会话可靠传输流量控制（发送窗口大小根据接收窗口大小确定）</li>
<li>流量控制、拥塞控制，全双工</li>
<li>每一条TCP连接有两个端点（套接字：IP+端口号）</li>
</ul>
</li>
<li><p>用户数据协议 <strong>UDP</strong>（User Datagram Protocol）</p>
<p>提供无连接的，尽最大努力的数据传输服务</p>
<ul>
<li>不保证数据传输的可靠性</li>
<li>不分段</li>
<li>支持一对一，一对多，多对一通信</li>
</ul>
</li>
<li><p>TCP和UDP对比[见问题三](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/3.TCP/UDP">http://lihengxu.cn/2021/03/23/计网/3.TCP/UDP</a> 协议的区别⭐)</p>
</li>
</ul>
<h4 id="1-2-2-本层加端口号"><a href="#1-2-2-本层加端口号" class="headerlink" title="1.2.2 本层加端口号"></a>1.2.2 本层加端口号</h4><p>常见端口：</p>
<ul>
<li>FTP（文件传输协议）：20，21——其中20端口用于传输数据，21端口用于命令控制；</li>
<li>Telnet（远程登录协议）：23；</li>
<li>DNS（域名解析服务）：53；</li>
<li>TFTP（简单文件传输协议）：69；</li>
<li>HTTP（超文本传输协议）：80</li>
</ul>
<h4 id="1-2-3-传输层进行差错检测"><a href="#1-2-3-传输层进行差错检测" class="headerlink" title="1.2.3 传输层进行差错检测"></a>1.2.3 传输层进行差错检测</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_2_network.png" alt="img"></a></p>
<h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><blockquote>
<p><strong>网络层</strong>（网际层/IP层）：在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。(<strong>路径选择、路由及逻辑寻址</strong>)</p>
</blockquote>
<ul>
<li><p><strong>协议</strong>：ARP IP ICMP IGMP(ARP为IP提供服务，IP为ICMP和IGMP提供服务）</p>
<ul>
<li>由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 IP 数据报 ，简称<strong>数据报</strong></li>
<li>无论是哪一层的数据单元都可以笼统的用”分组“表示，主要不要混淆”用户数据包UDP“和网络层的”IP数据报“</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_3_network.png" alt="img"></a></p>
</li>
<li><p><strong>特点</strong>：网络层不管发的顺序也不管丢数据不（对方传输层负责），根据目标地址选择合适路径转发。</p>
</li>
<li><p><strong>本层加源IP地址与目标IP地址，构成IP数据报。</strong> <strong>IP协议非常简单，仅仅提供不可靠、无连接的传送服务</strong>。 IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p>
</li>
<li><p><strong>路由器工作在网络层</strong>，在不同网段转发数据。</p>
</li>
</ul>
<h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><blockquote>
<p>数据链路层：数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</p>
</blockquote>
<ul>
<li>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 <strong>IP 数据报组装成帧</strong>，进行传送。每一帧包括数据和必要的控制信息（同步信息，地址信息，差错控制等）。</li>
<li>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。</li>
<li>封装成帧（帧头、帧尾、物理地址、校验值） 透明传输（字节填充法，传输数据出现控制字符前面插入一个转义字符） 差错校验（循环冗余检验CRC）</li>
</ul>
<blockquote>
<p><strong>数据链路层协议</strong>(了解)：</p>
</blockquote>
<ul>
<li>PPP（点到点信道） （拨号电话线接入因特网就是PPP）</li>
<li>CSMA/CD(带冲突检测的载波监听多路访问协议）（使用广播信道）（局域网）</li>
<li>多路访问：多个设备可以同时访问介质（多个设备在同一信道发送信号协议），一个设备发送的帧也可以被多个设备接收。</li>
<li>载波监听：每一个设备发送数据前，对信道侦听，空闲才可以发送，如果有其他设备正在发暂时不发避免碰撞。</li>
<li>碰撞检测：设备边发数据边检测信道上电压大小，一旦出现碰撞，立即停止发送，等待一段时间后再发。 这个协议只能<strong>半双工</strong>通信。</li>
</ul>
<blockquote>
<p><strong>以太网</strong>（ 全球使用最广泛的局域网技术）拓扑结构为总线型</p>
</blockquote>
<p>以太网的标准<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91">拓扑</a>结构为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91">总线型拓扑</a>，但目前的快速以太网为了减少冲突，将能提高的网络速度和使用效率最大化，使用交换机来进行网络连接和组织。如此一来，以太网的拓扑结构就成了<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%98%9F%E5%9E%8B">星型</a>；但在逻辑上，以太网仍然使用总线型拓扑和<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CSMA%2FCD">CSMA/CD</a>（Carrier Sense Multiple Access/Collision Detection，即载波多重访问/碰撞侦测）的总线技术。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_4_network.png" alt="img"></a></p>
<blockquote>
<p>网桥交换机：网桥设备（可以连接集线器）</p>
</blockquote>
<p>网桥既有过滤帧的功能。当网桥收到一个帧的时候，并不是像所有接口发此帧，而是先检查此帧的目的MAC地址，然后再确定该帧转发到哪一个接口。</p>
<ul>
<li>网桥口越来越多了就变成了交换机（直接连计算机）</li>
<li>交换机前身为网桥</li>
<li>交换机口可以存储转发，基于MAC地址转发，通过学习构建MAC地址表</li>
</ul>
<p><strong>本层加MAC地址</strong></p>
<h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><blockquote>
<p>物理层：实现主机和网络之间的物理连接，规定一些与传输媒体接口有关的一些特性。</p>
</blockquote>
<ul>
<li>在物理层上传送比特流</li>
<li>频分复用，时分复用</li>
</ul>
<blockquote>
<p>集线器：多接口转发器，工作在物理层</p>
</blockquote>
<h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p>发送端：</p>
<ul>
<li><p>应用程序准备传输的文件</p>
</li>
<li><p>传输层 将文件分段 并编号</p>
</li>
<li><p>网络层 添加目标IP地址源IP地址</p>
</li>
<li><p>数据链路层 两种情况</p>
<p>使用自己的子网掩码 判断自己在那个网段</p>
<p>使用自己的子网掩码 判断目标地址在哪个网段</p>
<ul>
<li>如果是同一个网段 arp协议广播解析目标IP地址的MAC</li>
<li>如果不是同一个网段 则mac写网关地址</li>
</ul>
</li>
</ul>
<hr>
<p>一些帮助理解的解释：</p>
<ul>
<li><p>ARP发送的广播包，目标MAC是全1（48位），交换机会给所有出口转发。得到MAC地址后会缓存，过一段时间不和目标地址通信了，这个缓存会删除掉。</p>
</li>
<li><p>交换机根据mac地址转发数据</p>
</li>
<li><p>每个计算机配有网关（知道自己所在子网的路由网口地址）</p>
</li>
<li><p>点到点信道，物理层地址固定为FF（因为只能这个传给对方，不用看地址）</p>
</li>
<li><p>IP地址决定了数据的起点与终点，MAC地址决定了本点和下一跳给谁</p>
</li>
<li><p>集线器：</p>
<p>只负责把比特流传出去，并对信号进行加强，属于物理层设备（与网线差不多，只认比特流）</p>
</li>
<li><p>交换机（一个网段内转给其他计算机还是路由器）：</p>
<p>收完比特流，存储，看目标mac地址，选择出口，工作在第二层数据链路层设备，存储转发（只能看懂mac地址看不懂IP地址）</p>
</li>
<li><p>路由器：</p>
<p>有网卡（接口）接收比特流，可以看懂mac，判断是不是给自己，然后会把mac地址去掉，剩下IP数据报，根据数据报的目标地址按照路由表选择出口（路由器看不懂具体传的数据），出口写上新的MAC地址，为三层设备网络设备</p>
<p>路由器–网关–交换机三层结构：</p>
<p>知道IP地址，想知道具体是哪个物理PC机</p>
<ul>
<li>首先要通过IP地址的网段查找到是哪个网关的</li>
<li>然后在网关ARP表中查找mac地址和交换机位置</li>
<li>然后通过MAC表查找到物理PC机。</li>
<li>即IP地址-网关-MAC地址-交换机-port-PC机</li>
</ul>
<blockquote>
<p><strong>mac表</strong>：记录交换机接口（端口）和终端MAC的对应关系，即说明交换机哪个端口和终端的哪个MAC地址对应，指的是物理层面的连接关系，存在于交换机当中。</p>
<p><strong>ARP缓存表</strong>：记录主机的IP地址和MAC地址的对应关系，对于同一台PC机，IP地址是可变的，但是MAC地址是物理网卡的地址，是网卡特有的信息，是不可变的。这个缓存表一般不存在交换机里面，而是在交换机上一层的仪器中，即网关中。这个表里面只能知道IP地址和MAC的对应关系，以及在哪个交换机上连接着，并不能知道在交换机的哪个端口，需要和mac表相结合才能知道。</p>
<p><strong>路由表</strong>：记录路由器掌握的所有目的地网段，以及到达这些目的的最佳路径</p>
</blockquote>
</li>
<li><p>工作在哪一层指的最高能看懂那一层的内容</p>
</li>
<li><p>对方物理层收到比特流后，数据链路层看目标mac地址是给自己的，然后到网络层去掉mac地址剩下IP数据报，然后数据报把IP地址去掉（IP地址）给传输层，传输层排序检查丢包后给应用层</p>
</li>
</ul>
<hr>
<p>病毒是一个代码，也会分段传，路由器只能看到每一段所以中不了病毒，交换机以及集线器也不会</p>
<h3 id="1-7-TCP-IP协议有了解吗？"><a href="#1-7-TCP-IP协议有了解吗？" class="headerlink" title="1.7 TCP/IP协议有了解吗？"></a>1.7 TCP/IP协议有了解吗？</h3><p>TCP/IP 协议不是TCP 和IP 这两个协议的合称，而是指因特网整个TCP/IP 协议族，是一系列网络协议的总称。</p>
<p>TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为</p>
<ul>
<li><strong>应用层</strong></li>
<li><strong>传输层</strong></li>
<li><strong>网络层</strong></li>
<li><strong>链路层</strong></li>
</ul>
<h2 id="2-TCP-三次握手和四次挥手⭐"><a href="#2-TCP-三次握手和四次挥手⭐" class="headerlink" title="2. TCP 三次握手和四次挥手⭐"></a>2. TCP 三次握手和四次挥手⭐</h2><p>TCP协议是一种可靠的协议，在正式传输数据之前必须通过三次握手建立连接并且互相交换窗口大小。在传输结束之后，通过四次挥手来确认双方都结束数据交互。</p>
<h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><ul>
<li>第一次握手：主机A 发送syn＝1,随机产生seq=x(如1234567) 的数据包到服务器，主机B由SYN=1 知道，A 要求建立联机；</li>
<li>第二次握手： 主机B 收到请求后要确认联机信息， 向A 发送ack=( 主机A 的seq+1),syn=1,ack=1,随机产生seq=y(如7654321） 的包</li>
<li>第三次握手：主机A 收到后检查ack是否正确，即第一次发送的seq +1,以及位码ACK是否为1，若正确，主机A 会再发送ack =(主机B 的seq+1),ACK=1，主机B 收到后确认</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_5_network.png" alt="img"></a></p>
<p><strong>序列号</strong>：TCP缓存中字节流分数据段发，序号是这个数据段的第一个字节是整个文件的第几个字节（ 如果传输的数据字节为0，即只有首部，那序列号还增加吗？当syn 或 fin被置1，虽然报文里长度为0（应用层的数据叫报文），计算ack时我们可以认为其长度为1。其他情况（如只有ack）不增加）</p>
<p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的<strong>握手信号</strong>。</p>
<p><strong>确认号ack</strong>：根据收到的数据包的最后一个字节，给信号说下一个该发哪个字节了，这个确认号就是下一个该发得字节号</p>
<p><strong>ACK</strong>：0确认号无效，1确认号有效</p>
<blockquote>
<p>状态变化:</p>
<ul>
<li>客户端: Close-&gt;SYN_SENT-&gt;ESTABLISHED</li>
<li>服务端: Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED</li>
</ul>
</blockquote>
<h3 id="2-2-为什么要三次握手？"><a href="#2-2-为什么要三次握手？" class="headerlink" title="2.2 为什么要三次握手？"></a>2.2 为什么要三次握手？</h3><p>三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收是正常的。 <strong>核心思想</strong>：<strong>让双方都证实对方能发收</strong>。</p>
<ul>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h3 id="2-3-两次握手可以么？"><a href="#2-3-两次握手可以么？" class="headerlink" title="2.3 两次握手可以么？"></a>2.3 两次握手可以么？</h3><p>不可以</p>
<blockquote>
<p>假如只有前面两次握手，那么服务器在接收到第一次握手信号，发出第二次握手信号后就会开始工作。</p>
</blockquote>
<ol>
<li>服务器角度：可能客户端发送的第一次握手请求传输过程中阻塞，客户端会再次发送一个请求，这个时候服务器先后接收到两次请求，并持续等两个客户端请求发送数据，其实只有一个，服务端却有两个响应，极端情况可能N个，会造成资源浪费。</li>
<li>客户端角度：假如发送建立连接的请求阻塞，过了一段时间发现没回复，然后再发一个（这次很快到达），然后给确认也很快， 就开始发数据。过了一会第一个阻塞的建立连接的请求也到了，再给一个确认给A，结果A不认了，刚已经收到确认了，就不理了，然后B就得等着传数据（没收到数据过一段就释放了），会造成资源浪费，所以需要第三个数据包的确认</li>
</ol>
<h3 id="2-4-第2次握手传回了ACK，为什么还要传回SYN？"><a href="#2-4-第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="2.4 第2次握手传回了ACK，为什么还要传回SYN？"></a>2.4 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。</p>
<p>而回传SYN则是为了建立并确认从服务端到客户端的通信，还要客户端确认我的发送是否正常（SYN=1了ack才为seq+1）。</p>
<h3 id="2-5-四次挥手"><a href="#2-5-四次挥手" class="headerlink" title="2.5 四次挥手"></a>2.5 四次挥手</h3><ul>
<li>第一次：主机A 请求断开连接 发送FIN=1 seq=u后，进入终止等待状态1，</li>
<li>第二次： 服务端对客户端的请求应答：ACK=1,ack=u+1,seq=v，然后服务器B 就进入关闭等待状态，此时TCP 服务器进程就通知高层应用进程，因而从A 到B 的连接就释放了。此时是“半关闭”状态。即A 不可以发送给B，但是B 可以发送给A。</li>
<li>第三次：此时，若B 没有数据报要发送给A 了，其应用进程就通知TCP 释放连接， 服务端请求断开连接：FIN=1，ACK=1,seq=w,ack=u+1，并等待确认。</li>
<li>第四次： 客户端对服务端的请求应答： ACK=1，seq=u+1，ack=w+1，A 进入时间等待，注意，此时TCP 连接还没有释放掉，然后经过时间等待计时器设置的2MSL 后，A 才进入到关闭状态。</li>
</ul>
<p>（FIN：finish）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_6_network.png" alt="img"></a></p>
<blockquote>
<p>状态变化：</p>
<p>客户端：ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p>
<p>服务端：ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p>
</blockquote>
<h3 id="2-7-为什么要四次挥手？"><a href="#2-7-为什么要四次挥手？" class="headerlink" title="2.7 为什么要四次挥手？"></a>2.7 为什么要四次挥手？</h3><p>我们可以看出服务端响应断开连接的请求时，其<strong>ACK和FIN包并不是一起发送给客户端的</strong>，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<h3 id="2-8-四次挥手主动方为什么需要等待2MSL"><a href="#2-8-四次挥手主动方为什么需要等待2MSL" class="headerlink" title="2.8 四次挥手主动方为什么需要等待2MSL?"></a>2.8 四次挥手主动方为什么需要等待2MSL?</h3><p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p>
<blockquote>
<p>MSL（Maximum Segment Lifetime）：</p>
<p>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。（ 去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)=2MSL）</p>
</blockquote>
<p>Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了， 主动关闭方需要等待2MSL是为了，<strong>防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号</strong>。（若重发的又没到，客户端就关闭了，server最后就会异常关闭连接，把链接错误问题报告给高层）</p>
<h3 id="2-9-已经建立连接，但客户端故障怎么办？"><a href="#2-9-已经建立连接，但客户端故障怎么办？" class="headerlink" title="2.9 已经建立连接，但客户端故障怎么办？"></a>2.9 已经建立连接，但客户端故障怎么办？</h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。</p>
<p>服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是<strong>设置为2小时</strong>，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75</strong>秒发送一次。若一连发送<strong>10个探测报文</strong>仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="3-TCP-UDP-协议的区别⭐"><a href="#3-TCP-UDP-协议的区别⭐" class="headerlink" title="3.TCP/UDP 协议的区别⭐"></a>3.TCP/UDP 协议的区别⭐</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_7_network.png" alt="img"></a></p>
<ul>
<li>TCP协议进行数据通信之前需要<strong>三次握手建立连接</strong>，UDP协议不需要建立连接即可发送数据。</li>
<li>TCP有<strong>确认</strong>机制，丢包可以重发，保证数据的正确性；UDP不保证正确性，只是单纯的负责发送数据包。<strong>传输可靠性</strong>区别</li>
<li>TCP协议可能会对大数据包进行拆分，并且在接收方进行重组数据包操作；UDP协议是面向报文的，不会进行分片和重组，所以需要注意传输的报文大小。</li>
<li>网络包中的TCP头部为20个字节；UDP头部只有8个字节。</li>
</ul>
<blockquote>
<p>UDP（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播、屏幕广播、DNS、多播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
</blockquote>
<h3 id="3-1-一个网络数据包包括哪些有了解吗？"><a href="#3-1-一个网络数据包包括哪些有了解吗？" class="headerlink" title="3.1 一个网络数据包包括哪些有了解吗？"></a>3.1 一个网络数据包包括哪些有了解吗？</h3><p>网络数据包一般包括头部和数据部分，在TCP协议中，要发送的数据经过TCP模块添加TCP头部；然后IP模块添加IP头部和MAC头部（链路层）；然后在最前面加上报头/起始帧分界符以及末尾假如FCS（帧校验序列），这样就构成了一个完成的数据包。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_8_network.png" alt="img"></a></p>
<h3 id="3-2-每一层的数据叫什么名字？"><a href="#3-2-每一层的数据叫什么名字？" class="headerlink" title="3.2 每一层的数据叫什么名字？"></a>3.2 每一层的数据叫什么名字？</h3><p>我们把应用层交互的数据单元称为报文</p>
<p>传输层：TCP叫报文段，UDP叫用户数据报</p>
<p>网络层：把运输层的报文段或者用户数据报封装成分组或者包，也叫IP数据报（数据报）</p>
<p>链路层：帧</p>
<p>物理层：比特流</p>
<h3 id="3-3-TCP协议中的数据包分片与重组功能有了解吗？"><a href="#3-3-TCP协议中的数据包分片与重组功能有了解吗？" class="headerlink" title="3.3 TCP协议中的数据包分片与重组功能有了解吗？"></a>3.3 TCP协议中的数据包分片与重组功能有了解吗？</h3><p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。</p>
<ul>
<li><p>发送方：</p>
<p>将数据包分为多个<strong>TCP头部+数据包</strong>的组合，TCP头部中存着不同的<strong>数据序号</strong>；之后将多个组合交由IP模块，<strong>统一添加IP头部和MAC头部</strong>，IP头部的<strong>ID号</strong>设为统一的。</p>
</li>
<li><p>接收方：</p>
<p>IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在<strong>IP头部</strong>的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中<strong>具有相同ID的包</strong>全部到达。此外，IP头部还有一个<strong>分片偏移量</strong>的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。</p>
</li>
</ul>
<blockquote>
<p>链路层MTU(Maximum Transmission Unit)：每一种物理网络都会规定链路层数据帧的最大长度。IP协议在传输数据包时，若IP数据报加上数据帧头部后长度大于MTU，则将数据报文分为若干分片进行传输，并在目标系统中进行重组。</p>
</blockquote>
<blockquote>
<p>MSS：是TCP数据包每次能够传输的最大报文分段。</p>
</blockquote>
<h3 id="3-4-TCP粘包"><a href="#3-4-TCP粘包" class="headerlink" title="3.4 TCP粘包"></a>3.4 TCP粘包</h3><p>TCP粘包是指一种发送方发送的数据包在接收方的缓冲区中粘成了一包，也就是出现了数据包首尾相接的现象。</p>
<ul>
<li>产生原因：主要是发送方使用了Nagle算法，或者接收方的处理速度小于数据包的接收速度，导致接收缓冲区中消息堆积。</li>
<li>解决方法：可以通过关闭Nagle算法或者规定每个数据包的具体格式和长度，在接收方的应用层来进行判断</li>
</ul>
<p>还有UDP是不会产生粘包现象的，因为数据包之间具有明确的消息保护边界。</p>
<h2 id="4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）"><a href="#4-TCP-协议如何保证可靠传输（如何用UDP实现可靠传输）" class="headerlink" title="4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）"></a>4. TCP 协议如何保证可靠传输（如何用UDP实现可靠传输）</h2><ul>
<li><p><strong>确认</strong>：</p>
<p>TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储哪些已发送但是未收到确认的报文段，以便重传。</p>
<p>TCP默认使用<strong>累计确认</strong>，即接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，对<strong>按序</strong>到达的最后一个分组发送确认（中间没到的可能丢了也可能阻塞还没到），这就表示到这个分组为止的所有分组都已经正确收到了。（但是不会立即发送这个确认号的数据包，因为其有可能只是阻塞了还能到，会等到这个报文段设置的重传时间到了还没收到确认就重传）</p>
</li>
<li><p><strong>重传：</strong>两种事件会导致TCP对报文段的重传：超时和冗余ACK。</p>
<ul>
<li>超时：TCP每发送一个报文段，就对这个报文段设置一次计时器，计时器设置的重传时间到期但还未收到确认，就重传。</li>
<li>冗余ACK：超时触发重传的周期往往太长。TCP规定每当比期望序号更大的失序报文段到达时，就发送一个冗余ACK（再次确认某个报文段的ACK，之前已经收到过），TCP规定当发送方接收到对同一报文段的3个冗余ACK时，可以认为这个报文段已经丢失，立即执行重传，也称<strong>快速重传</strong>。</li>
</ul>
</li>
<li><p><strong>序列号</strong>：TCP 给 每个字节的数据都进行了编号，即序列号。</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答， 也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发（对丢包的会重传）。接收方根据编号会丢弃重复编号的数据（如超时重传中若是因为应答信号丢失，则会再传重复的数据），把有序数据传送给应用层。</p>
</li>
<li><p><strong>校验和</strong>： 目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
</ul>
<blockquote>
<p>校验和的计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。</p>
<p>发送方：在发送数据之前计算检验和，并进行校验和的填充。</p>
<p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_9_network.png" alt="img"></a></p>
<blockquote>
<p>如果接收方比对校验和与发送方不一致，数据一定传输有误。</p>
<p>如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
</blockquote>
<p>此外，TCP协议还通过</p>
<ul>
<li>流量控制</li>
<li>拥塞控制</li>
<li>ARQ协议</li>
</ul>
<p>保证传输的可靠性。</p>
<h3 id="4-1-TCP-流量控制"><a href="#4-1-TCP-流量控制" class="headerlink" title="4.1 TCP 流量控制"></a>4.1 TCP 流量控制</h3><p>TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。</p>
<p>TCP 利用滑动窗口实现流量控制，在三次握手阶段，双方互相将自己的<strong>数据接收缓冲池大小</strong>告诉对方。 <strong>接收方有即时窗口</strong>（滑动窗口）， 窗口大小的内容 实际上是接收端接收数据缓冲区的剩余大小，而且接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。 发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度， 如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p>
<p>那么<strong>发送方</strong>就可以维护一个称为<strong>接收窗口</strong>的变量实现流量控制。</p>
<h3 id="4-2-TCP-拥塞控制"><a href="#4-2-TCP-拥塞控制" class="headerlink" title="4.2 TCP 拥塞控制"></a>4.2 TCP 拥塞控制</h3><p>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p>发送方维持一个拥塞窗口cwnd的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且动态变化，只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<blockquote>
<p>发送窗口的上限为接收窗口和拥塞窗口中较小的一个。</p>
</blockquote>
<p><strong>拥塞控制与流量控制的区别：</strong></p>
<ul>
<li>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</li>
<li>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
</ul>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1（最大一个报文段的长度），每经过一个传播轮次（即往返时间），cwnd加倍，指数型增长，一直到规定的慢开始门限，然后改用拥塞避免算法。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1，按照线性增长。（即加法增大）。当出现一次超时（网络拥塞时）。令慢开始门限为当前cwnd的一半，cwnd重置为1，执行慢开始算法（即乘法减小）</li>
<li><strong>快重传与快恢复FRR：</strong><ul>
<li>快重传：使用冗余ACK来检测丢包的发生。冗余ACK也用于网络拥塞的检测（丢包当然意味着网络可能出现了拥塞）。</li>
<li>快恢复：收到三个冗余ACK，执行乘法减小，把慢开始门限减为当前cwnd的一半，但是cwnd不置为1，置为新的慢开始门限值（即减半），然后执行加法增大。由于跳过了cwnd从1开始的慢开始过程所以称为快恢复。</li>
</ul>
</li>
</ul>
<p><strong>小结</strong>：当发送方检测到超时的时候，采用慢开始+拥塞避免，当发送方接收到冗余ACK时，采用快重传+快恢复</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_10_network.png" alt="img"></a></p>
<h3 id="4-3-ARQ协议"><a href="#4-3-ARQ协议" class="headerlink" title="4.3 ARQ协议"></a>4.3 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中<strong>数据链路层和传输层</strong>的错误纠正协议之一。使用了<strong>确认和超时</strong>的两个机制。</p>
<p>ARQ包括：</p>
<ul>
<li>停止等待ARQ协议</li>
<li>连续ARQ协议。</li>
</ul>
<blockquote>
<p>停止等待ARQ协议</p>
</blockquote>
<ul>
<li><p>停止等待协议：每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
</li>
<li><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</p>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点： 简单</li>
<li>缺点： 信道利用率低，等待时间长</li>
</ul>
</li>
<li><p>几种具体情况：</p>
<ul>
<li><p>无差错情况:</p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
</li>
<li><p>出现差错情况（超时重传）:</p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
</li>
<li><p>确认丢失和确认迟到</p>
<ul>
<li>确认丢失 ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
<li>确认迟到 ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>连续 ARQ 协议</p>
</blockquote>
<p>可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，也就是说接受方不必对接收到的每一个分组都进行确认，而是对按序到达的最后一个分组进行确认（过一段时间确认一次，发送方其实是按照顺序发送的，可能由于网络原因，包到达的顺序不一致），而发送方每接收到一个确认，窗口就向前滑动一定距离。</p>
<ul>
<li>优缺点：<ul>
<li>优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li>缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</li>
</ul>
<h2 id="5-在浏览器中输入url地址-—-gt-显示主页的过程"><a href="#5-在浏览器中输入url地址-—-gt-显示主页的过程" class="headerlink" title="5. 在浏览器中输入url地址 —&gt; 显示主页的过程"></a>5. 在浏览器中输入url地址 —&gt; 显示主页的过程</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_11_network.png" alt="img"></a></p>
<blockquote>
<p>上图有一个错误，请注意，是OSPF不是OPSF。</p>
<p>OSPF（Open Shortest Path Fitst）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li><p><strong>DNS解析</strong></p>
<blockquote>
<p>域名解释：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>.</p>
</blockquote>
<ul>
<li>以最右边英文.开始，称为域名的根：注意最后一个com的后面有点这个就是根，实际用的时候最后加不加点都行</li>
<li>.下面这个名称就为顶级域名，代表服务器/网站的性质：<ul>
<li>com（商业性质）</li>
<li>edu（教育性质）</li>
<li>net（提供信息）</li>
<li>cn（中国）</li>
<li>org（组织）</li>
<li>gov（政府部门）</li>
</ul>
</li>
<li>二级域名：自己申请，比如baidu 完全限定域名：FQDN，比如<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>（后面的<a target="_blank" rel="noopener" href="http://baidu.com/">baidu.com</a>已经全球唯一）</li>
<li>三级域名：<a target="_blank" rel="noopener" href="http://kkk.baidu.com/">kkk.baidu.com</a>的kkk就是第三级，也可以四级五级。一般网站习惯用www，也有<a target="_blank" rel="noopener" href="http://mail.baidu.com/">mail.baidu.com</a>,也可以<a target="_blank" rel="noopener" href="http://wwww.baidu.com/">wwww.baidu.com</a>代表一个域名下的不同服务器，只要对应的IP配正确就可以 谷歌公司的DNS服务器0.0.0.0 电信公司的DNS服务器222.222.222.222）</li>
</ul>
<blockquote>
<p>客户端浏览器通过DNS解析到域名的IP地址。</p>
</blockquote>
<p>域名解析的过程：</p>
<ul>
<li><p>迭代查询：</p>
<p>首先在本地域名服务器中查询IP地址，如果没有找到，本地域名服务器向根域名服务器发送请求, 根DNS服务器，不负责具体的域名解析，但是他知道负责解析顶级域名的服务器IP（知道哪个DNS服务器负责哪一块的域名解析），会返回这个IP。本地域名服务器收到这个IP后，联系负责解析该顶级域名的服务器，这个顶级域名的服务器如果自己无法解析就找管理这个二级域名解析的服务器IP地址给本地域名服务器，然后本地域名服务器就去联系这个服务器直到解析成功为止，并把这个IP缓存到本地，供下次查询使用。</p>
</li>
<li><p>转发查询：（递归）</p>
<p>DNS 服务器可使用其自身的资源记录信息缓存来应答查询，也可代表请求客户机来查询或联系其他 DNS 服务器，以完全解析该名称，并随后将应答返回至客户机。这个过程称为递归。</p>
<p>若有多个合适的服务器，DNS服务器可以返回一个跟用户最接近的点的IP地址给用户。（DNS负载均衡）</p>
</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong></p>
<p>在拿到域名对应的IP地址后，会以随机端口（1024~~65535）向WEB服务器程序80端口发起TCP的连接请求，对于客户端与服务器的TCP链接，必然要说的就是三次握手。</p>
</li>
<li><p><strong>浏览器向WEB服务器发起Http请求</strong></p>
<p>建立TCP连接之后，发起HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口（HTTP80端口）</p>
<ul>
<li><strong>传输层</strong> 把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。</li>
<li><strong>网络层：</strong>添加源IP和目标IP。</li>
<li><strong>链路层：</strong>客户端的链路层，发送ARP请求查找下一跳MAC，跨网段是网关的MAC</li>
<li>HTTP请求报文由三部分组成：<ul>
<li>请求行（ 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD）</li>
<li>请求头（ HTTP请求头中可以看到当前请求支持的语言，压缩格式，编码格式以及何种类型的返回文件，Connection以及Cookie，Content-Type等信息）</li>
<li>请求正文（ 当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>服务器端处理请求并返回HTTP报文</strong></p>
<ul>
<li>服务器端收到请求后的由web服务器（如 Tomcat）处理请求。web服务器解析用户请求，知道了需要调度哪些资源文件，再通过相应的这些资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</li>
<li>HTTP响应报文也是由三部分组成:<ul>
<li>状态码（[如下述问题](<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/7">http://lihengxu.cn/2021/03/23/计网/7</a>. 常见HTTP状态码)）</li>
<li>响应报头</li>
<li>响应报文（ 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>浏览器解析渲染页面</strong></p>
<p>浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
</li>
<li><p><strong>关闭TCP链接</strong></p>
<p>四次挥手</p>
</li>
</ol>
<h2 id="6-Get和Post区别"><a href="#6-Get和Post区别" class="headerlink" title="6. Get和Post区别"></a>6. Get和Post区别</h2><ul>
<li>Get一般是从服务器上请求数据，Post一般是向服务器传送数据。</li>
<li>GET请求也可传参到后台，但是其参数在浏览器的地址栏的url中可见，所以隐私性安全性较差，且参数长度也是有限制的。 POST请求传递参数放在Request body中，不会在url中显示，比GET要安全，且参数长度无限制。</li>
<li>GET请求刷新浏览器或回退时没有影响，POST回退时会重新提交数据请求。</li>
<li>GET 请求可被浏览器主动缓存， POST 请求不会除非手动设置 GET 请求保留在浏览器历史记录中， 可被收藏为书签； POST 请求不会保留在浏览器历史记录中， POST 不能被收藏为书签</li>
<li>GET 只接受ASCII字符， POST支持多种编码方式</li>
<li>GET产生一个TCP数据包， 浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；POST产生两个TCP数据包， 浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）（ 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次）。</li>
</ul>
<blockquote>
<p>HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议， HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</p>
</blockquote>
<h2 id="7-常见HTTP状态码"><a href="#7-常见HTTP状态码" class="headerlink" title="7. 常见HTTP状态码"></a>7. 常见HTTP状态码</h2><p>1xx：表示通知信息，例如表示收到或者是正在处理（临时响应）</p>
<p>2xx：表示成功，例如表示接受或知道了</p>
<p>3xx：表示重定向，例如表示完成请求还需要采取进一步的行动</p>
<p>4xx：表示客户端的差错，例如表示请求中有语法错误或不能完成</p>
<p>5xx：表示服务器端的差错：例如表示服务器失效无法完成请求</p>
<h2 id="8-HTTP协议和各种协议的关系"><a href="#8-HTTP协议和各种协议的关系" class="headerlink" title="8. HTTP协议和各种协议的关系"></a>8. HTTP协议和各种协议的关系</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_12_network.png" alt="img"></a></p>
<h2 id="9-HTTP长连接-短连接"><a href="#9-HTTP长连接-短连接" class="headerlink" title="9. HTTP长连接,短连接"></a>9. HTTP长连接,短连接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">《HTTP长连接、短连接究竟是什么？》</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fn:3">3]</a></p>
<p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<blockquote>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
</blockquote>
<p>长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损。</p>
<p>短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。</p>
<ul>
<li><p>使用场景：</p>
<ul>
<li><strong>短链接</strong>：像WEB网站的http服务一般都用短链接</li>
</ul>
<p>原因：长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<ul>
<li><strong>长连接</strong>：多用于操作频繁，点对点的通讯，而且连接数不能太多情况</li>
</ul>
</li>
</ul>
<h2 id="10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）"><a href="#10-HTTP是不保存状态的协议-如何保存用户状态-（Cookie和Session）" class="headerlink" title="10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）"></a>10. HTTP是不保存状态的协议,如何保存用户状态?（Cookie和Session）</h2><p>HTTP 是一种不保存状态，即无状态协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>我们可以使用cookie和session来保持会话状态，</p>
<ul>
<li>会话：一次会话中包含多次请求和响应</li>
<li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。</li>
</ul>
<blockquote>
<p>cookie和session功能就是在一次会话的范围内的多次请求间，共享数据。</p>
</blockquote>
<ul>
<li>客户端会话技术：Cookie，将数据保存到客户端浏览器（cookie一般用于存出少量的不太敏感的数据或是在不登录的情况下，完成服务器对客户端的身份识别）；</li>
<li>服务器端会话技术：Session，将数据保存在服务器端的对象中，Session的实现是依赖于Cookie的。用户发起请求，服务端收到请求处理后可以生成一个sessionId，并且将sessionId存入cookie中返回给客户端，将session的内容存储在服务器上。在下一次的请求中，客户端带着cookie来请求服务器，服务端从cookie中取出sessionId，实现了用户会话状态的保持。这样做有一个缺点就是将一些东西存在了服务器上，在用户量较大的情况下，服务器容量会不足。</li>
</ul>
<p>实际情况中，经常是将所需要的会话状态，比如说登录态直接存入cookie并且返回给客户端，下次请求时，服务端直接取出cookie中的信息和参数信息进行比较，保持HTTP会话状态。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。</p>
<blockquote>
<p>Cookie 被禁用怎么办?</p>
</blockquote>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p>
<p>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写(URL rewriting)。</p>
<p>参考回答：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/cs_13_network.png" alt="img"></a></p>
<h2 id="11-Cookie的作用是什么-和Session有什么区别？"><a href="#11-Cookie的作用是什么-和Session有什么区别？" class="headerlink" title="11. Cookie的作用是什么?和Session有什么区别？"></a>11. Cookie的作用是什么?和Session有什么区别？</h2><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Session没有数据大小限制，Cookie有。</p>
<p>相对 Cookie 来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2 id="12-HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#12-HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="12. HTTP 1.0和HTTP 1.1的主要区别是什么?"></a>12. HTTP 1.0和HTTP 1.1的主要区别是什么?</h2><ol>
<li>在HTTP/1.0中，默认使用的是短连接，HTTP 1.1起，默认使用长连接。</li>
<li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
<li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
</ol>
<h2 id="13-URI和URL的区别是什么"><a href="#13-URI和URL的区别是什么" class="headerlink" title="13. URI和URL的区别是什么?"></a>13. URI和URL的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URI就是在某一规则下能把一个资源独一无二地标识出来。如：身份证</li>
<li>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL就是用定位的方式实现的URI。 可认为由4部分组成：协议、主机、端口、路径 http:localhost:8080/index.jsp ( 对于现在网址我更倾向于叫它URL，毕竟它提供了资源的位置信息) 如：具体住址</li>
</ul>
<p> URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="14-HTTP-和-HTTPS-的区别？"><a href="#14-HTTP-和-HTTPS-的区别？" class="headerlink" title="14. HTTP 和 HTTPS 的区别？"></a>14. HTTP 和 HTTPS 的区别？</h2><ol>
<li>端口 ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li>
<li>安全性和资源消耗：<ul>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文。</li>
<li>HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。（ HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。）所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li>
</ul>
</li>
</ol>
<ul>
<li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快；</li>
<li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8">https://app.yinxiang.com/fx/4ed295dd-ff19-4200-b401-47bdd265d0f8</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:1">↩</a></li>
<li>JavaGuide面试突袭v4.0，计算机网络 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gotodsp/p/6366163.html">https://www.cnblogs.com/gotodsp/p/6366163.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/23/%E8%AE%A1%E7%BD%91/#fnref:3">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93/" data-id="ckqujm00f000ac4ubhxrvg8w2" data-title="计算机网络总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-BIO-AIO-NIO区别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:32:28.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/">BIO_AIO_NIO区别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BIO-AIO-NIO区别"><a href="#BIO-AIO-NIO区别" class="headerlink" title="BIO_AIO_NIO区别"></a>BIO_AIO_NIO区别</h1><blockquote>
<p>简单对比：</p>
<ul>
<li>BIO 就是传统的 <a href="https://link.zhihu.com/?target=http://java.io/">java.io</a> 包，它是基于流模型实现的，交互的方式是<strong>同步、阻塞</strong>方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li>
<li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、<strong>同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li>
<li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了<strong>异步非堵塞的 IO</strong> 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li>
</ul>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>问题的关键其实就是理解同步/异步、阻塞/非阻塞的含义。</p>
<p>最初我看了很多blog以及一些所谓的面试考题讲解视频，以为理解了同步/异步、阻塞/非阻塞的含义，但其实越想越经不起推敲</p>
<p>比如下面的一些理解（我认为是不对的）：</p>
<blockquote>
<p><del>同步和异步（针对请求），阻塞和非阻塞（针对客户端）</del></p>
<p><del>在网络请求中，客户端会发出一个请求到服务端</del></p>
<ol>
<li><del>客户端发了请求后，就一直等着服务端的返回相应。 客户端：阻塞。 请求：同步</del></li>
<li><del>客户端发了请求后，就去干别的事情了，时不时来检查服务端是否给出了响应。 客户端：非阻塞。 请求： 同步。</del></li>
<li><del>换成异步请求后，客户端发出请求后，就坐在椅子上，等着服务端的返回相应。 客户端：阻塞。 请求：异步。</del></li>
<li><del>客户端发出请求后，就去干别的事情了，等到服务端给出响应后，再来处理业务逻辑。 客户端：阻塞。 请求：异步。</del></li>
</ol>
</blockquote>
<p>像这样举通俗的例子来说明这几个概念，通常都经不起推敲，原因在于，例子中缺少了一个“操作系统”级别的调度者。</p>
<ul>
<li>阻塞非阻塞是跟进程/线程严密相关的，而进程/线程又是依赖于操作系统存在的，所以自然不能脱离操作系统来讨论阻塞非阻塞。</li>
<li>同步/异步也是跟任务流相关的，所以举例子必须考虑到并发的任务流，不然，肯定很难举出恰当的例子的。</li>
</ul>
<p>本文的讨论：</p>
<ul>
<li>限定Linux环境下的network IO作为背景来讨论同步/异步、阻塞/非阻塞的理解。[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:1">1]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:2">2]</a>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:4">4]</a></li>
<li>讨论Java中对应的编程模型</li>
<li>对比BIO/NIO的区别[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fn:3">3]</a></li>
</ul>
<h2 id="1-Linux下的五种I-O模型"><a href="#1-Linux下的五种I-O模型" class="headerlink" title="1. Linux下的五种I/O模型"></a>1. Linux下的五种I/O模型</h2><p>Stevens在文章中一共比较了五种IO Model：</p>
<ul>
<li>blocking IO</li>
<li>nonblocking IO</li>
<li>IO multiplexing</li>
<li>signal driven IO</li>
<li>asynchronous IO</li>
</ul>
<p>由于signal driven IO在实际中并不常用，所以只提及剩下的四种IO Model。</p>
<blockquote>
<p>IO发生时涉及的对象和步骤:</p>
<ul>
<li>对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象:<ul>
<li>一个是调用这个IO的process (or thread)</li>
<li>另一个就是系统内核(kernel)</li>
</ul>
</li>
<li>当一个read操作发生时，它会经历两个阶段：<br>1 等待数据准备 (Waiting for the data to be ready)<br>2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
<li>记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。</li>
</ul>
</blockquote>
<h3 id="1-1-阻塞I-O（blocking-I-O）"><a href="#1-1-阻塞I-O（blocking-I-O）" class="headerlink" title="1.1 阻塞I/O（blocking I/O）"></a>1.1 阻塞I/O（blocking I/O）</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样:</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/1_blockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
</li>
</ul>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。以下是java实现的服务器bio代码（需要掌握），注意阻塞方法阻塞的第一个阶段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; BIO阻塞代码</span><br><span class="line">public class ServerTcpSocket &#123;</span><br><span class="line">    static byte[] bytes &#x3D; new byte[1024];</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocket连接</span><br><span class="line">            final ServerSocket serverSocket &#x3D; new ServerSocket();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocket.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 3.当前线程放弃cpu资源等待获取数据</span><br><span class="line">            System.out.println(&quot;等待获取数据...&quot;);</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                final Socket socket &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">                executorService.execute(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            System.out.println(&quot;获取到数据...&quot;);</span><br><span class="line">                            &#x2F;&#x2F; 4.读取数据</span><br><span class="line">                            int read &#x3D; socket.getInputStream().read(bytes); &#x2F;&#x2F; 会阻塞</span><br><span class="line">                            String result &#x3D; new String(bytes);</span><br><span class="line">                            System.out.println(result);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>应用程序</strong>想要读取数据就会调用<code>recvfrom</code>,而<code>recvfrom</code>会通知OS来执行，OS就会判断<strong>数据报是否准备好</strong>(比如判断是否收到了一个完整的UDP报文，如果收到UDP报文不完整，那么就继续等待)。当数据包准备好了之后，OS就会<strong>将数据从内核空间拷贝到用户空间</strong>(因为我们的用户程序只能获取用户空间的内存，无法直接获取内核空间的内存)。拷贝完成之后<code>socket.read()</code>就会解除阻塞，并得到read的结果。</p>
<h3 id="1-2-非阻塞（Non-Blocking-IO）"><a href="#1-2-非阻塞（Non-Blocking-IO）" class="headerlink" title="1.2 非阻塞（Non-Blocking IO）"></a>1.2 非阻塞（Non-Blocking IO）</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_nonblockingIO.png" alt="img"></a></p>
<ul>
<li><p>第一阶段：准备数据</p>
<p>从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。</p>
</li>
<li><p>第二阶段：数据拷贝</p>
<p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
</li>
</ul>
<p>所以，用户进程其实是需要不断的主动询问kernel数据好了没有。一定要注意这个地方，<strong>Non-Blocking还是会阻塞的</strong>。</p>
<p>以下是java实现的服务器bio代码（需要掌握），注意数据准备阶段是非阻塞方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; NIO非阻塞式代码</span><br><span class="line">public class ServerNioTcpSocket &#123;</span><br><span class="line">    static ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(512);</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 1.创建一个ServerSocketChannel连接</span><br><span class="line">            final ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();</span><br><span class="line">            &#x2F;&#x2F; 2.绑定端口号</span><br><span class="line">            serverSocketChannel.bind(new InetSocketAddress(8080));</span><br><span class="line">            &#x2F;&#x2F; 设置为非阻塞式</span><br><span class="line">            serverSocketChannel.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 非阻塞式</span><br><span class="line">            SocketChannel socketChannel &#x3D; serverSocketChannel.accept(); </span><br><span class="line">            if (socketChannel !&#x3D; null) &#123;</span><br><span class="line">                int j &#x3D; socketChannel.read(byteBuffer);  &#x2F;&#x2F; 此处不会阻塞</span><br><span class="line">                if (j &gt; 0) &#123;</span><br><span class="line">                    byte[] bytes &#x3D; Arrays.copyOf(byteBuffer.array(), byteBuffer.limit());</span><br><span class="line">                    System.out.println(&quot;获取到数据&quot; + new String(bytes));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;程序执行完毕..&quot;);</span><br><span class="line"></span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>NIO中提供了集中Channel：<code>ServerSocketChannel；SocketChannel；FileChannel；</code> <code>DatagramChannel</code>只有<code>FileChannel</code>无法设置成非阻塞模式，其他Channel都可以设置为非阻塞模式。</p>
<p>当设置为非阻塞后，我们的<code>socket.read()</code>方法就会立即得到一个返回结果(成功 or 失败)，我们可以根据返回结果执行不同的逻辑，比如在失败时，我们可以做一些其他的事情。但事实上这种方式也是低效的，因为我们不得不使用轮询方法区一直问OS：“我的数据好了没啊”。第一个代码是该线程不断的轮询，第二个代码是使用selector实现轮询等待有效请求。</p>
<p>NIO 不会在<code>recvfrom</code>也就是<code>socket.read()</code>时候阻塞，但是还是会在<strong>将数据从内核空间拷贝到用户空间</strong>阻塞。</p>
<h3 id="1-3-I-O复用-IO-multiplexing"><a href="#1-3-I-O复用-IO-multiplexing" class="headerlink" title="1.3 I/O复用 IO multiplexing"></a>1.3 I/O复用 IO multiplexing</h3><p>IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。</p>
<p>有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/2_IOmultiplexing.png" alt="img"></a></p>
<p>这里用java的NIO示意select</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<blockquote>
<p>多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</blockquote>
<p>在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<h3 id="1-4-异步I-O-Asynchronous-IO"><a href="#1-4-异步I-O-Asynchronous-IO" class="headerlink" title="1.4 异步I/O(Asynchronous IO)"></a>1.4 异步I/O(Asynchronous IO)</h3><p>linux下的asynchronous IO其实用得很少(所以这里就不贴AIO的java代码了，一般不要求掌握）。先看一下它的流程：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/3_AsynchronousIO.png" alt="img"></a></p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。</p>
<p>而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>Asynchronous IO调用中是真正的无阻塞，其他IO model中多少会有点阻塞。</p>
<h3 id="1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解"><a href="#1-5-基于四个模型，对blocking和non-blocking，synchronous-IO和asynchronous-IO的理解" class="headerlink" title="1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解"></a>1.5 基于四个模型，对blocking和non-blocking，synchronous IO和asynchronous IO的理解</h3><p>其实是POSIX的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>核心区别是：synchronous IO做”IO operation”的时候会将process阻塞</p>
<ol>
<li>blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</li>
<li>而asynchronous IO,当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</li>
</ol>
<blockquote>
<p>有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_ComparisonOfTheFiveIO.png" alt="img"></a></p>
<p>经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h3 id="1-6-select，poll，epoll区别"><a href="#1-6-select，poll，epoll区别" class="headerlink" title="1.6 select，poll，epoll区别"></a>1.6 select，poll，epoll区别</h3><p>他们是NIO中多路复用的三种实用机制（底层是三个C++的API），是由Linux操作系统提供的。</p>
<p>Unix，Linux操作系统的一些基本知识：</p>
<ul>
<li>用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间</li>
<li>文件描述符File Descriptor（FD）：是一个抽象概念，形式上是一个整数，实际上是一个索引值。指向内核中为每一个进程维护进程所打开的文件的记录表。当程序打开一个文件或者创建一个文件时，内核就会向进程返回一个FD。</li>
</ul>
<blockquote>
<p>select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。（fd_set是一个数组结构，拷贝大小受限制 x64最大2048）</p>
<p>poll机制：和select机制差不多的。将fd_set结构进行了优化，FD集合大小突破了操作系统限制。（pollfd结构来代替fd_set，通过链表实现的）</p>
<p>Epoll机制：Event Poll不在扫描所有的FD，只将用户关心的FD的事件存放到内核的一个事件表当中。可以减少用户空间与内核空间之间需要拷贝的数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>操作方式</th>
<th>底层实现</th>
<th>最大连接数</th>
<th>IO效率</th>
</tr>
</thead>
<tbody><tr>
<td>select（1984）</td>
<td>遍历</td>
<td>数组</td>
<td>受限于内核</td>
<td>一般</td>
</tr>
<tr>
<td>poll（1997）</td>
<td>遍历</td>
<td>链表</td>
<td>无上限</td>
<td>一般</td>
</tr>
<tr>
<td>epoll（2002）</td>
<td>事件回调</td>
<td>红黑树</td>
<td>无上限</td>
<td>高</td>
</tr>
</tbody></table>
<p>Java NIO当中是使用哪一种机制？</p>
<p>基于内核版本，可以查看DefaultSelectorProvider源码：</p>
<ul>
<li>windows下，WindowsSelectorProvider。</li>
<li>Linux下，内核2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。</li>
</ul>
<h2 id="2-Java的IO编程模型"><a href="#2-Java的IO编程模型" class="headerlink" title="2. Java的IO编程模型"></a>2. Java的IO编程模型</h2><blockquote>
<p>BIO 同步阻塞IO。 可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。</p>
<p>编程模型最简单。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_BIO%E7%BB%93%E6%9E%841.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 复习黑马文件上传的服务端BIO代码</span><br><span class="line">public class FileUpload_Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;服务器 启动..... &quot;);</span><br><span class="line">        &#x2F;&#x2F; 1. 创建服务端ServerSocket</span><br><span class="line">        ServerSocket serverSocket &#x3D; new ServerSocket(6666);</span><br><span class="line">        &#x2F;&#x2F; 2. 循环接收,建立连接</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            Socket accept &#x3D; serverSocket.accept(); &#x2F;&#x2F; 阻塞方法</span><br><span class="line">            &#x2F;*</span><br><span class="line">            3. socket对象交给子线程处理,进行读写操作</span><br><span class="line">            Runnable接口中,只有一个run方法,使用lambda表达式简化格式</span><br><span class="line">            *&#x2F;</span><br><span class="line">            new Thread(() ‐&gt; &#123;</span><br><span class="line">                try (</span><br><span class="line">                    &#x2F;&#x2F;3.1 获取输入流对象</span><br><span class="line">                    BufferedInputStream bis &#x3D; new BufferedInputStream(accept.getInputStream());</span><br><span class="line">                    &#x2F;&#x2F;3.2 创建输出流对象, 保存到本地 .</span><br><span class="line">                    FileOutputStream fis &#x3D; new FileOutputStream(System.currentTimeMillis() +</span><br><span class="line">                    &quot;.jpg&quot;);</span><br><span class="line">                    BufferedOutputStream bos &#x3D; new BufferedOutputStream(fis);) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 3.3 读写数据</span><br><span class="line">                    byte[] b &#x3D; new byte[1024 * 8];</span><br><span class="line">                    int len;</span><br><span class="line">                    while ((len &#x3D; bis.read(b)) !&#x3D; ‐1) &#123;</span><br><span class="line">                        bos.write(b, 0, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;4. 关闭 资源</span><br><span class="line">                    bos.close();</span><br><span class="line">                    bis.close();</span><br><span class="line">                    accept.close();</span><br><span class="line">                    System.out.println(&quot;文件上传已保存&quot;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>但是如果不活跃的连接逐渐增多，线程池里的线程慢慢的也都开始阻塞等待IO，线程池里真正在运行的线程数会越来越少，当线程池处理不过来时，会放置到线程池配置的BlockingQueue中，队列塞满后，慢慢的线程池中线程的数目会逐渐达到线程池配置的maximumPoolSize，如果再处理不过来，执行拒绝策略。也就是说，<code>最终会导致请求无法及时处理。</code></p>
<p>这样带来的问题是，假设有线程池corePoolSize设置为100，只要有100个不活跃的连接正在阻塞读写IO，就会把前corePoolSize线程都阻塞住，后续的请求就无法及时处理。</p>
<blockquote>
<p>NIO 同步非阻塞IO。 可靠性比较好，吞吐量也比较高，适用于连接比较多且连接比较短（轻操作）。例如聊天室。JDK1.4开始支持。（应用最广）</p>
<p>编程模型最复杂。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/5_NIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<p>NIO非阻塞体现:</p>
<ul>
<li>accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</li>
<li>首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</li>
</ul>
<p>(我的一些看法，java的NIO就是Linux中IO复用和NIO两个模型的结合)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码</span><br><span class="line">public class NIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个本地端口进行监听的服务Socket通道，并设置为非阻塞方式</span><br><span class="line">        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();</span><br><span class="line">        &#x2F;&#x2F; 必须配置为非阻塞才能往selector上注册，否则会报错，selector模式甭说就是非阻塞模式</span><br><span class="line">        ssc.configureBlocking(false); </span><br><span class="line">        ssc.bind(new InetSocketAddress(8888));</span><br><span class="line">        &#x2F;&#x2F; 创建一个选择器selector</span><br><span class="line">        Selector selector &#x3D; selector.open();</span><br><span class="line">        &#x2F;&#x2F; 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        while(true)&#123;</span><br><span class="line">            System.out.println(&quot;等待事件发生...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 轮询监听channel里面的key，select是阻塞的，accept也是阻塞的</span><br><span class="line">            int select &#x3D; selector.select(); </span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;事件发生了...&quot;);</span><br><span class="line">            &#x2F;&#x2F; 有客户端请求，被轮询监听到</span><br><span class="line">            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectionKeys().iterator();</span><br><span class="line">            while(it.hasNext())&#123;</span><br><span class="line">                SelectionKey key &#x3D; it.next();</span><br><span class="line">                &#x2F;&#x2F; 删除本次已处理的key， 防止下次select重复处理</span><br><span class="line">                it.remove();</span><br><span class="line">                handle(key);</span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void handle(SelectionKey key) throws IOException&#123;</span><br><span class="line">        if(key.isAcceptable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端连接事件发生了...&quot;);</span><br><span class="line">            ServerSocketChannel ssc &#x3D; (ServerSocketChannel) key.channel();</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现:此处accept方法是阻塞的，但是这里因为发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br><span class="line">            &#x2F;&#x2F; 处理完连接请求不会继续等待客户端的数据发送</span><br><span class="line">            SocketChannel sc &#x3D; ssc.accept();</span><br><span class="line">            sc.configureBlocking(false);</span><br><span class="line">            &#x2F;&#x2F; 通过Selector监听Channel时对读事件感兴趣</span><br><span class="line">            sc.register(selector, SelectionKey.OP_READ); </span><br><span class="line">        &#125; else if (key.isReadable())&#123;</span><br><span class="line">            System.out.println(&quot;有客户端数据可读事件发生了...&quot;);</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">            &#x2F;&#x2F; NIO非阻塞体现：首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定时发生了客户端发送数据的事件</span><br><span class="line">            int len &#x3D; sc.read(buffer);</span><br><span class="line">            if(len !&#x3D; -1)&#123;</span><br><span class="line">                System.out.println(&quot;读取到客户端发送的数据:&quot; + new String(buffer.array(), 0, len));</span><br><span class="line">            &#125;</span><br><span class="line">            ByteBuffer bufferToWrite &#x3D; ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes());</span><br><span class="line">            sc.write(bufferToWrite);</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">        &#125; else if(key.isWritable) &#123;</span><br><span class="line">            SocketChannel sc &#x3D; (SocketChannel) key.channel();</span><br><span class="line">            System.out.println(&quot;write事件...&quot;);</span><br><span class="line">            &#x2F;&#x2F; NIO事件触发是水平触发</span><br><span class="line">            &#x2F;&#x2F; 使用Java的NIO编程时，在没有数据可以往外写的时候要取消写事件</span><br><span class="line">            &#x2F;&#x2F; 在有数据往外写的时候在注册写事件</span><br><span class="line">            key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">            &#x2F;&#x2F; sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AIO 异步非阻塞IO。解决了服务端需要一直守着线程的问题，可靠性是最好的，吞吐量也是非常高的，适用于连接比较多且比较长（重操作）。 例如相册服务器。 JDK7开始支持。</p>
<p>编程模型比较简单，但需要操作系统来支持异步服务。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/6_AIO%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 服务端代码(了解)</span><br><span class="line">public class AIOServer&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        final AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open().bind(new InewSocketAddress(9000));</span><br><span class="line">        </span><br><span class="line">        serverChannel.accept(null, new CompletionHander&lt;AsynchronousServerSocketChannel, Object&gt;())&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void completed(AsynchronousServerSocketChannel socketChannel, Object attachment)&#123;</span><br><span class="line">                try&#123;</span><br><span class="line">                    &#x2F;&#x2F; 再次接受客户端连接，如果不写这一行代码后面的客户端连接不上服务器端</span><br><span class="line">                    serverChannel.accept(attachment, this);</span><br><span class="line">                    System.out.println(socketChannel.getRemoteAddress());</span><br><span class="line">                    ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line">                    socketChannel.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void completed(Integer result, ByteBuffer buffer)&#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(new String(buffer.array(), 0, result));</span><br><span class="line">                            socketChannel.write(ByteBuffer.wrap(&quot;HelloClient&quot;.getBytes()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        @Override</span><br><span class="line">                        public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            @Override</span><br><span class="line">            public void failed(Throwable exc, ByteBuffer buffer) &#123;exc.printStackTrace();&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3-BIO-NIO区别"><a href="#3-BIO-NIO区别" class="headerlink" title="3. BIO/NIO区别"></a>3. BIO/NIO区别</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/4_%E5%AF%B9%E6%AF%94.png" alt="img"></a></p>
<h2 id="4-BIO、NIO、AIO适用场景"><a href="#4-BIO、NIO、AIO适用场景" class="headerlink" title="4. BIO、NIO、AIO适用场景"></a>4. BIO、NIO、AIO适用场景</h2><ul>
<li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择。</li>
<li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。</li>
<li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</li>
</ul>
<h2 id="5-Java-NIO的3个核心组件"><a href="#5-Java-NIO的3个核心组件" class="headerlink" title="5. Java NIO的3个核心组件"></a>5. Java NIO的3个核心组件</h2><blockquote>
<p>NIO重点:</p>
<p>Channel（通道），Buffer（缓冲区），Selector（选择器）三个类之间的关系</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/7_NIO%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="img"></a></p>
<blockquote>
<p>简单解释：</p>
</blockquote>
<ul>
<li>每一个channel对应一个buffer缓冲区。</li>
<li>channel会注册到selector。</li>
<li>selector会根据channel上发生的读写事件，将请求交由某一个空闲线程处理。</li>
<li>selector对应一个或者多个线程。</li>
<li>buffer和channel都是可读可写的。</li>
</ul>
<h3 id="5-1-缓冲区Buffer"><a href="#5-1-缓冲区Buffer" class="headerlink" title="5.1 缓冲区Buffer"></a>5.1 缓冲区Buffer</h3><p>Buffer是一个对象。它包含一些要写入或者读出的数据。在面向流的I/O中，可以将数据写入或者将数据直接读到Stream对象中。</p>
<p>在NIO中，所有的数据都是用缓冲区处理。这也就本文上面谈到的IO是面向流的，NIO是面向缓冲区的。</p>
<p>缓冲区实质是一个数组，通常它是一个字节数组（ByteBuffer），也可以使用其他类的数组。但是一个缓冲区不仅仅是一个数组，缓冲区提供了对数据的结构化访问以及维护读写位置（limit）等信息。</p>
<p>最常用的缓冲区是ByteBuffer，一个ByteBuffer提供了一组功能于操作byte数组。除了ByteBuffer，还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean）都对应一种缓冲区，具体如下：</p>
<ul>
<li>ByteBuffer：字节缓冲区</li>
<li>CharBuffer:字符缓冲区</li>
<li>ShortBuffer：短整型缓冲区</li>
<li>IntBuffer：整型缓冲区</li>
<li>LongBuffer:长整型缓冲区</li>
<li>FloatBuffer：浮点型缓冲区</li>
<li>DoubleBuffer：双精度浮点型缓冲区</li>
</ul>
<h3 id="5-2-通道Channel"><a href="#5-2-通道Channel" class="headerlink" title="5.2 通道Channel"></a>5.2 通道Channel</h3><p>Channel是一个通道，可以通过它读取和写入数据，他就像自来水管一样，网络数据通过Channel读取和写入。</p>
<p>通道和流不同之处在于通道是双向的，流只是在一个方向移动，而且通道可以用于读，写或者同时用于读写。</p>
<p>因为Channel是全双工的，所以它比流更好地映射底层操作系统的API，特别是在UNIX网络编程中，底层操作系统的通道都是全双工的，同时支持读和写。</p>
<p>Channel有四种实现：</p>
<ul>
<li>FileChannel:是从文件中读取数据。</li>
<li>DatagramChannel:从UDP网络中读取或者写入数据。</li>
<li>SocketChannel:从TCP网络中读取或者写入数据。</li>
<li>ServerSocketChannel:允许你监听来自TCP的连接，就像服务器一样。每一个连接都会有一个SocketChannel产生。</li>
</ul>
<h3 id="5-3-多路复用器Selector"><a href="#5-3-多路复用器Selector" class="headerlink" title="5.3 多路复用器Selector"></a>5.3 多路复用器Selector</h3><p>Selector选择器可以监听多个Channel通道感兴趣的事情(read、write、accept(服务端接收)、connect，实现一个线程管理多个Channel，节省线程切换上下文的资源消耗。Selector只能管理非阻塞的通道，FileChannel是阻塞的，无法管理。</p>
<p><strong>关键对象</strong></p>
<ul>
<li>Selector：选择器对象，通道注册、通道监听对象和Selector相关。</li>
<li>SelectorKey：通道监听关键字，通过它来监听通道状态。</li>
</ul>
<p><strong>监听注册</strong></p>
<p>监听注册在Selector</p>
<blockquote>
<p>socketChannel.register(selector, SelectionKey.OP_READ);</p>
</blockquote>
<p><strong>监听的事件有</strong></p>
<ul>
<li>OP_ACCEPT: 接收就绪，serviceSocketChannel使用的</li>
<li>OP_READ: 读取就绪，socketChannel使用</li>
<li>OP_WRITE: 写入就绪，socketChannel使用</li>
<li>OP_CONNECT: 连接就绪，socketChannel使用</li>
</ul>
<h3 id="5-4-NIO的一些应用和框架"><a href="#5-4-NIO的一些应用和框架" class="headerlink" title="5.4 NIO的一些应用和框架"></a>5.4 NIO的一些应用和框架</h3><p>例如：Dubbo(服务框架)，就默认使用Netty作为基础通信组件，用于实现各进程节点之间的内部通信。</p>
<p>Jetty、Mina、Netty、Dubbo、ZooKeeper等都是基于NIO方式实现</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking，Richard Stevens，6.2节 I/O Models <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:1">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/historyasamirror/article/details/5778378">https://blog.csdn.net/historyasamirror/article/details/5778378</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/83597838">https://zhuanlan.zhihu.com/p/83597838</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:3">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112810033">https://zhuanlan.zhihu.com/p/112810033</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/18/BIO_AIO_NIO%E5%8C%BA%E5%88%AB/#fnref:4">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/BIO-AIO-NIO%E5%8C%BA%E5%88%AB/" data-id="ckqujm00e0009c4ub1dmy0d71" data-title="BIO_AIO_NIO区别" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:30:54.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/">MySQL高级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL高级"><a href="#MySQL高级" class="headerlink" title="MySQL高级"></a>MySQL高级</h1><p>基于<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">MySQL高级</a>的学习笔记，由于有些讲得不够全，做了部分补充[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:2">2]</a></p>
<blockquote>
<p>内容说明：</p>
<p>MySQL 是目前最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 也是目前最好的 RDBMS 应用软件之一。随着淘宝去IOE(去除IBM小型机、Oracle数据库及EMC存储设备)化的推进，MySQL 数据库在当前的互联网应用中变得越来越重要。</p>
<p>包括的MySQL 高级知识：索引，如何避免索引失效，索引优化策略，innodb和myisam存储引擎，MySQL锁机制，配置MySQL主从复制，explain、show profile、慢查询日志等日常SQL诊断和性能分析策略。</p>
</blockquote>
<h2 id="1-MySQL的架构介绍"><a href="#1-MySQL的架构介绍" class="headerlink" title="1.MySQL的架构介绍"></a>1.MySQL的架构介绍</h2><h3 id="1-1-MySQL简介"><a href="#1-1-MySQL简介" class="headerlink" title="1.1 MySQL简介"></a>1.1 MySQL简介</h3><ul>
<li>概述：关系型数据库管理系统RDBMS</li>
<li>高级MySQL：完整的mysql优化需要很深的功底，大公司有专门的DBA<ul>
<li>数据库内部结构和原理</li>
<li>数据库建模优化</li>
<li>数据库索引建立</li>
<li>SQL语句优化</li>
<li>SQL编程</li>
<li>mysql服务器安装配置</li>
<li>数据库的性能监控分析与系统优化</li>
<li>各种参数常量设定</li>
<li>主从复制</li>
<li>分布式架构搭建、垂直切割和水平切割</li>
<li>数据迁移</li>
<li>容灾备份和恢复</li>
<li>shell或python等脚本语言开发</li>
<li>对开源数据库进行二次开发</li>
</ul>
</li>
</ul>
<h3 id="1-2-MysqlLinux版的安装（mysql5-5）"><a href="#1-2-MysqlLinux版的安装（mysql5-5）" class="headerlink" title="1.2 MysqlLinux版的安装（mysql5.5）"></a>1.2 MysqlLinux版的安装（mysql5.5）</h3><ul>
<li>下载地址：</li>
</ul>
<p>官网下载地址：<a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p>
<ul>
<li><p>拷贝&amp;解压缩</p>
</li>
<li><p>检查工作</p>
<ul>
<li><p>检查是否安装过mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 执行安装命令前，先执行查询命令</span><br><span class="line">rpm -qa|grep mysql</span><br><span class="line"># 如果存在mysql-libs的旧版本包如下：请先执行卸载命令</span><br><span class="line">rpm -e --nodeps  mysql-libs  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>由于mysql安装过程中，会通过mysql用户在/tmp目录下新建tmp_db文件，所以请给/tmp较大的权限执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 &#x2F;tmp</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql的安装文件目录下执行：</span><br><span class="line">rpm -ivh MySQL-server-5.5.54-1.linux2.6.x86_64.rpmrpm -ivh MySQL-client-5.5.54-1.linux2.6.x86_64.rpm </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看MySQL安装版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin --version</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>mysql服务的启+停</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br><span class="line">ps -ef|grep mysql # 查看服务是否开启</span><br><span class="line">service mysql stop</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>首次登陆</p>
<p>安装完成后会提示出如下的提示：在mysql首次登录前要给 root 账号设置密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务后，执行命令 </span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;mysqladmin -u root  password &#39;123123&#39;</span><br><span class="line"># 登录 </span><br><span class="line">mysql -uroot -p123123  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>自启动服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig mysql on # 设置开机自启动</span><br><span class="line">chkconfig --list | grep mysql</span><br><span class="line">ntsysv # 看到[*]mysql这一行，表示开机后会自启动mysql</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>mysql的安装位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep mysql # 在linux下查看安装目录</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>参数路径解释备注</p>
<ul>
<li>basedir: /usr/bin 相关命令目录mysqladmin mysqldump等命令</li>
<li>datadir: /var/lib/mysql/ mysql数据库文件的存放路径</li>
<li>plugin-dir: /usr/lib64/mysql/pluginmysql插件存放路径</li>
<li>log-error: /var/lib/mysql/jack.atguigu.errmysql错误日志路径</li>
<li>pid-file: /var/lib/mysql/jack.atguigu.pid进程pid文件</li>
<li>socket:/var/lib/mysql/mysql.sock本地连接时用的unix套接字文件</li>
<li>/usr/share/mysql 配置文件目录mysql脚本及配置文件</li>
<li>/etc/init.d/mysql服务启停相关脚本</li>
</ul>
</li>
<li><p>mysql修改字符集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1. 查看字符集设置</span><br><span class="line">show variables like &#39;character%&#39;;</span><br><span class="line">show variables like &#39;%char%&#39;;</span><br><span class="line"># 默认的是客户端和服务器都用了latin1，所以会乱码</span><br><span class="line"></span><br><span class="line"># 2. 修改my.cnf</span><br><span class="line"># 在&#x2F;usr&#x2F;share&#x2F;mysql&#x2F; 中找到my.cnf的配置文件，拷贝其中的my-huge.cnf 到&#x2F;etc&#x2F;, 并命名为my.cnf mysql</span><br><span class="line"># 优先选中&#x2F;etc&#x2F;下的配置文件然后修改my.cnf:</span><br><span class="line">[client]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server&#x3D;utf8character_set_client&#x3D;utf8collation-server&#x3D;utf8_general_ci</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br><span class="line"></span><br><span class="line"># 3. 重新启动mysql</span><br><span class="line"># 但是原库的设定不会发生变化，参数修改之对新建的数据库生效 </span><br><span class="line"></span><br><span class="line"># 4. 已生成的库表字符集如何变更修改数据库的字符集</span><br><span class="line">alter database mytest character set &#39;utf8&#39;;</span><br><span class="line"># 修改数据表的字符集</span><br><span class="line">alter table user convert to  character set &#39;utf8&#39;; </span><br><span class="line">但是原有的数据如果是用非&#39;utf8&#39;编码的话，数据本身不会发生改变。     </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-3-mysql配置文件"><a href="#1-3-mysql配置文件" class="headerlink" title="1.3 mysql配置文件"></a>1.3 mysql配置文件</h3><p>（先大致了解，混个眼熟）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_1_mysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="img"></a></p>
<h3 id="1-4-mysql逻辑框架简介"><a href="#1-4-mysql逻辑框架简介" class="headerlink" title="1.4 mysql逻辑框架简介"></a>1.4 mysql逻辑框架简介</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_2_mysql%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6.png" alt="img"></a></p>
<blockquote>
<p>和其它数据库相比，MySQL有点与众不同，<strong>它的架构可以在多种不同场景中应用并发挥良好作用</strong>。</p>
<p>主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构</strong>将查询处理和其它的系统任务以及数据的存储提取相分离。</p>
<p>这种架构可以根据业务的需求和实际需要选择合适的存储引擎</p>
</blockquote>
<ul>
<li><p>连接层</p>
<p>最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层</p>
<ol>
<li>Management Serveices &amp; Utilities： 系统管理和控制工具</li>
<li>SQL Interface: SQL接口 接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface</li>
<li>Parser: 解析器 SQL命令传递到解析器的时候会被解析器验证和解析。</li>
<li>Optimizer: 查询优化器。 SQL语句在查询之前会使用查询优化器对查询进行优化。 用一个例子就可以理解： select uid,name from user where gender= 1; 优化器来决定先投影还是先过滤。</li>
<li>Cache和Buffer： 查询缓存。 如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 缓存是负责读，缓冲负责写。</li>
</ol>
</li>
<li><p>引擎层</p>
<p>存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p>
</li>
<li><p>存储层</p>
<p>数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ul>
<h3 id="1-5-mysql存储引擎"><a href="#1-5-mysql存储引擎" class="headerlink" title="1.5 mysql存储引擎"></a>1.5 mysql存储引擎</h3><h4 id="1-5-1-查看命令"><a href="#1-5-1-查看命令" class="headerlink" title="1.5.1 查看命令"></a>1.5.1 查看命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 看你的mysql现在已提供什么存储引擎</span><br><span class="line">show engines; </span><br><span class="line"># 看你的mysql当前默认的存储引擎:  </span><br><span class="line">show variables like &#39;%storage_engine%&#39;; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="1-5-2-MyISAM和InnoDB"><a href="#1-5-2-MyISAM和InnoDB" class="headerlink" title="1.5.2 MyISAM和InnoDB"></a>1.5.2 <strong>MyISAM和InnoDB</strong></h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_3_InnoDB%E5%92%8CMyISAM.png" alt="img"></a></p>
<h4 id="1-5-3-各个存储引擎介绍"><a href="#1-5-3-各个存储引擎介绍" class="headerlink" title="1.5.3 各个存储引擎介绍"></a>1.5.3 各个存储引擎介绍</h4><ol>
<li><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况</li>
<li><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</li>
<li>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</li>
<li>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</li>
<li>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</li>
<li>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis)</li>
<li>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</li>
</ol>
<h4 id="1-5-4-阿里巴巴、淘宝用哪个"><a href="#1-5-4-阿里巴巴、淘宝用哪个" class="headerlink" title="1.5.4 阿里巴巴、淘宝用哪个"></a>1.5.4 阿里巴巴、淘宝用哪个</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_4_%E9%98%BF%E9%87%8C%E4%BD%BF%E7%94%A8%E7%9A%84%E5%93%AA%E4%B8%AA.png" alt="img"></a></p>
<h2 id="2-索引优化分析"><a href="#2-索引优化分析" class="headerlink" title="2. 索引优化分析"></a>2. 索引优化分析</h2><h3 id="2-1-性能下降SQL慢-执行时间长-等待时间长"><a href="#2-1-性能下降SQL慢-执行时间长-等待时间长" class="headerlink" title="2.1 性能下降SQL慢 执行时间长 等待时间长"></a>2.1 性能下降SQL慢 执行时间长 等待时间长</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_5_%E6%80%A7%E8%83%BD%E4%B8%8B%E9%99%8Dsql%E6%85%A2%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E9%95%BF%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4%E9%95%BF.png" alt="img"></a></p>
<h3 id="2-2-常见通用的join查询"><a href="#2-2-常见通用的join查询" class="headerlink" title="2.2 常见通用的join查询"></a>2.2 常见通用的join查询</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_6_%E5%B8%B8%E8%A7%81%E7%9A%84join%E6%9F%A5%E8%AF%A2.png" alt="img"></a></p>
<ul>
<li><p>SQL解析：机读顺序（先from）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_7_SQL%E8%A7%A3%E6%9E%90.png" alt="img"></a></p>
</li>
<li><p>Join图（重点，基本功一定要记住）：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_8_join%E5%9B%BE.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_9_join%E5%9B%BE.png" alt="img"></a></p>
</li>
</ul>
<h3 id="2-3-索引简介"><a href="#2-3-索引简介" class="headerlink" title="2.3 索引简介"></a>2.3 索引简介</h3><h4 id="2-3-1-索引是什么（重点）"><a href="#2-3-1-索引是什么（重点）" class="headerlink" title="2.3.1 索引是什么（重点）"></a>2.3.1 索引是什么（重点）</h4><blockquote>
<p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。</p>
</blockquote>
<ul>
<li><p><strong>索引的本质</strong>：索引是数据结构</p>
</li>
<li><p>索引的目的：在于提高查询效率</p>
<p>可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？</p>
</li>
<li><p>简单理解： <strong>索引是排好序的快速查找数据结构</strong></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_10_%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A32.png" alt="img"></a></p>
<ul>
<li>二叉树弊端之一：二叉树很可能会发生两边不平衡的情况。</li>
<li>B-TREE：(B:balance) 会自动根据两边的情况自动调节，使两端无限趋近于平衡状态。可以使性能最稳定。(myisam使用的方式)</li>
<li>B-TREE弊端：(插入/修改操作多时，B-TREE会不断调整平衡，消耗性能)从侧面说明了索引不是越多越好。</li>
<li>B+TREE：Innodb 所使用的索引</li>
</ul>
</li>
<li><p><strong>我们平常所说的索引，如果没有特别指明，都是指B树(多路搜索树，并不一定是二叉的)结构组织的索引</strong>。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈稀索引(hash index)等。</p>
</li>
</ul>
<h4 id="2-3-2-索引的优势"><a href="#2-3-2-索引的优势" class="headerlink" title="2.3.2 索引的优势"></a>2.3.2 索引的优势</h4><ul>
<li>类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗</li>
</ul>
<h4 id="2-3-3-索引的劣势"><a href="#2-3-3-索引的劣势" class="headerlink" title="2.3.3 索引的劣势"></a>2.3.3 索引的劣势</h4><ul>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的</li>
<li>虽然索引大大<strong>提高了查询速度</strong>，同时却会<strong>降低更新表的速度</strong>，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息</li>
<li><strong>索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句</strong></li>
</ul>
<h4 id="2-3-4-索引的分类"><a href="#2-3-4-索引的分类" class="headerlink" title="2.3.4 索引的分类"></a>2.3.4 索引的分类</h4><h5 id="2-3-4-1-单值索引"><a href="#2-3-4-1-单值索引" class="headerlink" title="2.3.4.1 单值索引"></a>2.3.4.1 单值索引</h5><blockquote>
<p>即一个索引只包含单个列，一个表可以有多个单列索引</p>
</blockquote>
<h5 id="2-3-4-2-唯一索引"><a href="#2-3-4-2-唯一索引" class="headerlink" title="2.3.4.2 唯一索引"></a>2.3.4.2 唯一索引</h5><blockquote>
<p>索引列的值必须唯一，但允许有空值</p>
</blockquote>
<h5 id="2-3-4-3-复合索引"><a href="#2-3-4-3-复合索引" class="headerlink" title="2.3.4.3 复合索引"></a>2.3.4.3 复合索引</h5><blockquote>
<p>即一个索引包含多个列</p>
</blockquote>
<h5 id="2-3-4-4-主键索引"><a href="#2-3-4-4-主键索引" class="headerlink" title="2.3.4.4 主键索引"></a>2.3.4.4 主键索引</h5><blockquote>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇（聚集）索引</p>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<h5 id="2-3-4-5-基本语法"><a href="#2-3-4-5-基本语法" class="headerlink" title="2.3.4.5 基本语法"></a>2.3.4.5 基本语法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 1. 创建</span><br><span class="line">CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length))</span><br><span class="line">ALTER mytable ADD  [UNIQUE ]  INDEX [indexName] ON (columnname(length)) </span><br><span class="line"></span><br><span class="line"># 2. 删除</span><br><span class="line">DROP INDEX [indexName] ON mytable</span><br><span class="line"></span><br><span class="line"># 3. 查看</span><br><span class="line">SHOW INDEX FROM table_name\G</span><br><span class="line"></span><br><span class="line"># 4. 使用ALTER命令</span><br><span class="line"># 有四种方式来添加数据表的索引：</span><br><span class="line">ALTER TABLE tbl_name ADD PRIMARY KEY (column_list) # 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</span><br><span class="line">ALTER TABLE tbl_name ADD UNIQUE index_name (column_list) # 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次</span><br><span class="line">ALTER TABLE tbl_name ADD INDEX index_name (column_list) # 添加普通索引，索引值可出现多次。</span><br><span class="line">ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list) #该语句指定了索引为 FULLTEXT ，用于全文索引。 </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="2-3-5-mysql索引结构⭐"><a href="#2-3-5-mysql索引结构⭐" class="headerlink" title="2.3.5 mysql索引结构⭐"></a>2.3.5 mysql索引结构⭐</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_11_%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<ul>
<li><p>B-Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<ul>
<li>d为大于1的一个正整数，称为B-Tree的度。</li>
<li>h为一个正整数，称为B-Tree的高度。</li>
<li>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</li>
<li>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</li>
<li>所有叶节点具有相同的深度，等于树高h。</li>
<li>key和指针互相间隔，节点两端是指针。</li>
<li>一个节点中的key从左到右非递减排列。</li>
<li>所有节点组成树结构。</li>
<li>每个指针要么为null，要么指向另外一个节点。</li>
<li>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key_1)，其中v(key_1)为node的第一个key的值。</li>
<li>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(key_m)，其中v(key_m)为node的最后一个key的值。</li>
<li>如果某个指针在节点node的左右相邻key分别是key_i和key{i+1}且不为null，则其指向节点的所有key小于v(key{i+1})且大于v(key_i)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_12_B-Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%86.png" alt="img"></a></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    if(node &#x3D;&#x3D; null) return null;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        if(node.key[i] &#x3D;&#x3D; key) return node.data[i];</span><br><span class="line">            if(node.key[i] &gt; key) return BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    return BTree_Search(point[i+1]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data &#x3D; BTree_Search(root, my_key);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为logd((N+1)/2)logd((N+1)/2)，检索一个key，其查找节点个数的渐进复杂度为O(logdN)O(logdN)。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。</p>
<p>另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p>
</li>
<li><p>B+Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。</p>
<p>与B-Tree相比，B+Tree有以下不同点：</p>
<ul>
<li>每个节点的指针上限为2d而不是2d+1。</li>
<li>内节点不存储data，只存储key；叶子节点不存储指针。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%863.png" alt="img"></a></p>
<p>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。</p>
<p>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关。</p>
</li>
<li><p>带有顺序访问指针的B+Tree[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提高了区间查询效率。</p>
</li>
<li><p>为什么使用B-Tree（B+Tree）[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<p>红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础</p>
<p>考虑到<strong>主存存取原理</strong>，<strong>磁盘存取原理</strong>，<strong>局部性原理与磁盘预读</strong>详细见[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li><p>一般使用磁盘I/O次数评价索引结构的优劣。</p>
</li>
<li><p>先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<blockquote>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
</blockquote>
</li>
<li><p><strong>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为$O(h)=O(logdN)$。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）</strong></p>
</li>
<li><p>综上所述，用B-Tree作为索引结构效率是非常高的</p>
</li>
<li><p>红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多</p>
</li>
</ul>
</li>
<li><p>B+Tree适合外存索引的原因[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a>：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+Tree%E6%A3%80%E7%B4%A2%E5%8E%9F%E7%90%864.png" alt="img"></a></p>
</li>
<li><p>B+Tree的索引id为什么设置为自增有益于索引维护</p>
<ul>
<li>可以避免<strong>页分裂</strong>和<strong>页合并</strong></li>
</ul>
</li>
<li><p>MyISAM索引实现[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%861.png" alt="img"></a></p>
<blockquote>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeMyISAM%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<blockquote>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
</blockquote>
</li>
<li><p>InnoDB索引实现[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:1">1]</a></p>
<ul>
<li>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</li>
<li>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%861.png" alt="img"></a></p>
<blockquote>
<p>上图是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<ul>
<li><p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如下图为定义在Col3上的一个辅助索引</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_13_B+TreeInnoDB%E5%8E%9F%E7%90%862.png" alt="img"></a></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>INNODB的二级索引与主键索引有很大的不同。InnoDB的二级索引的叶子包含主键值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。</p>
</blockquote>
<ul>
<li><p>聚簇索引和非聚簇索引的区别[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:10">10]</a></p>
<p>聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。详细见这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/alexdamiao/article/details/51934917">博客</a></p>
<ul>
<li>InnoDB按聚簇索引的形式存储数据</li>
<li>MyISAM按照非聚簇索引的形式存储数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_50_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_50_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
</li>
<li><p>回表</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_51_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_51_%E8%81%9A%E7%B0%87%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
<h4 id="2-3-6-哪些情况需要创建索引"><a href="#2-3-6-哪些情况需要创建索引" class="headerlink" title="2.3.6 哪些情况需要创建索引"></a>2.3.6 哪些情况需要创建索引</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_14_%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<h4 id="2-3-7-哪些情况不需要创建索引"><a href="#2-3-7-哪些情况不需要创建索引" class="headerlink" title="2.3.7 哪些情况不需要创建索引"></a>2.3.7 哪些情况不需要创建索引</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_15_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<p>关于<strong>2.3.7.4</strong>的判断公式：<a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_16_%E4%B8%8D%E9%9C%80%E8%A6%81%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5.png" alt="img"></a></p>
<h3 id="2-4-索引性能分析"><a href="#2-4-索引性能分析" class="headerlink" title="2.4 索引性能分析"></a>2.4 索引性能分析</h3><h4 id="2-4-1-MySQL-Query-Optimizer"><a href="#2-4-1-MySQL-Query-Optimizer" class="headerlink" title="2.4.1 MySQL Query Optimizer"></a>2.4.1 MySQL Query Optimizer</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_17_mysqlQueryOptimizer.png" alt="img"></a></p>
<h4 id="2-4-2-MySQL常见瓶颈"><a href="#2-4-2-MySQL常见瓶颈" class="headerlink" title="2.4.2 MySQL常见瓶颈"></a>2.4.2 MySQL常见瓶颈</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_18_mysql%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88.png" alt="img"></a></p>
<h4 id="2-4-3-Explain"><a href="#2-4-3-Explain" class="headerlink" title="2.4.3 Explain"></a>2.4.3 <strong>Explain</strong></h4><h5 id="2-4-3-1-Explain是什么"><a href="#2-4-3-1-Explain是什么" class="headerlink" title="2.4.3.1 Explain是什么"></a>2.4.3.1 Explain是什么</h5><blockquote>
<p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
</blockquote>
<p>官网介绍: <a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.5/en/explain-output.html">http://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p>
<h5 id="2-4-3-2-Explain能干嘛"><a href="#2-4-3-2-Explain能干嘛" class="headerlink" title="2.4.3.2 Explain能干嘛"></a>2.4.3.2 Explain能干嘛</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_19_explain%E8%83%BD%E5%B9%B2%E5%98%9B.png" alt="img"></a></p>
<h5 id="2-4-3-3-Explain怎么用"><a href="#2-4-3-3-Explain怎么用" class="headerlink" title="2.4.3.3 Explain怎么用"></a>2.4.3.3 Explain怎么用</h5><blockquote>
<p>Explain + SQL语句</p>
</blockquote>
<ul>
<li><p>执行计划包含的信息</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_20_explain%E6%80%8E%E4%B9%88%E7%94%A8.png" alt="img"></a></p>
</li>
</ul>
<h5 id="2-4-3-4-Explain执行计划各字段解释"><a href="#2-4-3-4-Explain执行计划各字段解释" class="headerlink" title="2.4.3.4 Explain执行计划各字段解释"></a>2.4.3.4 Explain执行计划各字段解释</h5><ul>
<li><p>id ⭐：</p>
<ul>
<li><p>含义：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的<strong>顺序</strong></p>
</li>
<li><p>三种情况：</p>
<ul>
<li><p>id相同：执行顺序由上至下</p>
</li>
<li><p>id不同：如果是子查询，id的序号会递增，<strong>id值越大优先级越高</strong>，越先被执行</p>
</li>
<li><p>id相同/不同，同时存在：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_21_id3.png" alt="img"></a></p>
<p>衍生表 = derived2 –&gt; derived + 2</p>
<p>（2 表示由 id =2 的查询衍生出来的表。type 肯定是 all ，因为衍生的表没有建立索引）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>select_type：</p>
<ul>
<li><p>包含：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_22_select_type.png" alt="img"></a></p>
</li>
<li><p>查询的类型：</p>
<p>主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_23_select_type.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>table：显示这一行的数据是关于哪张表的</p>
</li>
<li><p>type⭐：</p>
<ul>
<li><p>包含：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_24_type.png" alt="img"></a></p>
</li>
<li><p>type显示的是访问类型，是较为重要的一个指标</p>
</li>
<li><p><strong>结果值从最好到最坏依次是</strong>：</p>
<p>(system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL )</p>
<p><strong>简化版（记住）</strong>：<strong>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</strong> 一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_25_type.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>possible_keys：</p>
<ul>
<li>显示可能应用在这张表中的索引，一个或多个。</li>
<li>查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong></li>
</ul>
</li>
<li><p>key⭐：</p>
<ul>
<li>实际使用的索引。如果为NULL，则没有使用索引、索引失效</li>
<li><strong>查询中若使用了覆盖索引，则该索引和查询的select字段重叠</strong></li>
</ul>
</li>
<li><p>key_len：</p>
<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。不损失精度性的情况下，长度越短越好</li>
<li>key_len字段能够帮你检查是否充分的利用上了索引</li>
</ul>
</li>
<li><p>ref：</p>
<ul>
<li>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</li>
</ul>
</li>
<li><p>rows⭐：</p>
<ul>
<li>rows列显示MySQL认为它执行查询时必须检查的行数。</li>
<li>越少越好</li>
</ul>
</li>
<li><p>Extra⭐：</p>
<ul>
<li><p>包含不适合在其他列中显示但十分重要的额外信息</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_26_Extra.png" alt="img"></a></p>
</li>
<li><p><strong>覆盖索引</strong>：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据; 当能通过读取索引就可以得到想要的数据，那就不需要读取行了。</p>
<p>①一个索引</p>
<p>②包含了(或覆盖了)[select子句]与查询条件[Where子句]中</p>
<p>③所有需要的字段就叫做<strong>覆盖索引</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_27_%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95.png" alt="img"></a></p>
<p><strong>理解</strong>：</p>
<blockquote>
<p>select id , name from t_xxx where age=18;</p>
<p>有一个组合索引 idx_id_name_age_xxx 包含了(覆盖了) id,name,age三个字段。查询时直接将建立了索引的列读取出来了，而不需要去查找所在行的其他数据, 所以很高效。</p>
</blockquote>
<p>(个人认为：在数据量较大，固定字段查询情况多时可以使用这种方法。)</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-5-查询优化"><a href="#2-5-查询优化" class="headerlink" title="2.5 查询优化"></a>2.5 查询优化</h3><h4 id="2-5-1-索引优化"><a href="#2-5-1-索引优化" class="headerlink" title="2.5.1 索引优化"></a>2.5.1 索引优化</h4><h5 id="2-5-1-1-索引分析"><a href="#2-5-1-1-索引分析" class="headerlink" title="2.5.1.1 索引分析"></a>2.5.1.1 索引分析</h5><ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=209">单表分析案例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=210">多表分析案例</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=211">三表分析案例</a><ul>
<li>尽可能减少Join语句的NextedLoop的循环总次数：永远用小结果集驱动大结果集</li>
<li>优先优化NestedLoop的内层循环</li>
<li><strong>保证Join语句中被驱动表上Join条件的字段已经被索引</strong></li>
<li>当无法保证被驱动表的Join条件字段被索引且内存充足的前提下，不要太吝啬JoinBuffer的设置</li>
</ul>
</li>
</ul>
<h5 id="2-5-1-2-索引失效"><a href="#2-5-1-2-索引失效" class="headerlink" title="2.5.1.2 索引失效"></a>2.5.1.2 <strong>索引失效</strong></h5><ul>
<li><p><strong>联合索引在B+Tree上的存储结构及数据查找方式.</strong></p>
<p>⭐，具体参考</p>
<p>[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:3">3]</a></p>
<p>（基于底层去理解索引失效）</p>
<ul>
<li>这里贴一个简单的联合索引的结构图，具体看上面的帖子</li>
<li><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_30_%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8C%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F.png" alt="img"></a></li>
</ul>
</li>
<li><p>索引失效案例</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_28_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88.png" alt="img"></a></p>
<ul>
<li><p>小总结：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_29_%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%B0%8F%E6%80%BB%E7%BB%93.png" alt="img"></a></p>
</li>
<li><p>（补充）覆盖索引、最左匹配、索引下推的理解⭐</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#%E5%9B%9E%E8%A1%A8">回表</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;zhansan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>第一次查询name的B+Tree，根据那么获取到主键id，然后再根据id去id的B+Tree找到行记录，这个回表过程会导致IO次数变多。</p>
</li>
<li><p>覆盖索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name from table where name&#x3D;zhansan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>在进行检索是，直接更具那么去name的B+Tree获取到id，name两列的值，不需要回表，效率高，应该尽可能多的使用索引覆盖来代替回表，所以有时候，在复杂的sql中，可以考虑将不相关的列都设置为索引列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id,name,age from table where name&#x3D;zhangsan;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>这里name，age作为一个联合索引</p>
</li>
<li><p>最左匹配：</p>
<p>有一个表：id，name，age，gender（id是主键，name，age是联合索引）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;?           # 符合</span><br><span class="line">select * from table where name&#x3D;? and age&#x3D;? # 符合</span><br><span class="line">select * from table where age&#x3D;? &#x3D; name&#x3D;?   # 优化器会优化,使其符合最左匹配</span><br><span class="line">select * from table where age&#x3D;?            # 不符合</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>索引下推：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table where name&#x3D;? and age&#x3D;?</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>在没有索引下推之前，先根据name去存储引擎中拉取符合结构的数据，返回到server层，在server层中对age的条件进行过滤</li>
<li>有了索引下推之后，根据name，age两个条件直接从存储引擎中拉去结果，不需要再server层做条件过滤</li>
<li>mysql5.7版本之后默认开启</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-5-1-3-一般性建议"><a href="#2-5-1-3-一般性建议" class="headerlink" title="2.5.1.3 一般性建议"></a>2.5.1.3 一般性建议</h5><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_31_%E7%B4%A2%E5%BC%95%E4%B8%80%E8%88%AC%E6%80%A7%E5%BB%BA%E8%AE%AE2.png" alt="img"></a></p>
<h5 id="2-5-1-4-优化口诀"><a href="#2-5-1-4-优化口诀" class="headerlink" title="2.5.1.4 优化口诀"></a>2.5.1.4 优化口诀</h5><p>建议理解，不用背</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_32_%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%8F%A3%E8%AF%80.png" alt="img"></a></p>
<h4 id="2-5-2-查询优化"><a href="#2-5-2-查询优化" class="headerlink" title="2.5.2 查询优化"></a>2.5.2 查询优化</h4><blockquote>
<p>对于数据库分析</p>
<ol>
<li>观察，至少跑一天，看看生产的慢SQL情况。</li>
<li>开启慢查询日志，设置阈值，比如超过5秒钟的就是慢SQL，并将它抓取出来。</li>
<li>explain+慢SQL分析</li>
<li>show profile</li>
<li>运维经理 or DBA来进行SQL数据库服务器的参数调优</li>
</ol>
</blockquote>
<p><strong>总结</strong>：</p>
<ul>
<li>慢查询开启并捕获</li>
<li>explain+慢SQL分析</li>
<li>show profile查询SQL再MySQL服务器里面的执行细节和生命周期情况</li>
<li>SQL数据库服务器参数调优</li>
</ul>
<p>关于下面2.5.2.1和2.5.2.3的优化原理见我后面写的<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/04/01/MySQL_Join%E4%BC%98%E5%8C%96/">Join优化</a></p>
<h5 id="2-5-2-1-小表驱动大表"><a href="#2-5-2-1-小表驱动大表" class="headerlink" title="2.5.2.1 小表驱动大表"></a>2.5.2.1 小表驱动大表</h5><ul>
<li><p>类似嵌套循环Nested Loop</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96.png" alt="img"></a></p>
</li>
<li><p>in/exists</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_33_%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%962.png" alt="img"></a></p>
</li>
</ul>
<h5 id="2-5-2-2-order-by关键字优化"><a href="#2-5-2-2-order-by关键字优化" class="headerlink" title="2.5.2.2 order by关键字优化"></a>2.5.2.2 order by关键字优化</h5><blockquote>
<p>尽量使用Index方式排序,避免使用FileSort方式排序</p>
</blockquote>
<ul>
<li>MySQL支持二种方式的排序，FileSort和Index<ul>
<li>Index效率高.它指MySQL扫描索引本身完成排序。</li>
</ul>
</li>
<li>FileSort方式效率较低。</li>
</ul>
<blockquote>
<p>尽可能在索引列上完成排序操作，遵照索引建的最佳左前缀</p>
</blockquote>
<ul>
<li><p>ORDER BY满足两情况，会使用Index方式排序</p>
<ul>
<li>ORDER BY 语句使用索引最左前列</li>
<li>使用Where子句与Order BY子句条件列组合满足索引最左前列</li>
<li>where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</li>
</ul>
</li>
<li><p>小总结：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_35_orderby%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93.png" alt="img"></a></p>
</li>
</ul>
<blockquote>
<p>如果不在索引列上，filesort有两种算法：</p>
<p>mysql就要启动<strong>双路排序</strong>和<strong>单路排序</strong></p>
</blockquote>
<ul>
<li><p>双路排序</p>
<ul>
<li>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出</li>
<li>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。（两次）</li>
<li><strong>缺点</strong>：取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</li>
</ul>
</li>
<li><p>单路排序</p>
<ul>
<li>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，</li>
<li>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</li>
<li>结论及引申出的问题：<ul>
<li>结论：由于单路是后出的，总体而言好过双路</li>
<li>问题：在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</li>
</ul>
</li>
</ul>
</li>
<li><p>优化策略</p>
<ul>
<li><p>增大sort_buffer_size参数的设置</p>
</li>
<li><p>增大max_length_for_sort_data参数的设置</p>
</li>
<li><p>去掉select 后面不需要的字段</p>
</li>
<li><p>以上策略对应的原因：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_34_orderby%E4%BC%98%E5%8C%96.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-5-2-3-group-by关键字优化"><a href="#2-5-2-3-group-by关键字优化" class="headerlink" title="2.5.2.3 group by关键字优化"></a>2.5.2.3 group by关键字优化</h5><ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了。</li>
</ul>
<h5 id="2-5-2-4-关联查询优化"><a href="#2-5-2-4-关联查询优化" class="headerlink" title="2.5.2.4 关联查询优化"></a>2.5.2.4 关联查询优化</h5><ul>
<li>保证被驱动表的join字段已经被索引</li>
<li>left join 时，选择小表作为驱动表，大表作为被驱动表</li>
<li>inner join 时，mysql会自己帮你把小结果集的表选为驱动表</li>
<li>子查询尽量不要放在被驱动表，有可能使用不到索引</li>
</ul>
<h5 id="2-5-2-5-子查询优化"><a href="#2-5-2-5-子查询优化" class="headerlink" title="2.5.2.5 子查询优化"></a>2.5.2.5 子查询优化</h5><ul>
<li>有索引的情况下 用 inner join 是最好的 其次是 in ，exists最糟糕</li>
<li>无索引的情况下用 小表驱动大表 因为join 方式需要distinct ，没有索引distinct消耗性能较大 所以 exists性能最佳 in其次 join性能最差</li>
<li>无索引的情况下大表驱动小表in 和 exists 的性能应该是接近的 都比较糟糕 exists稍微好一点 超不过5% 但是inner join 由于使用了 join buffer 所以快很多如果left join 则最慢</li>
</ul>
<h5 id="2-5-2-6-分页查询优化"><a href="#2-5-2-6-分页查询优化" class="headerlink" title="2.5.2.6 分页查询优化"></a>2.5.2.6 分页查询优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化前</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp ORDER BY deptno  LIMIT 10000,40</span><br><span class="line"># 优化后</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM emp INNER JOIN (SELECT id FROM emp e ORDER BY deptno LIMIT 10000,40) a ON a.id&#x3D;emp.id</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先利用覆盖索引把要取的数据行的主键取到，然后再用这个主键列与数据表做关联（查询的数据量小了）</p>
</li>
<li><p>实践证明：</p>
<p>①、order by 后的字段（XXX）有索引</p>
<p>②、sql 中有 limit 时， 当 select id 或 XXX字段索引包含字段时 ，显示 using index 当 select 后的字段含有 bouder by 字段索引不包含的字段时，将显示 using filesort</p>
</li>
</ul>
<h5 id="2-5-2-7-去重优化"><a href="#2-5-2-7-去重优化" class="headerlink" title="2.5.2.7 去重优化"></a>2.5.2.7 去重优化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 将产生重复数据</span><br><span class="line">select kcdz from t_mall_sku where id in( 3,4,5,6,8 )</span><br><span class="line"></span><br><span class="line"># 使用 distinct 关键字去重消耗性能优化</span><br><span class="line">select distinct kcdz from t_mall_sku where id in( 3,4,5,6,8 )</span><br><span class="line"></span><br><span class="line"># 能够利用到索引</span><br><span class="line">select  kcdz from t_mall_sku where id in( 3,4,5,6,8 )  group by kcdz </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>尽量不要使用 distinct 关键字去重</li>
<li>group by能去重且利用索引</li>
</ul>
<h2 id="3-查询截取分析"><a href="#3-查询截取分析" class="headerlink" title="3. 查询截取分析"></a>3. 查询截取分析</h2><h3 id="3-1-慢查询日志"><a href="#3-1-慢查询日志" class="headerlink" title="3.1 慢查询日志"></a>3.1 慢查询日志</h3><h4 id="3-1-1-慢查询日志介绍"><a href="#3-1-1-慢查询日志介绍" class="headerlink" title="3.1.1 慢查询日志介绍"></a>3.1.1 慢查询日志介绍</h4><ul>
<li>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</li>
<li>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</li>
<li>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</li>
</ul>
<h4 id="3-1-2-慢查询日志使用"><a href="#3-1-2-慢查询日志使用" class="headerlink" title="3.1.2 慢查询日志使用"></a>3.1.2 慢查询日志使用</h4><blockquote>
<p>默认情况下，MySQL数据库没有开启慢查询日志，需要我们手动来设置这个参数。当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件</p>
</blockquote>
<ul>
<li><p>查看是否开启及如何开启</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看</span><br><span class="line">SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span><br><span class="line"># 设置开启，只对当前数据库生效</span><br><span class="line">set global slow_query_log&#x3D;1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>那么开启了慢查询日志后，什么样的SQL才会记录到慢查询日志里面呢？</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_36_%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AE%B0%E5%BD%95%E5%88%B0%E7%9A%84sql.png" alt="img"></a></p>
</li>
<li><p>查看当前多少秒算慢, 以及修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 查看</span><br><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line"># 设置</span><br><span class="line">set global long_query_time&#x3D;1;</span><br><span class="line"># 需要重新连接或新开一个会话才能看到修改值</span><br><span class="line">SHOW VARIABLES LIKE &#39;long_query_time%&#39;;</span><br><span class="line"></span><br><span class="line"># 改变当前session变量</span><br><span class="line">set session long_query_time&#x3D;1;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查询当前系统中有多少条慢查询记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show global status like &#39;%Slow_queries%&#39;;  </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-1-3-日志分析工具mysqldumpslow"><a href="#3-1-3-日志分析工具mysqldumpslow" class="headerlink" title="3.1.3 日志分析工具mysqldumpslow"></a>3.1.3 日志分析工具mysqldumpslow</h4><ul>
<li><p>工作常用参考</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log</span><br><span class="line"># 另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;atguigu-slow.log | more</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_37_mysqldumpslow.png" alt="img"></a></p>
</li>
</ul>
<h3 id="3-2-批量数据脚本"><a href="#3-2-批量数据脚本" class="headerlink" title="3.2 批量数据脚本"></a>3.2 批量数据脚本</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_38_%E6%89%B9%E9%87%8F%E6%95%B0%E6%8D%AE%E8%84%9A%E6%9C%AC.png" alt="img"></a></p>
<ul>
<li><p>创建函数，假如报错：This function has none of DETERMINISTIC……</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 由于开启过慢查询日志，因为我们开启了 bin-log, 我们就必须为我们的function指定一个参数。</span><br><span class="line">show variables like &#39;log_bin_trust_function_creators&#39;;</span><br><span class="line">set global log_bin_trust_function_creators&#x3D;1;</span><br><span class="line"></span><br><span class="line"># 这样添加了参数以后，如果mysqld重启，上述参数又会消失，永久方法：</span><br><span class="line"># windows下: my.ini[mysqld]加上log_bin_trust_function_creators&#x3D;1</span><br><span class="line"># linux下: &#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上log_bin_trust_function_creators&#x3D;1</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>创建函数,保证每条数据都不同</p>
<ul>
<li><p>随机产生字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR(255)</span><br><span class="line">BEGIN    ##方法开始 </span><br><span class="line">DECLARE chars_str VARCHAR(100) DEFAULT   &#39;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#39;;  ##声明一个 字符窜长度为 100 的变量 chars_str ,默认值  </span><br><span class="line">DECLARE return_str VARCHAR(255) DEFAULT &#39;&#39;; DECLARE i INT DEFAULT 0;  ##循环开始</span><br><span class="line">WHILE i &lt; n DO   </span><br><span class="line">SET return_str &#x3D;CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));##concat 连接函数  ，substring(a,index,length) 从index处开始截取</span><br><span class="line">SET i &#x3D; i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line">RETURN return_str;</span><br><span class="line">END $$ </span><br><span class="line"># 假如要删除</span><br><span class="line"># drop function rand_string;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>随机产生部门编号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    DELIMITER $$</span><br><span class="line">    CREATE FUNCTION rand_num( ) RETURNS INT(5)</span><br><span class="line">BEGIN    </span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET i &#x3D; FLOOR(100+RAND()*10);</span><br><span class="line">    RETURN i;</span><br><span class="line">    END $$  </span><br><span class="line">    # 假如要删除</span><br><span class="line">    # drop function rand_num;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建存储过程</p>
<ul>
<li><p>插入数据的存储过程(往emp表添加随机数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_emp10000(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN  </span><br><span class="line">DECLARE i INT DEFAULT 0;   #set autocommit &#x3D;0 把autocommit设置成0  ；提高执行效率 </span><br><span class="line">SET autocommit &#x3D; 0;     </span><br><span class="line">REPEAT  ##重复 </span><br><span class="line">SET i &#x3D; i + 1;   </span><br><span class="line">INSERT INTO emp10000 (empno, ename ,job ,mgr ,hiredate ,sal ,comm ,deptno ) VALUES ((START+i) ,rand_string(6),&#39;SALESMAN&#39;,0001,CURDATE(),FLOOR(1+RAND()*20000),FLOOR(1+RAND()*1000),rand_num());   </span><br><span class="line">UNTIL i &#x3D; max_num   ##直到  上面也是一个循环</span><br><span class="line">END REPEAT;  ##满足条件后结束循环 </span><br><span class="line">COMMIT;   ##执行完成后一起提交 </span><br><span class="line">END $$ </span><br><span class="line"># 删除</span><br><span class="line"># DELIMITER ;</span><br><span class="line"># drop PROCEDURE insert_emp; </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>插入数据的存储过程(往dept表添加随机数据)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往dept表添加随机数据</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE insert_dept(IN START INT(10),IN max_num INT(10))</span><br><span class="line">BEGIN  </span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET autocommit &#x3D; 0;     </span><br><span class="line">REPEAT   </span><br><span class="line">SET i &#x3D; i + 1;   </span><br><span class="line">INSERT INTO dept (deptno ,dname,loc ) VALUES (START +i ,rand_string(10),rand_string(8));   </span><br><span class="line">UNTIL i &#x3D; max_num   </span><br><span class="line">END REPEAT;   </span><br><span class="line">COMMIT;   </span><br><span class="line">END $$  </span><br><span class="line">#删除</span><br><span class="line"># DELIMITER ; #将 结束标志换回 ;</span><br><span class="line"># drop PROCEDURE insert_dept;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调用存储过程</p>
<ul>
<li><p>dept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER ; #将 结束标志换回 ;</span><br><span class="line">CALL insert_dept(100,10); </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>emp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#执行存储过程，往emp表添加50万条数据</span><br><span class="line">DELIMITER ;    #将 结束标志换回 ;</span><br><span class="line">CALL insert_emp(100001,500000);  </span><br><span class="line">CALL insert_emp10000(100001,10000);    </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="3-3-Show-Profile"><a href="#3-3-Show-Profile" class="headerlink" title="3.3 Show Profile"></a>3.3 Show Profile</h3><h4 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h4><blockquote>
<p>是什么：是mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
</blockquote>
<h4 id="3-3-2-官网介绍"><a href="#3-3-2-官网介绍" class="headerlink" title="3.3.2 官网介绍"></a>3.3.2 官网介绍</h4><p>官网：<a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.5/en/show-profile.html">http://dev.mysql.com/doc/refman/5.5/en/show-profile.html</a></p>
<h4 id="3-3-3-默认设置"><a href="#3-3-3-默认设置" class="headerlink" title="3.3.3 默认设置"></a>3.3.3 默认设置</h4><blockquote>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
</blockquote>
<h4 id="3-3-4-分析步骤"><a href="#3-3-4-分析步骤" class="headerlink" title="3.3.4 分析步骤"></a>3.3.4 分析步骤</h4><ul>
<li><p>看看当前的mysql版本是否支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Show variables like &#39;profiling&#39;; #  默认是关闭，使用前需要开启    </span><br><span class="line">set profiling&#x3D;1;  #  开启</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>运行SQL</p>
</li>
<li><p>查看结果，show profiles；</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles.png" alt="img"></a></p>
</li>
<li><p>诊断SQL，show profile cpu,block io for query n (n为上一步前面的问题SQL数字号码);</p>
<ul>
<li><p>查询命令的参数</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD2.png" alt="img"></a></p>
</li>
<li><p>查询结果</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_39_showprofiles%E8%AF%8A%E6%96%AD.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p>日常开发需要注意的结论</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA.png" alt="img"></a></p>
<ul>
<li><p>创建临时表的性能耗费示例：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_40_showprofiles%E8%AF%8A%E6%96%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%93%E8%AE%BA2.png" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-全局查询日志"><a href="#3-4-全局查询日志" class="headerlink" title="3.4 全局查询日志"></a>3.4 全局查询日志</h3><h4 id="3-4-1-配置启用"><a href="#3-4-1-配置启用" class="headerlink" title="3.4.1 配置启用"></a>3.4.1 配置启用</h4><p>在mysql的my.cnf中，设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 开启</span><br><span class="line">general_log&#x3D;1  </span><br><span class="line"># 记录日志文件的路径</span><br><span class="line">general_log_file&#x3D;&#x2F;path&#x2F;logfile</span><br><span class="line"># 输出格式</span><br><span class="line">log_output&#x3D;FILE</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-编码启用"><a href="#3-4-2-编码启用" class="headerlink" title="3.4.2 编码启用"></a>3.4.2 编码启用</h4><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_41_%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%BC%96%E7%A0%81%E5%90%AF%E7%94%A8.png" alt="img"></a></p>
<blockquote>
<p><strong>特别的：尽量不要在生产环境开启这个功能</strong></p>
</blockquote>
<h2 id="4-MySQL锁机制"><a href="#4-MySQL锁机制" class="headerlink" title="4. MySQL锁机制"></a>4. MySQL锁机制</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
</blockquote>
<h3 id="4-2-锁的分类"><a href="#4-2-锁的分类" class="headerlink" title="4.2 锁的分类"></a>4.2 锁的分类</h3><h4 id="4-2-1-从对数据操作的类型（读-写）分"><a href="#4-2-1-从对数据操作的类型（读-写）分" class="headerlink" title="4.2.1 从对数据操作的类型（读\写）分"></a>4.2.1 从对数据操作的类型（读\写）分</h4><ul>
<li>读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁(排它锁)：当前写操作没有完成前，它会阻断其他写锁和读锁。</li>
</ul>
<h4 id="4-2-2-从对数据操作的粒度分"><a href="#4-2-2-从对数据操作的粒度分" class="headerlink" title="4.2.2 从对数据操作的粒度分"></a>4.2.2 从对数据操作的粒度分</h4><ul>
<li>表锁</li>
<li>行锁</li>
</ul>
<h3 id="4-3-三锁"><a href="#4-3-三锁" class="headerlink" title="4.3 三锁"></a>4.3 三锁</h3><h4 id="4-3-1-表锁（偏读）"><a href="#4-3-1-表锁（偏读）" class="headerlink" title="4.3.1 表锁（偏读）"></a>4.3.1 表锁（偏读）</h4><blockquote>
<p>特点：偏向MyISAM存储引擎，开销小，加锁快；无死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</p>
</blockquote>
<ul>
<li><p>手动加读写锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tabel 表名 read(write), 表名2 read(write), ...;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看表上加过的锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show open tables;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>释放表锁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unlock tables;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>总结</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_42_%E8%A1%A8%E9%94%81.png" alt="img"></a></p>
<p>补充：加读锁的session也不能修改加读锁的表。</p>
<p><strong>简而言之，就是读锁会阻塞写，但是不会堵塞读。而写锁则会把读和写都堵塞</strong></p>
</li>
<li><p>如何分析表锁定</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_43_%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%A1%A8%E9%94%81%E5%AE%9A2.png" alt="img"></a></p>
</li>
</ul>
<h4 id="4-3-2-行锁（偏写）"><a href="#4-3-2-行锁（偏写）" class="headerlink" title="4.3.2 行锁（偏写）"></a>4.3.2 行锁（偏写）</h4><blockquote>
<p>特点：</p>
<ol>
<li>偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li>
<li>InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁</li>
</ol>
</blockquote>
<ul>
<li><p>行锁支持事务，<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/08/MySQL%E5%9F%BA%E7%A1%80/#5-TCL%E8%AF%AD%E8%A8%80">复习初级部分知识⭐</a></p>
<ul>
<li><p>重点:事务特性、并发事务导致的问题、事务隔离级别等</p>
</li>
<li><p>补充：并发事务导致的问题（更新丢失）</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_44_%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1.png" alt="img"></a></p>
</li>
</ul>
</li>
<li><p><strong>无索引(或者索引失效)行锁升级为表锁</strong></p>
</li>
<li><p>间隙锁的危害</p>
<ul>
<li><p><strong>间隙锁</strong>:</p>
<p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（GAP Lock）。</p>
</li>
<li><p><strong>危害</strong>:</p>
<p>因为Query执行过程中通过过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值并不存在。间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定键值范围内的任何数据。在某些场景下这可能会对性能造成很大的危害</p>
</li>
</ul>
</li>
<li><p><strong>[面试题] 常考如何锁定一行</strong></p>
<p>事务显示加锁[<a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fn:9">9]</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">##在 MySQL 5.7 中</span><br><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE</span><br><span class="line">排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br><span class="line"></span><br><span class="line">##在 MySQL 8.0 中</span><br><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... FOR SHARE</span><br><span class="line">排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE[NOWAIT|SKIP LOCKED]</span><br><span class="line">--NOWAIT:发现有锁等待后会立即返回错误，不用等待锁超时后报错。</span><br><span class="line">--SKIP LOCKED:跳过被锁定的行，直接更新其他行，但是这样要注意是否会造成更新结果不符合预期。</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_45_%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="img"></a></p>
</li>
<li><p>Innodb存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，Innodb的整体性能和MyISAM相比就会有比较明显的优势了。</p>
</li>
<li><p>但是，Innodb的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让Innodb的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
</li>
<li><p>如何分析行锁定</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%903.png" alt="img"></a></p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_47_%E8%A1%8C%E9%94%81%E5%AE%9A%E5%88%86%E6%9E%902.png" alt="img"></a></p>
</li>
<li><p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>尽可能较少检索条件，避免间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>锁住某行后，尽量不要去调别的行或表，赶紧处理被锁住的行然后释放掉锁</li>
<li>涉及相同表的事务，对于调用表的顺序尽量保持一致</li>
<li>在业务环境允许的情况下,尽可能低级别事务隔离</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-页锁（了解）"><a href="#4-3-2-页锁（了解）" class="headerlink" title="4.3.2 页锁（了解）"></a>4.3.2 页锁（了解）</h4><blockquote>
<p>开销和加锁时间界于表锁和行锁之间；</p>
<p>会出现死锁；</p>
<p>锁定粒度界于表锁和行锁之间，并发度一般。</p>
</blockquote>
<h2 id="5-主从复制⭐"><a href="#5-主从复制⭐" class="headerlink" title="5. 主从复制⭐"></a>5. 主从复制⭐</h2><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_48_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png" alt="img"></a></p>
<h3 id="5-1-复制的基本原理"><a href="#5-1-复制的基本原理" class="headerlink" title="5.1 复制的基本原理"></a>5.1 复制的基本原理</h3><p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E9%AB%98%E7%BA%A7_49_%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png" alt="img"></a></p>
<h3 id="5-2-复制的基本原则"><a href="#5-2-复制的基本原则" class="headerlink" title="5.2 复制的基本原则"></a>5.2 复制的基本原则</h3><ul>
<li>每个slave只有一个master</li>
<li>每个slave只能有一个唯一的服务器ID</li>
<li>每个master可以有多个salve</li>
</ul>
<h3 id="5-3-复制的最大问题"><a href="#5-3-复制的最大问题" class="headerlink" title="5.3 复制的最大问题"></a>5.3 复制的最大问题</h3><blockquote>
<p>延时</p>
</blockquote>
<h3 id="5-4-一主一从常见配置"><a href="#5-4-一主一从常见配置" class="headerlink" title="5.4 一主一从常见配置"></a>5.4 一主一从常见配置</h3><ul>
<li><p>mysql版本一致且后台以服务运行</p>
</li>
<li><p>主从都配置在[mysqld]结点下，都是小写</p>
</li>
<li><p>主机修改my.ini配置文件</p>
<ul>
<li>[必须]主服务器唯一ID<ul>
<li>server-id=1</li>
</ul>
</li>
</ul>
</li>
<li><p>[必须]启用二进制日志</p>
<ul>
<li>log-bin=自己本地的路径/data/mysqlbin<ul>
<li>log-bin=D:/devSoft/MySQLServer5.5/data/mysqlbin</li>
</ul>
</li>
<li>[可选]启用错误日志<ul>
<li>log-err=自己本地的路径/data/mysqlerr</li>
</ul>
</li>
<li>log-err=D:/devSoft/MySQLServer5.5/data/mys</li>
<li>[可选]根目录</li>
<li>basedir=”自己本地路径”<ul>
<li>basedir=”D:/devSoft/MySQLServer5.5/“</li>
</ul>
</li>
</ul>
</li>
<li><p>[可选]临时目录</p>
<ul>
<li>tmpdir=”自己本地路径”</li>
<li>tmpdir=”D:/devSoft/MySQLServer5.5/“</li>
<li>[可选]数据目录<ul>
<li>datadir=”自己本地路径/Data/“</li>
<li>datadir=”D:/devSoft/MySQLServer5.5/Data/“</li>
</ul>
</li>
</ul>
</li>
<li><p>read-only=0</p>
<ul>
<li>主机，读写都可以</li>
<li>[可选]设置不要复制的数据库</li>
<li>binlog-ignore-db=mysql</li>
<li>[可选]设置需要复制的数据库<ul>
<li>binlog-do-db=需要复制的主数据库名字</li>
</ul>
</li>
</ul>
</li>
<li><p>从机修改my.cnf配置文件</p>
<ul>
<li>[必须]从服务器唯一ID</li>
<li>[可选]启用二进制日志</li>
</ul>
</li>
<li><p>因修改过配置文件，请主机+从机都重启后台mysql服务</p>
</li>
<li><p>主机从机都关闭防火墙</p>
<ul>
<li>windows手动关闭</li>
<li>关闭虚拟机linux防火墙 service iptables stop</li>
</ul>
</li>
<li><p>在Windows主机上建立帐户并授权slave</p>
<ul>
<li><p>在主机mysql中执行授权命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1.授权</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;从机器数据库IP&#39; IDENTIFIED BY &#39;123456&#39;;</span><br><span class="line"># 2.执行结束后刷新</span><br><span class="line">flush privileges;</span><br><span class="line"># 3.查询主机状态</span><br><span class="line">show master status;</span><br><span class="line"># 4.记录下File和Position的值</span><br><span class="line"># 5.执行完此步骤后不要再操作主服务器MYSQL，防止主服务器状态值变化</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在Linux从机上配置需要复制的主机</p>
<ul>
<li><p>在从机mysql中执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机IP&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;zhangsan&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;File名字&#39;,MASTER_LOG_POS&#x3D;Position数字;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>启动从服务器复制功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start slave;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>查看从机状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show slave status\G</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>下面两个参数都是Yes，则说明主从配置成功!</p>
<p>Slave_IO_Running: Yes</p>
<p>Slave_SQL_Running: Yes</p>
</li>
</ul>
</li>
<li><p>主机新建库、新建表、insert记录，从机复制</p>
</li>
<li><p>如何停止从服务复制功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意停止后，重新授权需要重新查看主机状态，记录下File和Position的值</p>
</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a target="_blank" rel="noopener" href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:1">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu?p=179">https://www.bilibili.com/video/BV12b411K7Zu?p=179</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:2">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/feichitianxia/article/details/107997795">https://blog.csdn.net/feichitianxia/article/details/107997795</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:3">↩</a></li>
<li>Baron Scbwartz等 著，王小东等 译；高性能MySQL（High Performance MySQL）；电子工业出版社，2010 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:4">↩</a></li>
<li>Michael Kofler 著，杨晓云等 译；MySQL5权威指南（The Definitive Guide to MySQL5）；人民邮电出版社，2006 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:5">↩</a></li>
<li>D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:6">↩</a></li>
<li>Codd, E. F. (1970). “A relational model of data for large shared data banks”. Communications of the ACM, , Vol. 13, No. 6, pp. 377-387 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:7">↩</a></li>
<li>MySQL5.1参考手册 - <a target="_blank" rel="noopener" href="http://dev.mysql.com/doc/refman/5.1/zh/index.html">http://dev.mysql.com/doc/refman/5.1/zh/index.html</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:8">↩</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33033819/article/details/106445880">https://blog.csdn.net/qq_33033819/article/details/106445880</a> <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:9">↩</a></li>
<li>《数据库原理》 <a target="_blank" rel="noopener" href="http://lihengxu.cn/2021/03/12/MySQL%E9%AB%98%E7%BA%A7/#fnref:10">↩</a></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/MySQL%E9%AB%98%E7%BA%A7/" data-id="ckqujm00h000bc4ubezbc17pp" data-title="MySQL高级" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JDBC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/JDBC/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:29:31.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/JDBC/">JDBC</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在Java中，数据库存取技术可分为如下几类：</p>
<ul>
<li><strong>JDBC</strong>直接访问数据库</li>
<li><strong>JDO</strong>技术（Java Data Object）</li>
<li>第三方O/R工具，如Hibernate, Mybatis 等</li>
</ul>
<p><strong>JDBC</strong>是java访问数据库的基石，JDO, Hibernate等只是更好的封装了JDBC。</p>
<h3 id="1-1-JDBC介绍"><a href="#1-1-JDBC介绍" class="headerlink" title="1.1 JDBC介绍"></a>1.1 JDBC介绍</h3><blockquote>
<p>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统（DBMS）、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，使用这个类库可以以一种标准的方法、方便地访问数据库资源</p>
</blockquote>
<p><strong>作用</strong>：</p>
<ul>
<li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li>
<li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li>
</ul>
<p>如果没有JDBC，那么Java程序访问数据库时是这样的：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_1.png" alt="img"></a></p>
<p>而通过JDBC可以如下访问：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_2.png" alt="img"></a></p>
<blockquote>
<p>总结：</p>
<p>JDBC是SUN公司提供一套用于数据库操作的接口API，Java程序员只需要面向这套接口编程即可。不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。</p>
</blockquote>
<h3 id="1-2-JDBC-API"><a href="#1-2-JDBC-API" class="headerlink" title="1.2 JDBC API"></a>1.2 JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并到得到返回结果等各类操作。声明在java.sql与javax.sql包中</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_3.png" alt="img"></a></p>
<h3 id="1-3-JDBC程序编写步骤"><a href="#1-3-JDBC程序编写步骤" class="headerlink" title="1.3 JDBC程序编写步骤"></a>1.3 JDBC程序编写步骤</h3><ul>
<li>注册驱动</li>
<li>获取连接</li>
<li>执行增删改查</li>
<li>释放资源</li>
</ul>
<h2 id="2-快速使用JDBC"><a href="#2-快速使用JDBC" class="headerlink" title="2. 快速使用JDBC"></a>2. 快速使用JDBC</h2><h3 id="2-1-步骤"><a href="#2-1-步骤" class="headerlink" title="2.1 步骤"></a>2.1 步骤</h3><ol>
<li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar <a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/">MySQL的驱动下载地址</a></li>
<li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li>
<li>右键–&gt;Add As Library</li>
<li>注册驱动</li>
<li>获取数据库连接对象 Connection</li>
<li>定义sql</li>
<li>获取执行sql语句的对象 Statement</li>
<li>执行sql，接受返回结果</li>
<li>处理结果</li>
<li>释放资源</li>
</ol>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JDBC快速入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JdbcDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;1. 导入驱动jar包</span><br><span class="line">        &#x2F;&#x2F;2.注册驱动</span><br><span class="line">        &#x2F;&#x2F; Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">        &#x2F;&#x2F;3.获取数据库连接对象</span><br><span class="line">        &#x2F;&#x2F; Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">        Connection conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">        &#x2F;&#x2F;4.定义sql语句</span><br><span class="line">        &#x2F;&#x2F;String sql &#x3D; &quot;update account set balance &#x3D; 2000 where id &#x3D; 1&quot;;</span><br><span class="line">        String sql &#x3D; &quot;update account set balance &#x3D; 2000&quot;;</span><br><span class="line">        &#x2F;&#x2F;5.获取执行sql的对象 Statement</span><br><span class="line">        Statement stmt &#x3D; conn.createStatement();</span><br><span class="line">        &#x2F;&#x2F;6.执行sql</span><br><span class="line">        int count &#x3D; stmt.executeUpdate(sql);</span><br><span class="line">        &#x2F;&#x2F;7.处理结果</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        &#x2F;&#x2F;8.释放资源</span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-3-详解各个对象："><a href="#2-3-详解各个对象：" class="headerlink" title="2.3 详解各个对象："></a>2.3 详解各个对象：</h3><h4 id="2-3-1-DriverManager：驱动管理对象"><a href="#2-3-1-DriverManager：驱动管理对象" class="headerlink" title="2.3.1 DriverManager：驱动管理对象"></a>2.3.1 DriverManager：驱动管理对象</h4><ul>
<li><p>功能</p>
<ul>
<li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar</p>
<p>static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager</p>
<p>写代码使用： Class.forName(“com.mysql.jdbc.Driver”);</p>
<p>通过反射，加载与注册驱动类，<strong>解耦合（不直接依赖）</strong></p>
<p>通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  static &#123;</span><br><span class="line">  	try &#123;</span><br><span class="line">  		java.sql.DriverManager.registerDriver(new Driver());</span><br><span class="line">  	&#125; catch (SQLException E) &#123;</span><br><span class="line">  		throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>注意：mysql5之后的驱动jar包可以省略注册驱动的步骤</p>
</li>
<li><p>获取数据库连接：</p>
<ul>
<li><p>方法：static Connection getConnection(String url, String user, String password)</p>
</li>
<li><p>参数：</p>
<p><strong>JDBC URL</strong> 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。JDBC URL的标准由协议，子协议，子名称三部分组成，各部分间用冒号分隔。</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_4.png" alt="img"></a></p>
<p>参数url：指定连接的路径</p>
<ol>
<li>语法：jdbc:mysql://ip地址(域名):端口号/数据库名称</li>
<li>例子：jdbc:mysql://localhost:3306/db3</li>
<li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li>
</ol>
<p>user：用户名<br>password：密码</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-Connection：数据库连接对象"><a href="#2-3-2-Connection：数据库连接对象" class="headerlink" title="2.3.2 Connection：数据库连接对象"></a>2.3.2 Connection：数据库连接对象</h4><ul>
<li>功能<ul>
<li>获取执行sql 的对象</li>
<li>Statement createStatement()</li>
<li>PreparedStatement prepareStatement(String sql)</li>
</ul>
</li>
<li>管理事务：<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit()</li>
<li>回滚事务：rollback()</li>
</ul>
</li>
</ul>
<h4 id="2-3-3-Statement：执行sql的对象"><a href="#2-3-3-Statement：执行sql的对象" class="headerlink" title="2.3.3 Statement：执行sql的对象"></a>2.3.3 Statement：执行sql的对象</h4><ul>
<li><p>执行sql</p>
<ul>
<li>boolean execute(String sql) ：可以执行任意的sql 了解</li>
<li>int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句</li>
<li>ResultSet executeQuery(String sql) ：执行DQL（select)语句</li>
<li>PreparedStatement prepareStatement(String sql)</li>
</ul>
</li>
<li><p>代码: 对account表完成增删改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Statement stmt &#x3D; null;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 注册驱动</span><br><span class="line">            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;2. 定义sql(增删改)</span><br><span class="line">            String sql &#x3D; &quot;insert into account values(null,&#39;王五&#39;,3000)&quot;;</span><br><span class="line">            &#x2F;&#x2F;String sql  &#x3D; &quot;update account set balance &#x3D; 1500 where id &#x3D; 3&quot;;</span><br><span class="line">            &#x2F;&#x2F;String sql  &#x3D; &quot;delete from account where id &#x3D; 3&quot;;</span><br><span class="line">            &#x2F;&#x2F;3.获取Connection对象</span><br><span class="line">            conn &#x3D; DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;&#x2F;db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">            &#x2F;&#x2F;4.获取执行sql的对象 Statement</span><br><span class="line">            stmt &#x3D; conn.createStatement();</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            int count &#x3D; stmt.executeUpdate(sql);&#x2F;&#x2F;影响的行数</span><br><span class="line">            &#x2F;&#x2F;6.处理结果</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            if(count &gt; 0)&#123;</span><br><span class="line">                System.out.println(&quot;添加成功！&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                System.out.println(&quot;添加失败！&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            &#x2F;&#x2F;stmt.close();</span><br><span class="line">            &#x2F;&#x2F;7. 释放资源</span><br><span class="line">            &#x2F;&#x2F;避免空指针异常</span><br><span class="line">            if(stmt !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(conn !&#x3D; null)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：commit()</li>
<li>回滚事务：rollback()</li>
</ul>
</li>
</ul>
<h4 id="2-3-4-ResultSet：结果集对象-封装查询结果"><a href="#2-3-4-ResultSet：结果集对象-封装查询结果" class="headerlink" title="2.3.4 ResultSet：结果集对象,封装查询结果"></a>2.3.4 ResultSet：结果集对象,封装查询结果</h4><ul>
<li><p>boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true</p>
</li>
<li><p>getXxx(参数):获取数据</p>
<ul>
<li>Xxx：代表数据类型 如： int getInt() , String getString()</li>
<li>参数：<ol>
<li>int：代表列的编号, 从1开始 如: getString(1)</li>
<li>String：代表列名称, 如: getDouble(“balance”)</li>
</ol>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><p>使用步骤：</p>
<ul>
<li>游标向下移动一行</li>
<li>判断是否有数据</li>
<li>获取数据</li>
</ul>
</li>
<li><p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(rs.next())&#123;</span><br><span class="line">	&#x2F;&#x2F;获取数据</span><br><span class="line">	int id &#x3D; rs.getInt(1);</span><br><span class="line">	String name &#x3D; rs.getString(&quot;name&quot;);</span><br><span class="line">	double balance &#x3D; rs.getDouble(3);</span><br><span class="line">	System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);</span><br><span class="line">	&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-3-5-PreparedStatement：执行sql的对象"><a href="#2-3-5-PreparedStatement：执行sql的对象" class="headerlink" title="2.3.5 PreparedStatement：执行sql的对象"></a>2.3.5 PreparedStatement：执行sql的对象</h4><ul>
<li><p>SQL注入问题: 在拼接sql时, 有一些sql的特殊关键字参与字符串的拼接, 会造成安全性问题</p>
<ul>
<li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li>
<li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’</li>
</ul>
</li>
<li><p>解决sql注入问题：使用PreparedStatement对象来解决</p>
</li>
<li><p>预编译的SQL：参数使用 ? 作为占位符</p>
</li>
<li><p>步骤:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用PreparedStatement实现登录方法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean login(String username ,String password)&#123;</span><br><span class="line">    if(username &#x3D;&#x3D; null || password &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;连接数据库判断是否登录成功</span><br><span class="line">    Connection conn &#x3D; null;</span><br><span class="line">    PreparedStatement pstmt &#x3D;  null;</span><br><span class="line">    ResultSet rs &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F;1.获取连接</span><br><span class="line">    try &#123;</span><br><span class="line">        conn &#x3D;  JDBCUtils.getConnection();</span><br><span class="line">        &#x2F;&#x2F;2.定义sql</span><br><span class="line">        String sql &#x3D; &quot;select * from user where username &#x3D; ? and password &#x3D; ?&quot;;</span><br><span class="line">        &#x2F;&#x2F;3.获取执行sql的对象</span><br><span class="line">        pstmt &#x3D; conn.prepareStatement(sql);</span><br><span class="line">        &#x2F;&#x2F;给?赋值</span><br><span class="line">        pstmt.setString(1,username);</span><br><span class="line">        pstmt.setString(2,password);</span><br><span class="line">        &#x2F;&#x2F;4.执行查询,不需要传递sql</span><br><span class="line">        rs &#x3D; pstmt.executeQuery();</span><br><span class="line">        &#x2F;&#x2F;5.判断</span><br><span class="line">        &#x2F;* if(rs.next())&#123;&#x2F;&#x2F;如果有下一行，则返回true</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;*&#x2F;</span><br><span class="line">        return rs.next();&#x2F;&#x2F;如果有下一行，则返回true</span><br><span class="line"></span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        JDBCUtils.close(rs,pstmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p>
<ul>
<li>可以防止SQL注入</li>
<li>效率更高</li>
</ul>
</li>
</ul>
<h3 id="2-4-PreparedStatement-Statement-对比"><a href="#2-4-PreparedStatement-Statement-对比" class="headerlink" title="2.4 PreparedStatement/Statement 对比"></a>2.4 PreparedStatement/Statement 对比</h3><blockquote>
<p><strong>Blob类型的数据</strong> (了解)</p>
<ol>
<li>BLOB (binary large object)，二进制大对象，BLOB常常是数据库中用来存储二进制文件的字段类型。</li>
<li>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</li>
<li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
</ol>
<p>注意：如果存储的文件过大，数据库的性能会下降</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_5.png" alt="img"></a></p>
<p><strong>两者区别</strong></p>
<ul>
<li>代码的可读性和可维护性. Statement的sql拼接是个难题。</li>
<li>PreparedStatement 可以防止 SQL 注入</li>
<li>PreparedStatement 可以处理Blob类型的数据</li>
<li>PreparedStatement 能最大可能提高性能<ul>
<li>Oracle和PostgreSQL8是这样，但是对于MySQL不一定比Statement高</li>
<li>DBServer会对预编译语句提供性能优化。因为预编译语句有可能被重复调用，所以语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行</li>
</ul>
</li>
</ul>
<h2 id="3-JDBCUtils-抽取JDBC工具类"><a href="#3-JDBCUtils-抽取JDBC工具类" class="headerlink" title="3. JDBCUtils: 抽取JDBC工具类"></a>3. JDBCUtils: 抽取JDBC工具类</h2><ul>
<li><p>目的：简化书写</p>
</li>
<li><p>分析：</p>
<ol>
<li><p>注册驱动也抽取</p>
</li>
<li><p>抽取一个方法获取连接对象</p>
<ul>
<li><p>需求：不想传递参数（麻烦），还得保证工具类的通用性。</p>
</li>
<li><p>解决：配置文件</p>
<p>jdbc.properties<br>url=<br>user=<br>password=</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>抽取一个方法释放资源</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JDBC工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtils &#123;</span><br><span class="line">    private static String url;</span><br><span class="line">    private static String user;</span><br><span class="line">    private static String password;</span><br><span class="line">    private static String driver;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static&#123;</span><br><span class="line">        &#x2F;&#x2F;读取资源文件，获取值。</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1. 创建Properties集合类。</span><br><span class="line">            Properties pro &#x3D; new Properties();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br><span class="line">            ClassLoader classLoader &#x3D; JDBCUtils.class.getClassLoader();</span><br><span class="line">            URL res  &#x3D; classLoader.getResource(&quot;jdbc.properties&quot;);</span><br><span class="line">            String path &#x3D; res.getPath();</span><br><span class="line">           &#x2F;&#x2F; System.out.println(path);&#x2F;&#x2F;&#x2F;D:&#x2F;IdeaProjects&#x2F;itcast&#x2F;out&#x2F;production&#x2F;day04_jdbc&#x2F;jdbc.properties</span><br><span class="line">            &#x2F;&#x2F;2. 加载文件</span><br><span class="line">           &#x2F;&#x2F; pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br><span class="line">            pro.load(new FileReader(path));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;3. 获取数据，赋值</span><br><span class="line">            url &#x3D; pro.getProperty(&quot;url&quot;);</span><br><span class="line">            user &#x3D; pro.getProperty(&quot;user&quot;);</span><br><span class="line">            password &#x3D; pro.getProperty(&quot;password&quot;);</span><br><span class="line">            driver &#x3D; pro.getProperty(&quot;driver&quot;);</span><br><span class="line">            &#x2F;&#x2F;4. 注册驱动</span><br><span class="line">            Class.forName(driver);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接</span><br><span class="line">     * @return 连接对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">        return DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     * @param stmt</span><br><span class="line">     * @param conn</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">        if( stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if( conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     * @param stmt</span><br><span class="line">     * @param conn</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;</span><br><span class="line">        if( rs !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if( conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="4-JDBC控制事务"><a href="#4-JDBC控制事务" class="headerlink" title="4. JDBC控制事务"></a>4. JDBC控制事务</h2><ol>
<li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p>
</li>
<li><p>操作：</p>
<ol>
<li>开启事务</li>
<li>提交事务</li>
<li>回滚事务</li>
</ol>
</li>
<li><p>使用Connection对象来管理事务</p>
<ul>
<li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul>
<li>在执行sql之前开启事务</li>
</ul>
</li>
<li>提交事务：commit()<ul>
<li>当所有sql都执行完提交事务</li>
</ul>
</li>
<li>回滚事务：rollback()<ul>
<li>在catch中回滚事务</li>
</ul>
</li>
</ul>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 事务操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Connection conn &#x3D; null;</span><br><span class="line">        PreparedStatement pstmt1 &#x3D; null;</span><br><span class="line">        PreparedStatement pstmt2 &#x3D; null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.获取连接</span><br><span class="line">            conn &#x3D; JDBCUtils.getConnection();</span><br><span class="line">            &#x2F;&#x2F;开启事务</span><br><span class="line">            conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;2.定义sql</span><br><span class="line">            &#x2F;&#x2F;2.1 张三 - 500</span><br><span class="line">            String sql1 &#x3D; &quot;update account set balance &#x3D; balance - ? where id &#x3D; ?&quot;;</span><br><span class="line">            &#x2F;&#x2F;2.2 李四 + 500</span><br><span class="line">            String sql2 &#x3D; &quot;update account set balance &#x3D; balance + ? where id &#x3D; ?&quot;;</span><br><span class="line">            &#x2F;&#x2F;3.获取执行sql对象</span><br><span class="line">            pstmt1 &#x3D; conn.prepareStatement(sql1);</span><br><span class="line">            pstmt2 &#x3D; conn.prepareStatement(sql2);</span><br><span class="line">            &#x2F;&#x2F;4. 设置参数</span><br><span class="line">            pstmt1.setDouble(1,500);</span><br><span class="line">            pstmt1.setInt(2,1);</span><br><span class="line"></span><br><span class="line">            pstmt2.setDouble(1,500);</span><br><span class="line">            pstmt2.setInt(2,2);</span><br><span class="line">            &#x2F;&#x2F;5.执行sql</span><br><span class="line">            pstmt1.executeUpdate();</span><br><span class="line">            &#x2F;&#x2F; 手动制造异常</span><br><span class="line">            int i &#x3D; 3&#x2F;0;</span><br><span class="line"></span><br><span class="line">            pstmt2.executeUpdate();</span><br><span class="line">            &#x2F;&#x2F;提交事务</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            &#x2F;&#x2F;事务回滚</span><br><span class="line">            try &#123;</span><br><span class="line">                if(conn !&#x3D; null) &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;finally &#123;</span><br><span class="line">            JDBCUtils.close(pstmt1,conn);</span><br><span class="line">            JDBCUtils.close(pstmt2,null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-批处理"><a href="#5-批处理" class="headerlink" title="5. 批处理"></a>5. 批处理</h2><p>当需要成批插入或者更新记录时。可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。</p>
<blockquote>
<p>注意:</p>
<ol>
<li>不是所用版本的mysql都支持</li>
<li><strong>JDBC</strong>连接MySQL时，如果要使用批处理功能，请再ur中加参数?rewriteBatchedStatements=true</li>
<li><strong>PreparedStatement</strong>作批处理插入时使用values（使用value没有效果）</li>
</ol>
</blockquote>
<h3 id="5-1-JDBC的批量处理语句包括下面方法："><a href="#5-1-JDBC的批量处理语句包括下面方法：" class="headerlink" title="5.1 JDBC的批量处理语句包括下面方法："></a>5.1 JDBC的批量处理语句包括下面方法：</h3><ul>
<li><strong>addBatch</strong>()：添加需要批量处理的SQL语句或参数</li>
<li><strong>executeBatch</strong>()：执行批量处理语句；</li>
<li><strong>clearBatch</strong>():清空批处理包的语句</li>
</ul>
<h3 id="5-2-批量执行SQL语句的两种情况"><a href="#5-2-批量执行SQL语句的两种情况" class="headerlink" title="5.2 批量执行SQL语句的两种情况"></a>5.2 批量执行SQL语句的两种情况</h3><ul>
<li><p>多条SQL语句的批量处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Statement st &#x3D; conn.createStatement();</span><br><span class="line">st.addBatch(sql1);</span><br><span class="line">st.addBatch(sql2);</span><br><span class="line">...</span><br><span class="line">st.addBatch(sqln);</span><br><span class="line">st.executeBatch();</span><br><span class="line">st.clearBatch();</span><br><span class="line">...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p><strong>一个SQL语句的批量传参</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">PreparedStatement pst &#x3D; conn.prepareStatement(sql);</span><br><span class="line">for(int i &#x3D; 100; i &lt; 1001; i++)&#123;</span><br><span class="line">	pst.setInt(1, i);</span><br><span class="line">	...</span><br><span class="line">	pst.addBatch();</span><br><span class="line">&#125;</span><br><span class="line">pst.executeBatch();</span><br><span class="line">st.clearBatch();</span><br><span class="line">...</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-Blob类型数据的读写（了解）"><a href="#6-Blob类型数据的读写（了解）" class="headerlink" title="6. Blob类型数据的读写（了解）"></a>6. Blob类型数据的读写（了解）</h2><ul>
<li>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</li>
<li>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</li>
<li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li>
<li>需要注意的是：如果存储的文件过大，数据库的性能会下降</li>
</ul>
<p>写入：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_6.png" alt="img"></a></p>
<p>读取：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_7.png" alt="img"></a></p>
<h2 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h2><ol>
<li><p>概念：其实就是一个容器(集合)，存放数据库连接的容器。</p>
<p>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p>
</li>
<li><p>好处：</p>
<ul>
<li>节约资源</li>
<li>用户访问高效</li>
</ul>
</li>
<li><p>实现：</p>
</li>
</ol>
<ul>
<li><p>标准接口：DataSource javax.sql包下的</p>
<p>方法：</p>
<ul>
<li>获取连接：getConnection()</li>
<li>归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接</li>
</ul>
</li>
<li><p>一般我们不去实现它，有数据库厂商来实现</p>
<ul>
<li>C3P0：数据库连接池技术</li>
<li>Druid：数据库连接池实现技术，由阿里巴巴提供的</li>
</ul>
</li>
</ul>
<ol>
<li>C3P0：数据库连接池技术</li>
</ol>
<ul>
<li>步骤：</li>
</ul>
<ol>
<li>导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，<ul>
<li>不要忘记导入数据库驱动jar包</li>
</ul>
</li>
<li>定义配置文件：<ul>
<li>名称： c3p0.properties 或者 c3p0-config.xml</li>
<li>路径：直接将文件放在src目录下即可。</li>
</ul>
</li>
<li>创建核心对象 数据库连接池对象 ComboPooledDataSource</li>
<li>获取连接： getConnection</li>
</ol>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * c3p0的演示</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class C3P0Demo &#123;</span><br><span class="line">    public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建数据库连接池对象</span><br><span class="line">        DataSource ds  &#x3D; new ComboPooledDataSource();</span><br><span class="line">        &#x2F;&#x2F;2. 获取连接对象</span><br><span class="line">        Connection conn &#x3D; ds.getConnection();</span><br><span class="line">        &#x2F;&#x2F;3. 打印</span><br><span class="line">        System.out.println(conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Druid：数据库连接池实现技术，由阿里巴巴提供的</p>
<ol>
<li>步骤：<ol>
<li>导入jar包 druid-1.0.9.jar</li>
<li>定义配置文件：<ul>
<li>是properties形式的</li>
<li>可以叫任意名称，可以放在任意目录下</li>
</ul>
</li>
<li>加载配置文件。Properties</li>
<li>获取数据库连接池对象：通过工厂来来获取 DruidDataSourceFactory</li>
<li>获取连接：getConnection</li>
</ol>
</li>
</ol>
<ul>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;**</span><br><span class="line">   * Druid演示</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public class DruidDemo &#123;</span><br><span class="line">      public static void main(String[] args) throws Exception &#123;</span><br><span class="line">          &#x2F;&#x2F;1.导入jar包</span><br><span class="line">        &#x2F;&#x2F;2.定义配置文件</span><br><span class="line">        &#x2F;&#x2F;3.加载配置文件</span><br><span class="line">        Properties pro &#x3D; new Properties();</span><br><span class="line">        InputStream is &#x3D; DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        &#x2F;&#x2F;4.获取连接池对象</span><br><span class="line">        DataSource ds &#x3D; DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#x2F;&#x2F;5.获取连接</span><br><span class="line">        Connection conn &#x3D; ds.getConnection();</span><br><span class="line">        System.out.println(conn);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>定义工具类</p>
<ol>
<li><p>定义一个类 JDBCUtils</p>
</li>
<li><p>提供静态代码块加载配置文件，初始化连接池对象</p>
</li>
<li><p>提供方法</p>
<ol>
<li>获取连接方法：通过数据库连接池获取连接</li>
<li>释放资源</li>
<li>获取连接池的方法</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Druid连接池的工具类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JDBCUtils &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;1.定义成员变量 DataSource</span><br><span class="line">    private static DataSource ds ;</span><br><span class="line"></span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;1.加载配置文件</span><br><span class="line">            Properties pro &#x3D; new Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">            &#x2F;&#x2F;2.获取DataSource</span><br><span class="line">            ds &#x3D; DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">        return ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 释放资源</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">       close(null,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;</span><br><span class="line">        if(rs !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(stmt !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(conn !&#x3D; null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();&#x2F;&#x2F;归还连接</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取连接池方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static DataSource getDataSource()&#123;</span><br><span class="line">        return  ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）"><a href="#8-Spring-JDBC（DBUtils也比较常用，这里就不介绍了）" class="headerlink" title="8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）"></a>8. Spring JDBC（DBUtils也比较常用，这里就不介绍了）</h2><ul>
<li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>导入jar包</p>
</li>
<li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p>
<ul>
<li>JdbcTemplate template = new JdbcTemplate(ds);</li>
</ul>
</li>
<li><p>调用JdbcTemplate的方法来完成CRUD的操作</p>
<ul>
<li><p>update():执行DML语句。增、删、改语句</p>
</li>
<li><p>queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p>
<p>注意：这个方法查询的结果集长度只能是1</p>
</li>
<li><p>queryForList():查询结果将结果集封装为list集合</p>
<p>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p>
</li>
<li><p>query():查询结果，将结果封装为JavaBean对象</p>
</li>
<li><p>query的参数：RowMapper</p>
</li>
</ul>
</li>
<li><p>一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p>
</li>
<li><p>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p>
<ul>
<li><p>queryForObject：查询结果，将结果封装为对象</p>
<p>一般用于聚合函数的查询</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jdbctemplate;</span><br><span class="line">import cn.itcast.utils.JDBCUtils;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * JdbcTemplate入门</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class JdbcTemplateDemo1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;1.导入jar包</span><br><span class="line">        &#x2F;&#x2F;2.创建JDBCTemplate对象</span><br><span class="line">        JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">        &#x2F;&#x2F;3.调用方法</span><br><span class="line">        String sql &#x3D; &quot;update account set balance &#x3D; 5000 where id &#x3D; ?&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 3);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.jdbctemplate;</span><br><span class="line"></span><br><span class="line">import cn.itcast.domain.Emp;</span><br><span class="line">import cn.itcast.utils.JDBCUtils;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">import java.sql.Date;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JdbcTemplateDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Junit单元测试，可以让方法独立执行</span><br><span class="line">    &#x2F;&#x2F;1. 获取JDBCTemplate对象</span><br><span class="line">    private JdbcTemplate template &#x3D; new JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 1. 修改1号数据的 salary 为 10000</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;2. 定义sql</span><br><span class="line">        String sql &#x3D; &quot;update emp set salary &#x3D; 10000 where id &#x3D; 1001&quot;;</span><br><span class="line">        &#x2F;&#x2F;3. 执行sql</span><br><span class="line">        int count &#x3D; template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 2. 添加一条记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        String sql &#x3D; &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 1015, &quot;郭靖&quot;, 10);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 3.删除刚才添加的记录</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        String sql &#x3D; &quot;delete from emp where id &#x3D; ?&quot;;</span><br><span class="line">        int count &#x3D; template.update(sql, 1015);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="line">     * 注意：这个方法查询的结果集长度只能是1</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp where id &#x3D; ? or id &#x3D; ?&quot;;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; template.queryForMap(sql, 1001,1002);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        &#x2F;&#x2F;&#123;id&#x3D;1001, ename&#x3D;孙悟空, job_id&#x3D;4, mgr&#x3D;1004, joindate&#x3D;2000-12-17, salary&#x3D;10000.00, bonus&#x3D;null, dept_id&#x3D;20&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 5. 查询所有记录，将其封装为List</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list &#x3D; template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list &#x3D; template.query(sql, new RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;</span><br><span class="line">                Emp emp &#x3D; new Emp();</span><br><span class="line">                int id &#x3D; rs.getInt(&quot;id&quot;);</span><br><span class="line">                String ename &#x3D; rs.getString(&quot;ename&quot;);</span><br><span class="line">                int job_id &#x3D; rs.getInt(&quot;job_id&quot;);</span><br><span class="line">                int mgr &#x3D; rs.getInt(&quot;mgr&quot;);</span><br><span class="line">                Date joindate &#x3D; rs.getDate(&quot;joindate&quot;);</span><br><span class="line">                double salary &#x3D; rs.getDouble(&quot;salary&quot;);</span><br><span class="line">                double bonus &#x3D; rs.getDouble(&quot;bonus&quot;);</span><br><span class="line">                int dept_id &#x3D; rs.getInt(&quot;dept_id&quot;);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                return emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6_2()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list &#x3D; template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 7. 查询总记录数</span><br><span class="line">     *&#x2F;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test7()&#123;</span><br><span class="line">        String sql &#x3D; &quot;select count(id) from emp&quot;;</span><br><span class="line">        Long total &#x3D; template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>表与JavaBean的关系</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/JDBC_8(2).png" alt="img"></a></p>
</li>
</ul>
<h2 id="9-DAO层"><a href="#9-DAO层" class="headerlink" title="9. DAO层"></a>9. DAO层</h2><ul>
<li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息</li>
<li>作用：为了实现功能的模块化，更有利于代码的维护和升级</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/JDBC/" data-id="ckqujm00b0005c4ub26ef3shy" data-title="JDBC" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/MySQL%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T11:27:16.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/MySQL%E5%9F%BA%E7%A1%80/">MySQL基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h1><p><strong>基于<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12b411K7Zu">尚硅谷MySQL视频</a>的学习笔记</strong></p>
<h2 id="1-初识MySQL"><a href="#1-初识MySQL" class="headerlink" title="1. 初识MySQL"></a>1. 初识MySQL</h2><h3 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h3><ul>
<li><p>数据库的常见概念 ★<br>1、DB：数据库，存储数据的容器<br>2、DBMS：数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理DB<br>3、SQL：结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p>
</li>
<li><p>数据库存储数据的特点<br>1、数据存放到表中，然后表再放到库中<br>2、一个库中可以有多张表，每张表具有唯一的表名用来标识自己<br>3、表中有一个或多个列，<strong>列</strong>又称为“<strong>字段</strong>”，相当于java中“<strong>属性</strong>”<br>4、表中的<strong>每一行数据</strong>，相当于java中“<strong>对象</strong>”</p>
</li>
<li><p>常见的数据库管理系统<br>mysql、oracle、db2、sqlserver</p>
</li>
</ul>
<h3 id="1-2-MySQL介绍"><a href="#1-2-MySQL介绍" class="headerlink" title="1.2 MySQL介绍"></a>1.2 MySQL介绍</h3><ul>
<li><p>MySQL的背景<br>前身属于瑞典的一家公司，MySQL AB<br>08年被sun公司收购<br>09年sun被oracle收购</p>
</li>
<li><p>MySQL的优点</p>
<ul>
<li>开源、免费、成本低</li>
<li>性能高、移植性也好</li>
<li>体积小，便于安装</li>
</ul>
</li>
<li><p>MySQL服务的启动和停止</p>
<ul>
<li><p>方式一：通过命令行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net start 服务名</span><br><span class="line">net stop 服务名</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：计算机——右击——管理——服务</p>
</li>
</ul>
</li>
<li><p>MySQL服务的登录和退出</p>
<ul>
<li><p>登录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql 【-h 主机名 -P 端口号】 -u 用户名 -p密码</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit 或 ctrl+C</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>MySQL的常见命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1.查看当前所有的数据库</span><br><span class="line">show databases;</span><br><span class="line"># 2.打开指定的库</span><br><span class="line">use 库名</span><br><span class="line"># 3.查看当前库的所有表</span><br><span class="line">show tables;</span><br><span class="line"># 4.查看其它库的所有表</span><br><span class="line">show tables from 库名;</span><br><span class="line"># 5.创建表</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 列类型,</span><br><span class="line">	列名 列类型，</span><br><span class="line">	...</span><br><span class="line">);</span><br><span class="line"># 6.查看表结构</span><br><span class="line">desc 表名;</span><br><span class="line"># 7.查看服务器的版本</span><br><span class="line"># 方式一：登录到mysql服务端</span><br><span class="line">select version();</span><br><span class="line"># 方式二：没有登录到mysql服务端</span><br><span class="line">mysql --version</span><br><span class="line"># 或</span><br><span class="line">mysql --V</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>MySQL的语法规范</p>
<ol>
<li>不区分大小写,但建议关键字大写，表名、列名小写</li>
<li>每条命令最好用分号结尾</li>
<li>每条命令根据需要，可以进行缩进 或换行</li>
<li>注释<ul>
<li>单行注释：#注释文字</li>
<li>单行注释：– 注释文字</li>
<li>多行注释：/* 注释文字 */</li>
</ul>
</li>
</ol>
</li>
<li><p>SQL的语言分类</p>
<ul>
<li><p>DQL（Data Query Language）：数据查询语言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    select </span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>DML(Data Manipulate Language):数据操作语言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    insert 、update、delete</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>DDL（Data Define Languge）：数据定义语言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    create、drop、alter</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>TCL（Transaction Control Language）：事务控制语言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    commit、rollback</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="2-DQL语言"><a href="#2-DQL语言" class="headerlink" title="2. DQL语言"></a>2. DQL语言</h2><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 1、查询单个字段</span><br><span class="line">select 字段名 from 表名;</span><br><span class="line"></span><br><span class="line"># 2、查询多个字段</span><br><span class="line">select 字段名，字段名 from 表名;</span><br><span class="line"></span><br><span class="line"># 3、查询所有字段</span><br><span class="line">select * from 表名;</span><br><span class="line"></span><br><span class="line"># 4、查询常量</span><br><span class="line"># 注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要</span><br><span class="line">select 常量值;</span><br><span class="line"></span><br><span class="line"># 5、查询函数</span><br><span class="line">select 函数名(实参列表);</span><br><span class="line"></span><br><span class="line"># 6、查询表达式</span><br><span class="line">select 100&#x2F;1234;</span><br><span class="line"></span><br><span class="line"># 7、起别名</span><br><span class="line"># ① as</span><br><span class="line"># ② 空格</span><br><span class="line"></span><br><span class="line"># 8、去重</span><br><span class="line">select distinct 字段名 from 表名;</span><br><span class="line"></span><br><span class="line"># 9、+</span><br><span class="line"># 作用：做加法运算</span><br><span class="line">select 数值+数值;  # 直接运算</span><br><span class="line">select 字符+数值;  # 先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算</span><br><span class="line">select null+值;  # 结果都为null</span><br><span class="line"></span><br><span class="line"># 10、【补充】concat函数</span><br><span class="line"># 功能：拼接字符</span><br><span class="line">select concat(字符1，字符2，字符3,...);</span><br><span class="line"></span><br><span class="line"># 11、【补充】ifnull函数</span><br><span class="line"># 功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</span><br><span class="line">select ifnull(commission_pct,0) from employees;</span><br><span class="line"></span><br><span class="line"># 12、【补充】isnull函数</span><br><span class="line"># 功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 1.条件查询的基本结构</span><br><span class="line">select 查询列表 from 表名 where 筛选条件</span><br><span class="line"></span><br><span class="line"># 2.简单条件运算符</span><br><span class="line">&gt; &lt; &#x3D; &lt;&gt; !&#x3D; &gt;&#x3D; &lt;&#x3D;  </span><br><span class="line">&lt;&#x3D;&gt;安全等于 # 可以判断null值</span><br><span class="line"></span><br><span class="line"># 3. 逻辑运算符</span><br><span class="line">&amp;&amp; and</span><br><span class="line">|| or</span><br><span class="line">!  not</span><br><span class="line"></span><br><span class="line"># 4、模糊查询</span><br><span class="line">between and # 左右边界不能颠倒顺序</span><br><span class="line">between 120 and 100 # 等价于 &gt;&#x3D; 120 &amp;&amp; &lt;&#x3D; 100 </span><br><span class="line"></span><br><span class="line">in (&#39;&#39;, &#39;&#39;) # in列表值类型必须统一,且不支持通配符</span><br><span class="line">is null &#x2F;is not null  # 用于判断null值, &#x3D; 不能判断null</span><br><span class="line">like  # 一般搭配通配符使用，可以判断字符型或数值型 </span><br><span class="line"></span><br><span class="line"># 5.通配符：</span><br><span class="line">%：任意多个字符</span><br><span class="line">_：任意单个字符</span><br><span class="line">通配符转义 \ 或者 &#39;_$_&#39; ESCAPE &#39;$&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			普通类型的数值	  null值		   可读性</span><br><span class="line">is null		×			   √		      √</span><br><span class="line">&lt;&#x3D;&gt;		    √			   √		      ×</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>经典面试题</strong> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from employees;</span><br><span class="line">select * from employees where name like &#39;%%&#39; and id like &#39;%%&#39;;</span><br><span class="line">两个查询语句的执行结果是否相同？</span><br><span class="line">解：不一样，若name或者id有null值则查不出来</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1. 排序查询的基本结构</span><br><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">where 筛选条件</span><br><span class="line">order by 排序列表 [asc&#125;desc]</span><br><span class="line"></span><br><span class="line"># 2. 特点</span><br><span class="line">&#x2F;*</span><br><span class="line">1、asc ：升序，如果不写默认升序</span><br><span class="line">   desc：降序</span><br><span class="line">2、排序列表 支持 单个字段、多个字段、函数、表达式、别名</span><br><span class="line">3、order by的位置一般放在查询语句的最后（除limit语句之外）</span><br><span class="line">*&#x2F;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-4-常见函数"><a href="#2-4-常见函数" class="headerlink" title="2.4 常见函数"></a>2.4 常见函数</h3><ul>
<li>功能：类似于java中的方法</li>
<li>好处：提高重用性和隐藏实现细节</li>
<li>调用：select 函数名(实参列表);</li>
</ul>
<p>单行函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"># 1、字符函数</span><br><span class="line"># concat:连接</span><br><span class="line"># substr:截取子串，索引从1开始</span><br><span class="line"># upper:变大写</span><br><span class="line"># lower：变小写</span><br><span class="line"># replace：替换</span><br><span class="line"># length：获取字节长度</span><br><span class="line"># trim:去前后空格</span><br><span class="line"># lpad：左填充</span><br><span class="line"># rpad：右填充</span><br><span class="line"># instr:获取子串第一次出现的索引</span><br><span class="line"></span><br><span class="line">SELECT LENGTH(&#39;john&#39;);</span><br><span class="line">SELECT CONCAT(last_name,&#39;_&#39;,first_name) 姓名 FROM employees;</span><br><span class="line">SELECT UPPER(&#39;john&#39;);</span><br><span class="line">SELECT LOWER(&#39;joHn&#39;);</span><br><span class="line">SELECT </span><br><span class="line">CONCAT(UPPER(last_name),LOWER(first_name))  姓名 </span><br><span class="line">FROM employees;</span><br><span class="line">SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,7)  out_put;</span><br><span class="line">SELECT SUBSTR(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;</span><br><span class="line">SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),&#39;_&#39;,LOWER(SUBSTR(last_name,2)))  out_put</span><br><span class="line">FROM employees;</span><br><span class="line">SELECT INSTR(&#39;杨不殷六侠悔爱上了殷六侠&#39;,&#39;殷八侠&#39;) AS out_put;</span><br><span class="line">SELECT LENGTH(TRIM(&#39;    张翠山    &#39;)) AS out_put;</span><br><span class="line">SELECT TRIM(&#39;aa&#39; FROM &#39;aaaaaa张aaaa翠山aaaaa&#39;) AS out_put;</span><br><span class="line">SELECT LPAD(&#39;殷素素&#39;,2,&#39;*&#39;) AS out_put;</span><br><span class="line">SELECT RPAD(&#39;殷素素&#39;,12,&#39;ab&#39;) AS out_put;</span><br><span class="line">SELECT REPLACE(&#39;周芷若周芷若张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) AS out_put;</span><br><span class="line"></span><br><span class="line"># 2、数学函数</span><br><span class="line"># ceil:向上取整</span><br><span class="line"># round：四舍五入</span><br><span class="line"># mod:取模</span><br><span class="line"># floor：向下取整</span><br><span class="line"># truncate:截断</span><br><span class="line"># rand:获取随机数，返回0-1之间的小数</span><br><span class="line">SELECT ROUND(-1.55);</span><br><span class="line">SELECT ROUND(1.567,2);</span><br><span class="line">SELECT CEIL(-1.02);</span><br><span class="line">SELECT FLOOR(-9.99);</span><br><span class="line">SELECT TRUNCATE(1.69999,1);</span><br><span class="line">#mod取余</span><br><span class="line">&#x2F;*</span><br><span class="line">mod(a,b) ：  a-a&#x2F;b*b</span><br><span class="line">mod(-10,-3):-10- (-10)&#x2F;(-3)*（-3）&#x3D;-1</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT MOD(10,-3);</span><br><span class="line">SELECT 10%3;</span><br><span class="line"></span><br><span class="line"># 3、日期函数</span><br><span class="line"># now：返回当前日期+时间</span><br><span class="line"># year:返回年</span><br><span class="line"># month：返回月</span><br><span class="line"># day:返回日</span><br><span class="line"># date_format:将日期转换成字符</span><br><span class="line"># curdate:返回当前日期</span><br><span class="line"># str_to_date:将字符转换成日期</span><br><span class="line"># curtime：返回当前时间</span><br><span class="line"># hour:小时</span><br><span class="line"># minute:分钟</span><br><span class="line"># second：秒</span><br><span class="line"># datediff:返回两个日期相差的天数</span><br><span class="line"># monthname:以英文形式返回月</span><br><span class="line">SELECT NOW();</span><br><span class="line">SELECT CURDATE();</span><br><span class="line">SELECT CURTIME();</span><br><span class="line">SELECT YEAR(NOW()) 年;</span><br><span class="line">SELECT YEAR(&#39;1998-1-1&#39;) 年;</span><br><span class="line">SELECT  YEAR(hiredate) 年 FROM employees;</span><br><span class="line">SELECT MONTH(NOW()) 月;</span><br><span class="line">SELECT MONTHNAME(NOW()) 月;</span><br><span class="line">SELECT STR_TO_DATE(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) AS out_put;</span><br><span class="line">#查询入职日期为1992--4-3的员工信息</span><br><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; &#39;1992-4-3&#39;;</span><br><span class="line">SELECT * FROM employees WHERE hiredate &#x3D; STR_TO_DATE(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);</span><br><span class="line">SELECT DATE_FORMAT(NOW(),&#39;%y年%m月%d日&#39;) AS out_put;</span><br><span class="line">#查询有奖金的员工名和入职日期(xx月&#x2F;xx日 xx年)</span><br><span class="line">SELECT last_name,DATE_FORMAT(hiredate,&#39;%m月&#x2F;%d日 %y年&#39;) 入职日期</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL;</span><br><span class="line"></span><br><span class="line"># 4、其他函数</span><br><span class="line"># version 当前数据库服务器的版本</span><br><span class="line"># database 当前打开的数据库</span><br><span class="line"># user当前用户</span><br><span class="line"># password(&#39;字符&#39;)：返回该字符的密码形式</span><br><span class="line"># md5(&#39;字符&#39;):返回该字符的md5加密形式</span><br><span class="line">SELECT VERSION();</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">SELECT USER();</span><br><span class="line"></span><br><span class="line">#5、流程控制函数</span><br><span class="line">&#x2F;*</span><br><span class="line">①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2</span><br><span class="line">②case情况1</span><br><span class="line">case 变量或表达式或字段</span><br><span class="line">when 常量1 then 值1</span><br><span class="line">when 常量2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">③case情况2</span><br><span class="line">case </span><br><span class="line">when 条件1 then 值1</span><br><span class="line">when 条件2 then 值2</span><br><span class="line">...</span><br><span class="line">else 值n</span><br><span class="line">end</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT IF(10&lt;5,&#39;大&#39;,&#39;小&#39;);</span><br><span class="line"></span><br><span class="line">SELECT salary 原始工资,department_id,</span><br><span class="line">CASE department_id</span><br><span class="line">WHEN 30 THEN salary*1.1</span><br><span class="line">WHEN 40 THEN salary*1.2</span><br><span class="line">WHEN 50 THEN salary*1.3</span><br><span class="line">ELSE salary</span><br><span class="line">END AS 新工资</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT salary,</span><br><span class="line">CASE </span><br><span class="line">WHEN salary&gt;20000 THEN &#39;A&#39;</span><br><span class="line">WHEN salary&gt;15000 THEN &#39;B&#39;</span><br><span class="line">WHEN salary&gt;10000 THEN &#39;C&#39;</span><br><span class="line">ELSE &#39;D&#39;</span><br><span class="line">END AS 工资级别</span><br><span class="line">FROM employees;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>分组函数(统计函数\聚合函数)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 1.分类</span><br><span class="line">max 最大值</span><br><span class="line">min 最小值</span><br><span class="line">sum 和</span><br><span class="line">avg 平均值</span><br><span class="line">count 计算个数</span><br><span class="line"></span><br><span class="line"># 2.简单 的使用</span><br><span class="line">SELECT SUM(salary) FROM employees;</span><br><span class="line">SELECT AVG(salary) FROM employees;</span><br><span class="line">SELECT MIN(salary) FROM employees;</span><br><span class="line">SELECT MAX(salary) FROM employees;</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"># 3、参数支持哪些类型</span><br><span class="line"># sum和avg一般用于处理数值型</span><br><span class="line"># max、min、count可以处理任何数据类型</span><br><span class="line">SELECT SUM(last_name) ,AVG(last_name) FROM employees;</span><br><span class="line">SELECT SUM(hiredate) ,AVG(hiredate) FROM employees;</span><br><span class="line">SELECT MAX(last_name),MIN(last_name) FROM employees;</span><br><span class="line">SELECT MAX(hiredate),MIN(hiredate) FROM employees;</span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT COUNT(last_name) FROM employees;</span><br><span class="line"></span><br><span class="line"># 4、是否忽略null(以上分组函数都忽略)</span><br><span class="line">SELECT SUM(commission_pct) ,AVG(commission_pct),SUM(commission_pct)&#x2F;35,SUM(commission_pct)&#x2F;107 FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT MAX(commission_pct) ,MIN(commission_pct) FROM employees;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(commission_pct) FROM employees;</span><br><span class="line">SELECT commission_pct FROM employees;</span><br><span class="line"></span><br><span class="line"># 5、和distinct搭配</span><br><span class="line">SELECT SUM(DISTINCT salary),SUM(salary) FROM employees;</span><br><span class="line">SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;</span><br><span class="line"></span><br><span class="line"># 6、count函数的详细介绍</span><br><span class="line">count(字段)：统计该字段非空值的个数</span><br><span class="line">count(*):统计结果集的行数</span><br><span class="line">SELECT COUNT(salary) FROM employees;</span><br><span class="line">SELECT COUNT(*) FROM employees;</span><br><span class="line">SELECT COUNT(1) FROM employees;</span><br><span class="line"></span><br><span class="line">效率：</span><br><span class="line">MYISAM存储引擎下，COUNT(*)的效率高</span><br><span class="line">INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</span><br><span class="line"></span><br><span class="line">#6、和分组函数一同查询的字段有限制,要求是group by后出现的字段</span><br><span class="line">SELECT AVG(salary),employee_id  FROM employees; # 这个查询没有意义</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 1.分组查询的基本结构</span><br><span class="line">select 分组函数，分组后的字段</span><br><span class="line">from 表</span><br><span class="line">[where 筛选条件]</span><br><span class="line">group by 分组的字段</span><br><span class="line">[having 分组后的筛选]</span><br><span class="line">[order by 排序列表]</span><br><span class="line"></span><br><span class="line"># 2.筛选对比</span><br><span class="line">			使用关键字		筛选的表	位置</span><br><span class="line">分组前筛选	where			原始表		 group by的前面</span><br><span class="line">分组后筛选	having		分组后的结果	   group by 的后面</span><br><span class="line"></span><br><span class="line"># 3. 常见问题</span><br><span class="line">1：分组函数做筛选能不能放在where后面</span><br><span class="line">答：不能</span><br><span class="line"></span><br><span class="line">2：where——group by——having</span><br><span class="line">答：一般来讲，能用分组前筛选的，尽量使用分组前筛选，提高效率</span><br><span class="line"></span><br><span class="line">3、分组可以按单个字段也可以按多个字段</span><br><span class="line">4、可以搭配着排序使用</span><br><span class="line"></span><br><span class="line"># 4. 一些示例</span><br><span class="line">#案例1：查询每个工种的员工平均工资</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line">#案例2：每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line">SELECT job_id,MAX(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING MAX(salary)&gt;12000;</span><br><span class="line">#案例3：每个工种有奖金的员工的最高工资&gt;6000的工种编号和最高工资,按最高工资升序</span><br><span class="line">SELECT job_id,MAX(salary) m</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY job_id</span><br><span class="line">HAVING m&gt;6000</span><br><span class="line">ORDER BY m ;</span><br><span class="line">#案例4：查询每个工种每个部门的最低工资,并按最低工资降序</span><br><span class="line">SELECT MIN(salary),job_id,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id,job_id</span><br><span class="line">ORDER BY MIN(salary) DESC;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-6-连接查询"><a href="#2-6-连接查询" class="headerlink" title="2.6 连接查询"></a>2.6 连接查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"># 1.连接查询的含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</span><br><span class="line">    笛卡尔乘积现象：表1 有m行，表2有n行，结果&#x3D;m*n行</span><br><span class="line">    发生原因：没有有效的连接条件</span><br><span class="line">    如何避免：添加有效的连接条件</span><br><span class="line"></span><br><span class="line"># 2.分类：</span><br><span class="line">	# 按年代分类：</span><br><span class="line">	sql92标准:仅仅支持内连接</span><br><span class="line">	sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接</span><br><span class="line">	</span><br><span class="line">	# 按功能分类：</span><br><span class="line">		内连接：</span><br><span class="line">			等值连接</span><br><span class="line">			非等值连接</span><br><span class="line">			自连接</span><br><span class="line">		外连接：</span><br><span class="line">			左外连接</span><br><span class="line">			右外连接</span><br><span class="line">			全外连接</span><br><span class="line">		</span><br><span class="line">		交叉连接</span><br><span class="line"></span><br><span class="line"># 3. SQL92语法</span><br><span class="line">	# 等值连接</span><br><span class="line">	select 查询列表</span><br><span class="line">	from 表1 别名,表2 别名</span><br><span class="line">	where 表1.key&#x3D;表2.key</span><br><span class="line">	【and 筛选条件】</span><br><span class="line">	【group by 分组字段】</span><br><span class="line">	【having 分组后的筛选】</span><br><span class="line">	【order by 排序字段】</span><br><span class="line"></span><br><span class="line">	① 一般为表起别名</span><br><span class="line">	② 多表的顺序可以调换</span><br><span class="line">	③ n表连接至少需要n-1个连接条件</span><br><span class="line">	④ 等值连接的结果是多表的交集部分</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	# 非等值连接</span><br><span class="line">	select 查询列表</span><br><span class="line">	from 表1 别名,表2 别名</span><br><span class="line">	where 非等值的连接条件</span><br><span class="line">	【and 筛选条件】</span><br><span class="line">	【group by 分组字段】</span><br><span class="line">	【having 分组后的筛选】</span><br><span class="line">	【order by 排序字段】</span><br><span class="line"></span><br><span class="line">	# 自连接</span><br><span class="line">	select 查询列表</span><br><span class="line">	from 表 别名1,表 别名2</span><br><span class="line">	where 等值的连接条件</span><br><span class="line">	【and 筛选条件】</span><br><span class="line">	【group by 分组字段】</span><br><span class="line">	【having 分组后的筛选】</span><br><span class="line">	【order by 排序字段】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4.SQL99语法</span><br><span class="line">    # 内连接</span><br><span class="line">    - 语法：</span><br><span class="line">    select 查询列表</span><br><span class="line">    from 表1 别名</span><br><span class="line">    【inner】 join 表2 别名 on 连接条件</span><br><span class="line">    where 筛选条件</span><br><span class="line">    group by 分组列表</span><br><span class="line">    having 分组后的筛选</span><br><span class="line">    order by 排序列表</span><br><span class="line">    limit 子句;</span><br><span class="line">    - 特点：</span><br><span class="line">    ① 表的顺序可以调换</span><br><span class="line">    ② 内连接的结果&#x3D;多表的交集</span><br><span class="line">    ③ n表连接至少需要n-1个连接条件</span><br><span class="line">    - 分类：</span><br><span class="line">    等值连接</span><br><span class="line">    非等值连接</span><br><span class="line">    自连接</span><br><span class="line"></span><br><span class="line">    # 外连接</span><br><span class="line">    - 语法：</span><br><span class="line">    select 查询列表</span><br><span class="line">    from 表1 别名</span><br><span class="line">    left|right|full【outer】 join 表2 别名 on 连接条件</span><br><span class="line">    where 筛选条件</span><br><span class="line">    group by 分组列表</span><br><span class="line">    having 分组后的筛选</span><br><span class="line">    order by 排序列表</span><br><span class="line">    limit 子句;</span><br><span class="line">    - 特点：</span><br><span class="line">    ① 查询的结果&#x3D;主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null</span><br><span class="line">    ② left join 左边的就是主表</span><br><span class="line">      right join 右边的就是主表</span><br><span class="line">      full join 两边都是主表</span><br><span class="line">    ③ 一般用于查询除了交集部分的剩余的不匹配的行</span><br><span class="line"></span><br><span class="line">    # 交叉连接</span><br><span class="line">    - 语法：</span><br><span class="line">    select 查询列表</span><br><span class="line">    from 表1 别名</span><br><span class="line">    cross join 表2 别名;</span><br><span class="line">    - 特点：</span><br><span class="line">    类似于笛卡尔乘积</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-7-子查询"><a href="#2-7-子查询" class="headerlink" title="2.7 子查询"></a>2.7 子查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"># 1. 子查询的含义</span><br><span class="line">出现在其他语句中的select语句，称为子查询或内查询</span><br><span class="line">外部的查询语句，称为主查询或外查询</span><br><span class="line"></span><br><span class="line"># 2. 分类：</span><br><span class="line">    # 按子查询出现的位置：</span><br><span class="line">        select后面：</span><br><span class="line">            仅仅支持标量子查询</span><br><span class="line"></span><br><span class="line">        from后面：</span><br><span class="line">            支持表子查询</span><br><span class="line">        where或having后面：★</span><br><span class="line">            标量子查询（单行） √</span><br><span class="line">            列子查询  （多行） √</span><br><span class="line">            行子查询</span><br><span class="line"></span><br><span class="line">        exists后面（相关子查询）</span><br><span class="line">            表子查询</span><br><span class="line"></span><br><span class="line">    # 按结果集的行列数不同：</span><br><span class="line">        标量子查询（结果集只有一行一列）</span><br><span class="line">        列子查询（结果集只有一列多行）</span><br><span class="line">        行子查询（结果集有一行多列）</span><br><span class="line">        表子查询（结果集一般为多行多列）</span><br><span class="line"></span><br><span class="line"># 3. 示例</span><br><span class="line"># 3.1 where或having后面</span><br><span class="line">特点：</span><br><span class="line">① 子查询放在小括号内</span><br><span class="line">② 子查询一般放在条件的右侧</span><br><span class="line">③ 标量子查询，一般搭配着单行操作符使用</span><br><span class="line">&gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;</span><br><span class="line">列子查询，一般搭配着多行操作符使用</span><br><span class="line">in、any&#x2F;some、all</span><br><span class="line"></span><br><span class="line">④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</span><br><span class="line"></span><br><span class="line">    # 标量子查询</span><br><span class="line">    案例：查询最低工资的员工姓名和工资</span><br><span class="line">    ① 最低工资</span><br><span class="line">    select min(salary) from employees</span><br><span class="line">    ② 查询员工的姓名和工资，要求工资&#x3D;①</span><br><span class="line">    select last_name,salary</span><br><span class="line">    from employees</span><br><span class="line">    where salary&#x3D;(</span><br><span class="line">        select min(salary) from employees</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    # 列子查询 ★</span><br><span class="line">    案例：查询所有是领导的员工姓名</span><br><span class="line">    ① 查询所有员工的 manager_id</span><br><span class="line">    select manager_id</span><br><span class="line">    from employees</span><br><span class="line">    ② 查询姓名，employee_id属于①列表的一个</span><br><span class="line">    select last_name</span><br><span class="line">    from employees</span><br><span class="line">    where employee_id in(</span><br><span class="line">        select manager_id</span><br><span class="line">        from employees</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    # 行子查询（了解）</span><br><span class="line">	案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE (employee_id,salary)&#x3D;(</span><br><span class="line">        SELECT MIN(employee_id),MAX(salary)</span><br><span class="line">        FROM employees</span><br><span class="line">    );</span><br><span class="line">    ① 查询最小的员工编号</span><br><span class="line">    SELECT MIN(employee_id)</span><br><span class="line">    FROM employees</span><br><span class="line">	② 查询最高工资</span><br><span class="line">    SELECT MAX(salary)</span><br><span class="line">    FROM employees</span><br><span class="line">    ③ 查询员工信息</span><br><span class="line">    SELECT *</span><br><span class="line">    FROM employees</span><br><span class="line">    WHERE employee_id&#x3D;(</span><br><span class="line">        SELECT MIN(employee_id)</span><br><span class="line">        FROM employees</span><br><span class="line">    )AND salary&#x3D;(</span><br><span class="line">        SELECT MAX(salary)</span><br><span class="line">        FROM employees</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"># 3.2 select后面</span><br><span class="line">仅仅支持标量子查询</span><br><span class="line">    #案例：查询每个部门的员工个数</span><br><span class="line">    SELECT d.*,(</span><br><span class="line">        SELECT COUNT(*)</span><br><span class="line">        FROM employees e</span><br><span class="line">        WHERE e.department_id &#x3D; d.&#96;department_id&#96;</span><br><span class="line">     ) 个数</span><br><span class="line">     FROM departments d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.3 from后面</span><br><span class="line">将子查询结果充当一张表，要求必须起别名</span><br><span class="line">    #案例：查询每个部门的平均工资的工资等级</span><br><span class="line">    ① 查询每个部门的平均工资</span><br><span class="line">    SELECT AVG(salary),department_id</span><br><span class="line">    FROM employees</span><br><span class="line">    GROUP BY department_id</span><br><span class="line">    SELECT * FROM job_grades;</span><br><span class="line"></span><br><span class="line">    ② 连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">    SELECT  ag_dep.*,g.&#96;grade_level&#96;</span><br><span class="line">    FROM (</span><br><span class="line">        SELECT AVG(salary) ag,department_id</span><br><span class="line">        FROM employees</span><br><span class="line">        GROUP BY department_id</span><br><span class="line">    ) ag_dep</span><br><span class="line">    INNER JOIN job_grades g</span><br><span class="line">    ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.4 exists后面（相关子查询）</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line"></span><br><span class="line">SELECT EXISTS(SELECT employee_id FROM employees WHERE salary&#x3D;300000);</span><br><span class="line"></span><br><span class="line">    #案例：查询有员工的部门名</span><br><span class="line">    #in</span><br><span class="line">    SELECT department_name</span><br><span class="line">    FROM departments d</span><br><span class="line">    WHERE d.&#96;department_id&#96; IN(</span><br><span class="line">        SELECT department_id</span><br><span class="line">        FROM employees</span><br><span class="line">    )</span><br><span class="line">    #exists</span><br><span class="line">    SELECT department_name</span><br><span class="line">    FROM departments d</span><br><span class="line">    WHERE EXISTS(</span><br><span class="line">        SELECT *</span><br><span class="line">        FROM employees e</span><br><span class="line">        WHERE d.&#96;department_id&#96;&#x3D;e.&#96;department_id&#96;</span><br><span class="line">    );</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-8-分页查询"><a href="#2-8-分页查询" class="headerlink" title="2.8 分页查询"></a>2.8 分页查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 1. 分页查询</span><br><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">[join type join 表2</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段]</span><br><span class="line">limit [offset，] size;</span><br><span class="line"></span><br><span class="line"># 2. 注意</span><br><span class="line">offset代表的是起始的条目索引，默认从0开始</span><br><span class="line">size代表的是显示的条目数</span><br><span class="line"></span><br><span class="line"># 3. 公式</span><br><span class="line">假如要显示的页数为page，每一页条目数为size</span><br><span class="line">select 查询列表</span><br><span class="line">from 表</span><br><span class="line">limit (page-1)*size,size;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-9-联合查询"><a href="#2-9-联合查询" class="headerlink" title="2.9 联合查询"></a>2.9 联合查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 1. 联合查询: 将多条查询语句的结果合并成一个结果</span><br><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 2. 应用场景：</span><br><span class="line">要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</span><br><span class="line"></span><br><span class="line"># 3. 特点：★</span><br><span class="line">3.1 要求多条查询语句的查询列数是一致的！</span><br><span class="line">3.2 要求多条查询语句的查询的每一列的类型和顺序最好一致</span><br><span class="line">3.3 union关键字默认去重，如果使用union all 可以包含重复项</span><br><span class="line"></span><br><span class="line"># 4.案例：查询部门编号&gt;90或邮箱包含a的员工信息</span><br><span class="line">SELECT * FROM employees WHERE email LIKE &#39;%a%&#39; OR department_id&gt;90;;</span><br><span class="line">SELECT * FROM employees  WHERE email LIKE &#39;%a%&#39;</span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM employees  WHERE department_id&gt;90;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="2-10-查询语句总结"><a href="#2-10-查询语句总结" class="headerlink" title="2.10 查询语句总结"></a>2.10 查询语句总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 语法以及执行顺序</span><br><span class="line">select 查询列表    ⑦</span><br><span class="line">from 表1 别名       ①</span><br><span class="line">连接类型 join 表2   ②</span><br><span class="line">on 连接条件         ③</span><br><span class="line">where 筛选          ④</span><br><span class="line">group by 分组列表   ⑤</span><br><span class="line">having 筛选         ⑥</span><br><span class="line">order by排序列表    ⑧</span><br><span class="line">limit 起始条目索引，条目数;  ⑨</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="3-DML语言"><a href="#3-DML语言" class="headerlink" title="3. DML语言"></a>3. DML语言</h2><blockquote>
<p>数据操作语言：</p>
<p>插入：insert</p>
<p>修改：update</p>
<p>删除：delete</p>
</blockquote>
<h3 id="3-1-插入语句"><a href="#3-1-插入语句" class="headerlink" title="3.1 插入语句"></a>3.1 插入语句</h3><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">insert into 表名(列名) values(值1,...);</span><br><span class="line"></span><br><span class="line"># 1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"></span><br><span class="line"># 2.不可以为null的列必须插入值。可以为null的列如何插入值？</span><br><span class="line"># 2.1：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,borndate,phone,photo,boyfriend_id)</span><br><span class="line">VALUES(13,&#39;唐艺昕&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"># 2.2：</span><br><span class="line">INSERT INTO beauty(id,NAME,sex,phone)</span><br><span class="line">VALUES(15,&#39;娜扎&#39;,&#39;女&#39;,&#39;1388888888&#39;);</span><br><span class="line"></span><br><span class="line"># 3.列的顺序是否可以调换</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;蒋欣&#39;,&#39;女&#39;,16,&#39;110&#39;);</span><br><span class="line"></span><br><span class="line"># 4.列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty(NAME,sex,id,phone)</span><br><span class="line">VALUES(&#39;关晓彤&#39;,&#39;女&#39;,17,&#39;110&#39;);</span><br><span class="line"></span><br><span class="line"># 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(18,&#39;张飞&#39;,&#39;男&#39;,NULL,&#39;119&#39;,NULL,NULL);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 语法：</span><br><span class="line">insert into 表名</span><br><span class="line">set 列名&#x3D;值,列名&#x3D;值,...</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">SET id&#x3D;19, NAME&#x3D;&#39;刘涛&#39;, phone&#x3D;&#39;999&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>对比两种方式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 1、方式一支持插入多行,方式二不支持</span><br><span class="line">INSERT INTO beauty</span><br><span class="line">VALUES(23,&#39;唐艺昕1&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(24,&#39;唐艺昕2&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2)</span><br><span class="line">,(25,&#39;唐艺昕3&#39;,&#39;女&#39;,&#39;1990-4-23&#39;,&#39;1898888888&#39;,NULL,2);</span><br><span class="line"></span><br><span class="line"># 2、方式一支持子查询，方式二不支持</span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT 26,&#39;宋茜&#39;,&#39;11809866&#39;;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty(id,NAME,phone)</span><br><span class="line">SELECT id,boyname,&#39;1234567&#39;</span><br><span class="line">FROM boys WHERE id&lt;3;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-2-修改语句"><a href="#3-2-修改语句" class="headerlink" title="3.2 修改语句"></a>3.2 修改语句</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 1.修改单表的记录★</span><br><span class="line">update 表名</span><br><span class="line">set 列&#x3D;新值,列&#x3D;新值,...</span><br><span class="line">where 筛选条件;</span><br><span class="line"></span><br><span class="line"># 2.修改多表的记录【补充】</span><br><span class="line"># sql92语法：</span><br><span class="line">update 表1 别名,表2 别名</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"># sql99语法：</span><br><span class="line">update 表1 别名</span><br><span class="line">inner|left|right join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">set 列&#x3D;值,...</span><br><span class="line">where 筛选条件;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#1.修改单表的记录</span><br><span class="line">#案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line">UPDATE beauty SET phone &#x3D; &#39;13899888899&#39;</span><br><span class="line">WHERE NAME LIKE &#39;唐%&#39;;</span><br><span class="line">#案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE boys SET boyname&#x3D;&#39;张飞&#39;,usercp&#x3D;10</span><br><span class="line">WHERE id&#x3D;2;</span><br><span class="line"></span><br><span class="line">#2.修改多表的记录</span><br><span class="line">#案例 1：修改张无忌的女朋友的手机号为114</span><br><span class="line">UPDATE boys bo</span><br><span class="line">INNER JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">SET b.&#96;phone&#96;&#x3D;&#39;119&#39;,bo.&#96;userCP&#96;&#x3D;1000</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;</span><br><span class="line">#案例2：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line">UPDATE boys bo</span><br><span class="line">RIGHT JOIN beauty b ON bo.&#96;id&#96;&#x3D;b.&#96;boyfriend_id&#96;</span><br><span class="line">SET b.&#96;boyfriend_id&#96;&#x3D;2</span><br><span class="line">WHERE bo.&#96;id&#96; IS NULL;</span><br><span class="line">SELECT * FROM boys;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="3-3-删除语句"><a href="#3-3-删除语句" class="headerlink" title="3.3 删除语句"></a>3.3 删除语句</h3><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1、单表的删除【★】</span><br><span class="line">delete from 表名 where 筛选条件</span><br><span class="line"></span><br><span class="line"># 2、多表的删除【补充】</span><br><span class="line"># sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"># sql99语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 1.单表的删除</span><br><span class="line"># 案例：删除手机号以9结尾的女神信息</span><br><span class="line">DELETE FROM beauty WHERE phone LIKE &#39;%9&#39;;</span><br><span class="line"></span><br><span class="line"># 2.多表的删除</span><br><span class="line"># 案例：删除张无忌的女朋友的信息</span><br><span class="line">DELETE b</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96; &#x3D; bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;张无忌&#39;;</span><br><span class="line"># 案例：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE b,bo</span><br><span class="line">FROM beauty b</span><br><span class="line">INNER JOIN boys bo ON b.&#96;boyfriend_id&#96;&#x3D;bo.&#96;id&#96;</span><br><span class="line">WHERE bo.&#96;boyName&#96;&#x3D;&#39;黄晓明&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：</span><br><span class="line">truncate table 表名;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#案例：将魅力值&gt;100的男神信息删除</span><br><span class="line">TRUNCATE TABLE boys ;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>delete 对比 truncate</strong> [面试题]</p>
<blockquote>
<ol>
<li>delete 可以加where 条件，truncate不能加</li>
<li>truncate删除，效率高一丢丢</li>
<li>假如要删除的表中有自增长列，如果用delete删除后，再插入数据，自增长列的值从断点开始，而truncate删除后，再插入数据，自增长列的值从1开始。</li>
<li>truncate删除没有返回值，delete删除有返回值</li>
<li>truncate删除不能回滚，delete删除可以回滚.</li>
</ol>
</blockquote>
<h2 id="4-DDL语言"><a href="#4-DDL语言" class="headerlink" title="4. DDL语言"></a>4. DDL语言</h2><p>数据定义语言 –&gt; 库和表的管理</p>
<blockquote>
<p>一、库的管理<br>创建、修改、删除</p>
<p>二、表的管理<br>创建、修改、删除</p>
</blockquote>
<p>创建： create<br>修改： alter<br>删除： drop</p>
<h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#1、库的创建</span><br><span class="line">create database  [if not exists]库名;</span><br><span class="line">#案例：创建库Books</span><br><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br><span class="line"></span><br><span class="line">#2、库的修改</span><br><span class="line">RENAME DATABASE books TO 新库名;</span><br><span class="line">#更改库的字符集</span><br><span class="line">ALTER DATABASE books CHARACTER SET gbk;</span><br><span class="line"></span><br><span class="line">#3、库的删除</span><br><span class="line">DROP DATABASE IF EXISTS books;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"># 1.表的创建 ★</span><br><span class="line"># 语法：</span><br><span class="line">create table 表名(</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	列名 列的类型【(长度) 约束】,</span><br><span class="line">	...</span><br><span class="line">	列名 列的类型【(长度) 约束】</span><br><span class="line">)</span><br><span class="line"># 案例：创建表Book</span><br><span class="line">CREATE TABLE book(</span><br><span class="line">	id INT,#编号</span><br><span class="line">	bName VARCHAR(20),#图书名</span><br><span class="line">	price DOUBLE,#价格</span><br><span class="line">	authorId  INT,#作者编号</span><br><span class="line">	publishDate DATETIME#出版日期</span><br><span class="line">);</span><br><span class="line">DESC book;</span><br><span class="line">#案例：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author(</span><br><span class="line">	id INT,</span><br><span class="line">	au_name VARCHAR(20),</span><br><span class="line">	nation VARCHAR(10)</span><br><span class="line">)</span><br><span class="line">DESC author;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.表的修改</span><br><span class="line"># 语法</span><br><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br><span class="line"># ① 修改列名</span><br><span class="line">ALTER TABLE book CHANGE COLUMN publishdate pubDate DATETIME;</span><br><span class="line"># ② 修改列的类型或约束</span><br><span class="line">ALTER TABLE book MODIFY COLUMN pubdate TIMESTAMP;</span><br><span class="line"># ③ 添加新列</span><br><span class="line">ALTER TABLE author ADD COLUMN annual DOUBLE; </span><br><span class="line"># ④ 删除列</span><br><span class="line">ALTER TABLE book_author DROP COLUMN  annual;</span><br><span class="line"># ⑤ 修改表名</span><br><span class="line">ALTER TABLE author RENAME TO book_author;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 3.表的删除</span><br><span class="line">DROP TABLE IF EXISTS book_author;</span><br><span class="line">SHOW TABLES;</span><br><span class="line"># 通用的写法：</span><br><span class="line">DROP DATABASE IF EXISTS 旧库名;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line">DROP TABLE IF EXISTS 旧表名;</span><br><span class="line">CREATE TABLE  表名();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 4.表的复制</span><br><span class="line">INSERT INTO author VALUES</span><br><span class="line">(1,&#39;村上春树&#39;,&#39;日本&#39;),</span><br><span class="line">(2,&#39;莫言&#39;,&#39;中国&#39;),</span><br><span class="line">(3,&#39;冯唐&#39;,&#39;中国&#39;),</span><br><span class="line">(4,&#39;金庸&#39;,&#39;中国&#39;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM Author;</span><br><span class="line">SELECT * FROM copy2;</span><br><span class="line"># 1.仅仅复制表的结构</span><br><span class="line">CREATE TABLE copy LIKE author;</span><br><span class="line"># 2.复制表的结构+数据</span><br><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT * FROM author;</span><br><span class="line"></span><br><span class="line"># 只复制部分数据</span><br><span class="line">CREATE TABLE copy3</span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author </span><br><span class="line">WHERE nation&#x3D;&#39;中国&#39;;</span><br><span class="line"></span><br><span class="line"># 仅仅复制某些字段</span><br><span class="line">CREATE TABLE copy4 </span><br><span class="line">SELECT id,au_name</span><br><span class="line">FROM author</span><br><span class="line">WHERE 0;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><blockquote>
<p>常见的数据类型</p>
<ul>
<li>数值型：</li>
<li>整型</li>
<li>小数：<ul>
<li>定点数</li>
<li>浮点数</li>
</ul>
</li>
<li>字符型：</li>
<li>较短的文本：char、varchar</li>
<li>较长的文本：text、blob（较长的二进制数据）</li>
<li>日期型</li>
</ul>
</blockquote>
<p><strong>整型</strong></p>
<ul>
<li>分类：<br>tinyint、smallint、mediumint、int/integer、bigint<br>1 2 3 4 8</li>
<li>特点：<br>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字<br>② 如果插入的数值超出了整型的范围,会报out of range异常，并且插入临界值<br>③ 如果不设置长度，会有默认的长度<br>长度代表了显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如何设置无符号和有符号</span><br><span class="line">DROP TABLE IF EXISTS tab_int;</span><br><span class="line">CREATE TABLE tab_int(</span><br><span class="line">	t1 INT(7) ZEROFILL,</span><br><span class="line">	t2 INT(7) ZEROFILL,</span><br><span class="line">    t3 INT UNSIGNED</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">DESC tab_int;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int VALUES(-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(-123456,-123456);</span><br><span class="line">INSERT INTO tab_int VALUES(2147483648,4294967296);</span><br><span class="line">INSERT INTO tab_int VALUES(123,123);</span><br><span class="line">SELECT * FROM tab_int;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>小数</strong></p>
<ul>
<li><p>分类：</p>
<ol>
<li>浮点型<br>float(M,D)<br>double(M,D)</li>
<li>定点型<br>dec(M，D)<br>decimal(M,D)</li>
</ol>
</li>
<li><p>特点：</p>
<p>①<br>M：整数部位+小数部位<br>D：小数部位<br>如果超过范围，则插入临界值</p>
<p>②<br>M和D都可以省略<br>如果是decimal，则M默认为10，D默认为0<br>如果是float和double，则会根据插入的数值的精度来决定精度</p>
<p>③</p>
<p>定点型的精确度较高，如果要求插入数值的精度较高如货币运算等则考虑使用</p>
</li>
<li><p>原则：</p>
<p>所选择的类型越简单越好，能保存数值的类型越小越好</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#测试M和D</span><br><span class="line">CREATE TABLE tab_float(</span><br><span class="line">	f1 FLOAT,</span><br><span class="line">	f2 DOUBLE,</span><br><span class="line">	f3 DECIMAL</span><br><span class="line">);</span><br><span class="line">SELECT * FROM tab_float;</span><br><span class="line">DESC tab_float;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_float VALUES(123.4523,123.4523,123.4523);</span><br><span class="line">INSERT INTO tab_float VALUES(123.456,123.456,123.456);</span><br><span class="line">INSERT INTO tab_float VALUES(123.4,123.4,123.4);</span><br><span class="line">INSERT INTO tab_float VALUES(1523.4,1523.4,1523.4);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>字符型</strong></p>
<ul>
<li><p>较短的文本：</p>
<p>char varchar</p>
</li>
<li><p>其他：</p>
<p>binary和varbinary用于保存较短的二进制<br>enum用于保存枚举<br>set用于保存集合</p>
</li>
<li><p>较长的文本：<br>text<br>blob(较大的二进制)</p>
</li>
<li><p>char/varchar 对比</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>写法</th>
<th>M的意思</th>
<th>特点</th>
<th>空间的耗费</th>
<th>效率</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>char(M)</td>
<td>最大的字符数，可以省略，默认为1</td>
<td>固定长度的字符</td>
<td>比较耗费</td>
<td>高</td>
</tr>
<tr>
<td>varchar</td>
<td>varchar(M)</td>
<td>最大的字符数，不可以省略</td>
<td>可变长度的字符</td>
<td>比较节省</td>
<td>低</td>
</tr>
</tbody></table>
<ul>
<li><p>enum和set不区分大小写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_char(</span><br><span class="line">	c1 ENUM(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;b&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;c&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;m&#39;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#39;A&#39;);</span><br><span class="line">SELECT * FROM tab_char;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_set(</span><br><span class="line">	s1 SET(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;)</span><br><span class="line">);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;A,B&#39;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#39;a,c,d&#39;);</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>日期型</strong></p>
<ul>
<li>分类：<br>date只保存日期<br>time 只保存时间<br>year只保存年</li>
</ul>
<p>datetime保存日期+时间<br>timestamp保存日期+时间</p>
<table>
<thead>
<tr>
<th></th>
<th>写法</th>
<th>范围</th>
<th>时区等的影响</th>
</tr>
</thead>
<tbody><tr>
<td>datetime</td>
<td>8</td>
<td>1000-9999</td>
<td>不受</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>1970-2038</td>
<td>受</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_date(</span><br><span class="line">	t1 DATETIME,</span><br><span class="line">	t2 TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line">SELECT * FROM tab_date;</span><br><span class="line"></span><br><span class="line"># 查看当前时区</span><br><span class="line">SHOW VARIABLES LIKE &#39;time_zone&#39;;</span><br><span class="line"># 更改时区</span><br><span class="line">SET time_zone&#x3D;&#39;+9:00&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-4-常见约束"><a href="#4-4-常见约束" class="headerlink" title="4.4 常见约束"></a>4.4 常见约束</h3><ul>
<li><p>含义：一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p>
</li>
<li><p>分类：六大约束</p>
<ul>
<li><p>NOT NULL：<strong>非空</strong>，用于保证该字段的值不能为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如姓名、学号等</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>DEFAULT：<strong>默认</strong>，用于保证该字段有默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如性别</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>PRIMARY KEY：<strong>主键</strong>，用于保证该字段的值具有<strong>唯一性</strong>，并且<strong>非空</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如学号、员工编号等</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>UNIQUE：<strong>唯一</strong>，用于保证该字段的值具有<strong>唯一性</strong>，可以为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如座位号</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>CHECK：检查约束【mysql中不支持】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如年龄、性别</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>FOREIGN KEY：<strong>外键</strong>，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值</p>
<p> 在<strong>从表添加外键约束</strong>，用于<strong>引用主表</strong>中某列的值<br>​ 比如学生表的专业编号，员工表的部门编号，员工表的工种编号<br>​</p>
</li>
</ul>
</li>
<li><p>添加约束的时机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建表时</span><br><span class="line">2.修改表时</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
<li><p>约束的添加分类：</p>
<ul>
<li><p>列级约束：<br>六大约束语法上都支持，但外键约束没有效果</p>
</li>
<li><p>表级约束：</p>
<p>除了非空、默认，其他的都支持</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	字段名 字段类型 列级约束,</span><br><span class="line">	字段名 字段类型,</span><br><span class="line">	表级约束</span><br><span class="line">)</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li>主键和唯一的对比【面试题】</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>保证唯一性</th>
<th>是否允许为空</th>
<th>一个表中可以有多少个</th>
<th>是否允许组合</th>
</tr>
</thead>
<tbody><tr>
<td>主键</td>
<td>√</td>
<td>×</td>
<td>至多有1个</td>
<td>√，但不推荐</td>
</tr>
<tr>
<td>唯一</td>
<td>√</td>
<td>√</td>
<td>可以有多个</td>
<td>√，但不推荐</td>
</tr>
</tbody></table>
<ul>
<li><p>外键</p>
<ul>
<li><p>要求在从表设置外键关系</p>
</li>
<li><p>从表的外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p>
</li>
<li><p>主表的关联列必须是一个key（一般是主键或唯一）</p>
</li>
<li><p>插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 可以通过以下两种方式来删除主表的记录</span><br><span class="line"># 方式一：级联删除</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</span><br><span class="line"># 方式二：级联置空</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>约束的增删改</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"># 一、创建表时添加约束</span><br><span class="line"># 1.添加列级约束</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">直接在字段名和类型后面追加 约束类型即可。</span><br><span class="line">只支持：默认、非空、主键、唯一</span><br><span class="line">*&#x2F;</span><br><span class="line">USE students;</span><br><span class="line">DROP TABLE stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,#主键</span><br><span class="line">	stuName VARCHAR(20) NOT NULL UNIQUE,#非空</span><br><span class="line">	gender CHAR(1) CHECK(gender&#x3D;&#39;男&#39; OR gender &#x3D;&#39;女&#39;),#检查</span><br><span class="line">	seat INT UNIQUE,#唯一</span><br><span class="line">	age INT DEFAULT  18,#默认约束</span><br><span class="line">	majorId INT REFERENCES major(id)#外键(这里外键无效)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE major(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	majorName VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#查看stuinfo中的所有索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2.添加表级约束</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line"> 【constraint 约束名】 约束类型(字段名) </span><br><span class="line">*&#x2F;</span><br><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT,</span><br><span class="line">	</span><br><span class="line">	CONSTRAINT pk PRIMARY KEY(id),#主键</span><br><span class="line">	CONSTRAINT uq UNIQUE(seat),#唯一键</span><br><span class="line">	CONSTRAINT ck CHECK(gender &#x3D;&#39;男&#39; OR gender  &#x3D; &#39;女&#39;),#检查</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)#外键</span><br><span class="line">	</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 通用的写法：★</span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo(</span><br><span class="line">	id INT PRIMARY KEY,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	sex CHAR(1),</span><br><span class="line">	age INT DEFAULT 18,</span><br><span class="line">	seat INT UNIQUE,</span><br><span class="line">	majorid INT,</span><br><span class="line">	CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二、修改表时添加约束</span><br><span class="line">&#x2F;*</span><br><span class="line">1. 添加列级约束</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br><span class="line">2. 添加表级约束</span><br><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br><span class="line">*&#x2F;</span><br><span class="line">DROP TABLE IF EXISTS stuinfo;</span><br><span class="line">CREATE TABLE stuinfo(</span><br><span class="line">	id INT,</span><br><span class="line">	stuname VARCHAR(20),</span><br><span class="line">	gender CHAR(1),</span><br><span class="line">	seat INT,</span><br><span class="line">	age INT,</span><br><span class="line">	majorid INT</span><br><span class="line">)</span><br><span class="line">DESC stuinfo;</span><br><span class="line"></span><br><span class="line"># 1.添加非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20)  NOT NULL;</span><br><span class="line"># 2.添加默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT DEFAULT 18;</span><br><span class="line"># 3.添加主键</span><br><span class="line"># ①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN id INT PRIMARY KEY;</span><br><span class="line"># ②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD PRIMARY KEY(id);</span><br><span class="line"># 4.添加唯一</span><br><span class="line"># ①列级约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN seat INT UNIQUE;</span><br><span class="line"># ②表级约束</span><br><span class="line">ALTER TABLE stuinfo ADD UNIQUE(seat);</span><br><span class="line"># 5.添加外键</span><br><span class="line">ALTER TABLE stuinfo ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY(majorid) REFERENCES major(id); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三、修改表时删除约束</span><br><span class="line"># 1.删除非空约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN stuname VARCHAR(20) NULL;</span><br><span class="line"># 2.删除默认约束</span><br><span class="line">ALTER TABLE stuinfo MODIFY COLUMN age INT ;</span><br><span class="line"># 3.删除主键</span><br><span class="line">ALTER TABLE stuinfo DROP PRIMARY KEY;</span><br><span class="line"># 4.删除唯一</span><br><span class="line">ALTER TABLE stuinfo DROP INDEX seat;</span><br><span class="line"># 5.删除外键</span><br><span class="line">ALTER TABLE stuinfo DROP FOREIGN KEY fk_stuinfo_major;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自增长列(标识列）</p>
<ul>
<li><p>含义：可以不用手动的插入值，系统提供默认的序列值</p>
</li>
<li><p>特点：</p>
<blockquote>
<p>1、标识列必须和主键搭配吗？不一定，但要求是一个key<br>2、一个表可以有几个标识列？<strong>至多一个</strong>！<br>3、标识列的类型只能是数值型<br>4、标识列可以通过 <code>SET auto_increment_increment=3;</code>设置步长<br>可以通过 手动插入值，设置起始值</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 1.创建表时设置标识列</span><br><span class="line">DROP TABLE IF EXISTS tab_identity;</span><br><span class="line">CREATE TABLE tab_identity(</span><br><span class="line">	id INT,</span><br><span class="line">	NAME FLOAT UNIQUE AUTO_INCREMENT,</span><br><span class="line">	seat INT </span><br><span class="line">);</span><br><span class="line">TRUNCATE TABLE tab_identity;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#39;john&#39;);</span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&#39;lucy&#39;);</span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line"># 查看自增长相关变量</span><br><span class="line">SHOW VARIABLES LIKE &#39;%auto_increment%&#39;;</span><br><span class="line"># 设置自增长步长(一般要进行修改)</span><br><span class="line">SET auto_increment_increment&#x3D;3;</span><br><span class="line"></span><br><span class="line"># 2.修改表时设置标识列</span><br><span class="line">ALTER TABLE tab_identity MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line"># 3.修改表时删除标识列</span><br><span class="line">ALTER TABLE tab_identity MODIFY COLUMN id INT;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="4-5-表与表之间的关系"><a href="#4-5-表与表之间的关系" class="headerlink" title="4.5 表与表之间的关系"></a>4.5 表与表之间的关系</h3><ul>
<li>一对一</li>
<li>一对多</li>
<li>多对多</li>
</ul>
<h2 id="5-TCL语言"><a href="#5-TCL语言" class="headerlink" title="5. TCL语言"></a>5. TCL语言</h2><p>Transaction Control Language 事务控制语言</p>
<h3 id="5-1-事务的含义"><a href="#5-1-事务的含义" class="headerlink" title="5.1 事务的含义"></a>5.1 事务的含义</h3><blockquote>
<p><strong>事务</strong>：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p>
</blockquote>
<h3 id="5-2-事务的特点"><a href="#5-2-事务的特点" class="headerlink" title="5.2 事务的特点"></a>5.2 事务的特点</h3><p>事务的特性：ACID [面试题]</p>
<ul>
<li>原子性：一个事务不可再分割，要么都执行要么都不执行.</li>
<li>一致性：一个事务执行会使数据从一个一致状态切换到另外一个一致状态.</li>
<li>隔离性：一个事务的执行不受其他事务的干扰.</li>
<li>持久性：一个事务一旦提交，则会永久的改变数据库的数据.</li>
</ul>
<blockquote>
<p>存储引擎:</p>
<ol>
<li>概念: 在mysql中的数据用各种不同的技术存储在文件(或者内存)中.</li>
<li>通过<code>show engines;</code>来查看mysql支持的存储引擎.</li>
<li>在mysql中用的最多的存储引擎有: innodb, myisam, memory等. 其中innodb支持事务,而myisam和memory不支持事务.</li>
</ol>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_2.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95_tx_2.png" alt="img"></a></p>
<h3 id="5-3-事务的使用"><a href="#5-3-事务的使用" class="headerlink" title="5.3 事务的使用"></a>5.3 事务的使用</h3><ul>
<li><p>事务的创建</p>
<ul>
<li><p>隐式事务：事务没有明显的开启和结束的标记<br>比如insert、update、delete语句</p>
<p> delete from 表 where id =1;</p>
</li>
<li><p>显式事务：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用<code>set autocommit=0;</code></p>
</li>
</ul>
</li>
<li><p>显式事务的使用</p>
<p>① 开启事务<br>set autocommit=0;<br>start transaction;#可以省略</p>
<p>② 编写一组逻辑sql语句<br>注意：sql语句支持的是insert、update、delete</p>
<p>设置回滚点：<br>savepoint 回滚点名;</p>
<p>③ 结束事务<br>提交：commit;<br>回滚：rollback;<br>回滚到指定的地方：rollback to 回滚点名;</p>
</li>
<li><p>delete和truncate在事务使用时的区别：</p>
<ul>
<li>delete支持回滚</li>
<li>truncate不支持</li>
</ul>
</li>
</ul>
<h3 id="5-4-并发事务"><a href="#5-4-并发事务" class="headerlink" title="5.4 并发事务"></a>5.4 并发事务</h3><ul>
<li><p>事务的并发问题是如何发生的？</p>
<p> 多个事务 同时 操作 同一个数据库的相同数据时</p>
</li>
<li><p>并发问题都有哪些？</p>
<ul>
<li><strong>脏读</strong>：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li>
<li><strong>不可重复读</strong>：一个事务多次读取，结果不一样</li>
<li><strong>幻读</strong>：一个事务读取了其他事务还没有提交的数据，只是读到的是其他事务“插入”的数据</li>
<li><strong>更新丢失</strong>：当两个或者多个事务选择同一行，然后基于最初的选定的值更新该行时，由于每一个事务都不知道其他事务的存在，就会发生更新问题。最后的更新覆盖了其他事务所做的更新。</li>
</ul>
</li>
<li><p>如何解决并发问题</p>
<p> 通过设置隔离级别来解决并发问题</p>
</li>
<li><p>事务的隔离级别</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>读数据一致性</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommitted: 读未提交</td>
<td>最低级别，只能保证不读取物理上损坏的数据</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>read committed: 读已提交</td>
<td>语句级</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>repeatable read: 可重复读</td>
<td>事务级</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>serializable: 串行化 (每次读都需获得表级共享锁，读写相互都会阻塞,性能低下)</td>
<td>最高级别，事务级</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># mysql中默认 第三个隔离级别 </span><br><span class="line">repeatable read</span><br><span class="line"># oracle中默认第二个隔离级别 </span><br><span class="line">read committed</span><br><span class="line"># 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">show variables like &#39;tx_isolation&#39;;</span><br><span class="line"># 设置隔离级别</span><br><span class="line">set session|global transaction isolation level 隔离级别;</span><br><span class="line">Copy</span><br><span class="line">#1.演示事务的使用步骤</span><br><span class="line"># 开启事务</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"># 编写一组事务的语句</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;张无忌&#39;;</span><br><span class="line">UPDATE account SET balance &#x3D; 1000 WHERE username&#x3D;&#39;赵敏&#39;;</span><br><span class="line"># 结束事务</span><br><span class="line">ROLLBACK; # commit;</span><br><span class="line">SELECT * FROM account;</span><br><span class="line"></span><br><span class="line">#2.演示事务对于delete和truncate的处理的区别</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br><span class="line"></span><br><span class="line">#3.演示savepoint 的使用</span><br><span class="line">SET autocommit&#x3D;0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id&#x3D;25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id&#x3D;28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line">SELECT * FROM account;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><blockquote>
<p><strong>含义</strong>：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据, <strong>只保存了sql逻辑</strong>, 不保存查询结果</p>
</blockquote>
<ul>
<li>应用场景:<ul>
<li>多个地方用到相同的查询结果</li>
<li>该查询结果使用的sql语句比较复杂</li>
</ul>
</li>
<li>好处：<ul>
<li>重用sql语句</li>
<li>简化复杂的sql操作，不必知道它的查询细节</li>
<li>保护数据，提高安全性（只提供对方需要的信息）</li>
</ul>
</li>
<li>创建视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 示例：查询姓张的学生名和专业名</span><br><span class="line"># 1.原始sql语句</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;</span><br><span class="line">WHERE s.&#96;stuname&#96; LIKE &#39;张%&#39;;</span><br><span class="line"># 2.①创建视图</span><br><span class="line">CREATE VIEW v1</span><br><span class="line">AS</span><br><span class="line">SELECT stuname,majorname</span><br><span class="line">FROM stuinfo s</span><br><span class="line">INNER JOIN major m ON s.&#96;majorid&#96;&#x3D; m.&#96;id&#96;;</span><br><span class="line"># 2.②使用视图简化原始sql语句</span><br><span class="line">SELECT * FROM v1 WHERE stuname LIKE &#39;张%&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>修改视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#方式一：</span><br><span class="line">&#x2F;*</span><br><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br><span class="line">*&#x2F;</span><br><span class="line">SELECT * FROM myv3 </span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br><span class="line"></span><br><span class="line">#方式二：</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br><span class="line">*&#x2F;</span><br><span class="line">ALTER VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>删除视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 语法：drop view 视图名,视图名,...;</span><br><span class="line">DROP VIEW emp_v1,emp_v2,myv3;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>查看视图</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DESC myv3;</span><br><span class="line">SHOW CREATE VIEW myv3;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li>更新视图</li>
</ul>
<p>视图可以增删改，示例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email</span><br><span class="line">FROM employees;</span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line">SELECT * FROM employees;</span><br><span class="line">#1.插入</span><br><span class="line">INSERT INTO myv1 VALUES(&#39;张飞&#39;,&#39;zf@qq.com&#39;);</span><br><span class="line">#2.修改</span><br><span class="line">UPDATE myv1 SET last_name &#x3D; &#39;张无忌&#39; WHERE last_name&#x3D;&#39;张飞&#39;;</span><br><span class="line">#3.删除</span><br><span class="line">DELETE FROM myv1 WHERE last_name &#x3D; &#39;张无忌&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p>具备以下特点的视图不允许更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># ① 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</span><br><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT MAX(salary) m,department_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY department_id;</span><br><span class="line">SELECT * FROM myv1;</span><br><span class="line">#更新</span><br><span class="line">UPDATE myv1 SET m&#x3D;9000 WHERE department_id&#x3D;10;</span><br><span class="line"></span><br><span class="line"># ② 常量视图</span><br><span class="line">CREATE OR REPLACE VIEW myv2</span><br><span class="line">AS</span><br><span class="line">SELECT &#39;john&#39; NAME;</span><br><span class="line">SELECT * FROM myv2;</span><br><span class="line">#更新</span><br><span class="line">UPDATE myv2 SET NAME&#x3D;&#39;lucy&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ③ Select中包含子查询</span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT department_id,(SELECT MAX(salary) FROM employees) 最高工资</span><br><span class="line">FROM departments;</span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line">UPDATE myv3 SET 最高工资&#x3D;100000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ④ join</span><br><span class="line">CREATE OR REPLACE VIEW myv4</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,department_name</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN departments d</span><br><span class="line">ON e.department_id  &#x3D; d.department_id;</span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv4;</span><br><span class="line">UPDATE myv4 SET last_name  &#x3D; &#39;张飞&#39; WHERE last_name&#x3D;&#39;Whalen&#39;;</span><br><span class="line">INSERT INTO myv4 VALUES(&#39;陈真&#39;,&#39;xxxx&#39;);</span><br><span class="line"></span><br><span class="line"># ⑤ from一个不能更新的视图</span><br><span class="line">CREATE OR REPLACE VIEW myv5</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM myv3;</span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv5;</span><br><span class="line">UPDATE myv5 SET 最高工资&#x3D;10000 WHERE department_id&#x3D;60;</span><br><span class="line"></span><br><span class="line"># ⑥ where子句的子查询引用了from子句中的表</span><br><span class="line">CREATE OR REPLACE VIEW myv6</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email,salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE employee_id IN(</span><br><span class="line">	SELECT  manager_id</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE manager_id IS NOT NULL</span><br><span class="line">);</span><br><span class="line">#更新</span><br><span class="line">SELECT * FROM myv6;</span><br><span class="line">UPDATE myv6 SET salary&#x3D;10000 WHERE last_name &#x3D; &#39;k_ing&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表和视图的对比</p>
<table>
<thead>
<tr>
<th></th>
<th>创建语法的关键字</th>
<th>是否实际占用物理空间</th>
<th>使用</th>
</tr>
</thead>
<tbody><tr>
<td>视图</td>
<td>create view</td>
<td>只是保存了sql逻辑</td>
<td>增删改查，只是一般不能增删改</td>
</tr>
<tr>
<td>表</td>
<td>create table</td>
<td>保存了数据</td>
<td>增删改查</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><ul>
<li><p>系统变量：</p>
<ul>
<li>全局变量：</li>
</ul>
<p>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</p>
<ul>
<li><p>会话变量：</p>
<p>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</p>
</li>
</ul>
</li>
<li><p>自定义变量：</p>
<ul>
<li>用户变量</li>
<li>局部变量</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li>系统变量</li>
</ol>
</blockquote>
<p><strong>说明</strong>：变量由系统定义，不是用户定义，属于服务器层面<br><strong>注意</strong>：全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别<br><strong>使用步骤</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1、查看所有系统变量</span><br><span class="line">show global|【session】variables;</span><br><span class="line"># 2、查看满足条件的部分系统变量</span><br><span class="line">show global|【session】 variables like &#39;%char%&#39;;</span><br><span class="line"># 3、查看指定的系统变量的值</span><br><span class="line">select @@global|【session】系统变量名;</span><br><span class="line"># 4、为某个系统变量赋值</span><br><span class="line"># 方式一：</span><br><span class="line">set global|【session】系统变量名&#x3D;值;</span><br><span class="line"># 方式二：</span><br><span class="line">set @@global|【session】系统变量名&#x3D;值;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 1》全局变量</span><br><span class="line">&#x2F;*</span><br><span class="line">作用域：针对于所有会话（连接）有效，但不能跨重启</span><br><span class="line">*&#x2F;</span><br><span class="line"># ① 查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES;</span><br><span class="line"># ② 查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line"># ③ 查看指定的系统变量的值</span><br><span class="line">SELECT @@global.autocommit;</span><br><span class="line"># ④ 为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit&#x3D;0;</span><br><span class="line">SET GLOBAL autocommit&#x3D;0;</span><br><span class="line"></span><br><span class="line">#2》会话变量</span><br><span class="line">&#x2F;*</span><br><span class="line">作用域：针对于当前会话（连接）有效</span><br><span class="line">*&#x2F;</span><br><span class="line"># ① 查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES;</span><br><span class="line"># ② 查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;</span><br><span class="line"># ③ 查看指定的会话变量的值</span><br><span class="line">SELECT @@autocommit;</span><br><span class="line">SELECT @@session.tx_isolation;</span><br><span class="line"># ④ 为某个会话变量赋值</span><br><span class="line">SET @@session.tx_isolation&#x3D;&#39;read-uncommitted&#39;;</span><br><span class="line">SET SESSION tx_isolation&#x3D;&#39;read-committed&#39;;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>自定义变量</li>
</ol>
</blockquote>
<p><strong>说明</strong>：变量由用户自定义，而不是系统提供的<br><strong>使用步骤</strong>：<br>1、声明<br>2、赋值<br>3、使用（查看、比较、运算等）</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 1》用户变量</span><br><span class="line">&#x2F;*</span><br><span class="line">作用域：针对于当前会话（连接）有效，作用域同于会话变量</span><br><span class="line">*&#x2F;</span><br><span class="line"># 赋值操作符：&#x3D;或:&#x3D;</span><br><span class="line"># ① 声明并初始化</span><br><span class="line">SET @变量名&#x3D;值;</span><br><span class="line">SET @变量名:&#x3D;值;</span><br><span class="line">SELECT @变量名:&#x3D;值;</span><br><span class="line"># ② 赋值（更新变量的值）</span><br><span class="line">#方式一：</span><br><span class="line">	SET @变量名&#x3D;值;</span><br><span class="line">	SET @变量名:&#x3D;值;</span><br><span class="line">	SELECT @变量名:&#x3D;值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO @变量名</span><br><span class="line">	FROM 表;</span><br><span class="line"># ③ 使用（查看变量的值）</span><br><span class="line">SELECT @变量名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 2》局部变量</span><br><span class="line">&#x2F;*</span><br><span class="line">作用域：仅仅在定义它的begin end块中有效</span><br><span class="line">应用在 begin end中的第一句话</span><br><span class="line">*&#x2F;</span><br><span class="line"># ① 声明</span><br><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 【DEFAULT 值】</span><br><span class="line"># ② 赋值（更新变量的值）</span><br><span class="line">#方式一：</span><br><span class="line">	SET 局部变量名&#x3D;值;</span><br><span class="line">	SET 局部变量名:&#x3D;值;</span><br><span class="line">	SELECT 局部变量名:&#x3D;值;</span><br><span class="line">#方式二：</span><br><span class="line">	SELECT 字段 INTO 具备变量名</span><br><span class="line">	FROM 表;</span><br><span class="line"># ③ 使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 案例：声明两个变量，求和并打印</span><br><span class="line"># 用户变量</span><br><span class="line">SET @m&#x3D;1;</span><br><span class="line">SET @n&#x3D;1;</span><br><span class="line">SET @sum&#x3D;@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"># 局部变量</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM&#x3D;m+n;</span><br><span class="line">SELECT SUM;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<p><strong>用户变量和局部变量的对比</strong>：</p>
<table>
<thead>
<tr>
<th></th>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>用户变量</td>
<td>当前会话</td>
<td>会话的任何地方</td>
<td>加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话</td>
<td>一般不用加@,需要指定类型</td>
</tr>
</tbody></table>
<h3 id="6-3-存储过程和函数"><a href="#6-3-存储过程和函数" class="headerlink" title="6.3 存储过程和函数"></a>6.3 存储过程和函数</h3><ul>
<li>存储过程和函数：类似于java中的方法</li>
<li>好处：<br>1、提高代码的重用性<br>2、简化操作</li>
</ul>
<blockquote>
<ol>
<li><strong>存储过程</strong></li>
</ol>
</blockquote>
<p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"># 一、创建语法★</span><br><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">	存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br><span class="line">&#x2F;*</span><br><span class="line">1、参数列表包含三部分</span><br><span class="line">参数模式  参数名  参数类型</span><br><span class="line">举例：</span><br><span class="line">in stuname varchar(20)</span><br><span class="line"></span><br><span class="line">参数模式：</span><br><span class="line">in：该参数可以作为输入，也就是该参数需要调用方传入值,in可以省略</span><br><span class="line">out：该参数可以作为输出，也就是该参数可以作为返回值</span><br><span class="line">inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</span><br><span class="line"></span><br><span class="line">2、如果存储过程体仅仅只有一句话，begin end可以省略</span><br><span class="line">存储过程体中的每条sql语句的结尾要求必须加分号。</span><br><span class="line">存储过程的结尾可以使用 delimiter 重新设置</span><br><span class="line">语法：</span><br><span class="line">delimiter 结束标记</span><br><span class="line">案例：</span><br><span class="line">delimiter $</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 二、调用语法</span><br><span class="line">CALL 存储过程名(实参列表);</span><br><span class="line"></span><br><span class="line">#----------------------案例演示-------------------------</span><br><span class="line"># 1.空参列表</span><br><span class="line">#案例：插入到admin表中五条记录</span><br><span class="line">SELECT * FROM admin;</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">	INSERT INTO admin(username,&#96;password&#96;) </span><br><span class="line">	VALUES(&#39;john1&#39;,&#39;0000&#39;),(&#39;lily&#39;,&#39;0000&#39;),(&#39;rose&#39;,&#39;0000&#39;),(&#39;jack&#39;,&#39;0000&#39;),(&#39;tom&#39;,&#39;0000&#39;);</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">CALL myp1()$</span><br><span class="line"></span><br><span class="line"># 2.创建带in模式参数的存储过程</span><br><span class="line">#案例1：创建存储过程实现 根据女神名，查询对应的男神信息</span><br><span class="line">CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT bo.*</span><br><span class="line">	FROM boys bo</span><br><span class="line">	RIGHT JOIN beauty b ON bo.id &#x3D; b.boyfriend_id</span><br><span class="line">	WHERE b.name&#x3D;beautyName;</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">CALL myp2(&#39;柳岩&#39;)$</span><br><span class="line">#案例2 ：创建存储过程实现，用户是否登录成功</span><br><span class="line">CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">	SELECT COUNT(*) INTO result#赋值</span><br><span class="line">	FROM admin</span><br><span class="line">	WHERE admin.username &#x3D; username</span><br><span class="line">	AND admin.password &#x3D; PASSWORD;</span><br><span class="line">	</span><br><span class="line">	SELECT IF(result&gt;0,&#39;成功&#39;,&#39;失败&#39;);#使用</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">CALL myp3(&#39;张飞&#39;,&#39;8888&#39;)$</span><br><span class="line"></span><br><span class="line"># 3.创建out 模式参数的存储过程</span><br><span class="line">#案例1：根据输入的女神名，返回对应的男神名</span><br><span class="line">CREATE PROCEDURE myp6(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT bo.boyname INTO boyname</span><br><span class="line">	FROM boys bo</span><br><span class="line">	RIGHT JOIN</span><br><span class="line">	beauty b ON b.boyfriend_id &#x3D; bo.id</span><br><span class="line">	WHERE b.name&#x3D;beautyName ;</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&#39;小昭&#39;, @name)$</span><br><span class="line">SELECT @name$</span><br><span class="line">#案例2：根据输入的女神名，返回对应的男神名和魅力值</span><br><span class="line">CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">	FROM boys </span><br><span class="line">	RIGHT JOIN</span><br><span class="line">	beauty b ON b.boyfriend_id &#x3D; boys.id</span><br><span class="line">	WHERE b.name&#x3D;beautyName ;</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&#39;小昭&#39;, @name, @cp)$</span><br><span class="line">SELECT @name,@cp$</span><br><span class="line"></span><br><span class="line"># 4.创建带inout模式参数的存储过程</span><br><span class="line">#案例1：传入a和b两个值，最终a和b都翻倍并返回</span><br><span class="line">CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line">	SET a&#x3D;a*2;</span><br><span class="line">	SET b&#x3D;b*2;</span><br><span class="line">END $</span><br><span class="line">#调用</span><br><span class="line">SET @m&#x3D;10$</span><br><span class="line">SET @n&#x3D;20$</span><br><span class="line">CALL myp8(@m,@n)$</span><br><span class="line">SELECT @m,@n$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三、删除存储过程</span><br><span class="line">#语法：drop procedure 存储过程名</span><br><span class="line">DROP PROCEDURE p1;</span><br><span class="line">DROP PROCEDURE p2,p3;#×</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 四、查看存储过程的信息</span><br><span class="line">DESC myp2; # 不可以</span><br><span class="line">SHOW CREATE PROCEDURE  myp2;</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><strong>函数</strong></li>
</ol>
</blockquote>
<p><strong>含义</strong>：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p>
<p><strong>区别</strong>：</p>
<p>存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新<br>函数：有且仅有1 个返回，适合做处理数据后返回一个结果</p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"># 一、创建语法</span><br><span class="line">CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型</span><br><span class="line">BEGIN</span><br><span class="line">	函数体</span><br><span class="line">END</span><br><span class="line">&#x2F;*</span><br><span class="line">注意：</span><br><span class="line">1.参数列表 包含两部分：</span><br><span class="line">参数名 参数类型</span><br><span class="line">2.函数体：</span><br><span class="line">肯定会有return语句，如果没有会报错</span><br><span class="line">如果return语句没有放在函数体的最后也不报错，但不建议</span><br><span class="line">	return 值;</span><br><span class="line">3.函数体中仅有一句话，则可以省略begin end</span><br><span class="line">4.使用 delimiter语句设置结束标记</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#二、调用语法</span><br><span class="line">SELECT 函数名(参数列表)</span><br><span class="line"></span><br><span class="line">#-----------------案例演示-------------------</span><br><span class="line"># 1.无参有返回</span><br><span class="line">#案例：返回公司的员工个数</span><br><span class="line">CREATE FUNCTION myf1() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE c INT DEFAULT 0;#定义局部变量</span><br><span class="line">	SELECT COUNT(*) INTO c#赋值</span><br><span class="line">	FROM employees;</span><br><span class="line">	RETURN c;</span><br><span class="line">END $</span><br><span class="line">SELECT myf1()$</span><br><span class="line"></span><br><span class="line"># 2.有参有返回</span><br><span class="line"># 案例1：根据员工名，返回它的工资</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	SET @sal&#x3D;0;#定义用户变量 </span><br><span class="line">	SELECT salary INTO @sal   #赋值</span><br><span class="line">	FROM employees</span><br><span class="line">	WHERE last_name &#x3D; empName;</span><br><span class="line">	RETURN @sal;</span><br><span class="line">END $</span><br><span class="line">SELECT myf2(&#39;k_ing&#39;) $</span><br><span class="line"># 案例2：根据部门名，返回该部门的平均工资</span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE sal DOUBLE ;</span><br><span class="line">	SELECT AVG(salary) INTO sal</span><br><span class="line">	FROM employees e</span><br><span class="line">	JOIN departments d ON e.department_id &#x3D; d.department_id</span><br><span class="line">	WHERE d.department_name&#x3D;deptName;</span><br><span class="line">	RETURN sal;</span><br><span class="line">END $</span><br><span class="line">SELECT myf3(&#39;IT&#39;)$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#三、查看函数</span><br><span class="line">SHOW CREATE FUNCTION myf3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#四、删除函数</span><br><span class="line">DROP FUNCTION myf3;</span><br><span class="line"></span><br><span class="line"># 案例: 创建函数，实现传入两个float，返回二者之和</span><br><span class="line">CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE SUM FLOAT DEFAULT 0;</span><br><span class="line">	SET SUM&#x3D;num1+num2;</span><br><span class="line">	RETURN SUM;</span><br><span class="line">END $</span><br><span class="line">SELECT test_fun1(1,2)$</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<h3 id="6-4-流程控制结构"><a href="#6-4-流程控制结构" class="headerlink" title="6.4 流程控制结构"></a>6.4 流程控制结构</h3><p>顺序、分支、循环</p>
<blockquote>
<ol>
<li>分支结构</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 1.if函数</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：if(条件,值1，值2)</span><br><span class="line">功能：实现双分支</span><br><span class="line">应用在begin end中或外面</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"># 2.case结构</span><br><span class="line">&#x2F;*</span><br><span class="line">语法：</span><br><span class="line">情况1：类似于switch</span><br><span class="line">case 变量或表达式</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end </span><br><span class="line">情况2：</span><br><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end </span><br><span class="line">- 应用在begin end 中或外面</span><br><span class="line">如果放在begin end 外面，作为表达式结合着其他语句使用</span><br><span class="line">如果放在begin end 里面，一般作为独立的语句使用</span><br><span class="line">- else语句可以省略，如果else省略了，全部when都不满足，则返回null</span><br><span class="line"></span><br><span class="line"># 3.if结构</span><br><span class="line">语法：</span><br><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">....</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br><span class="line">功能：类似于多重if</span><br><span class="line">只能应用在begin end 中</span><br><span class="line">Copy</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>循环结构</li>
</ol>
</blockquote>
<p><strong>分类</strong>：<br>while、loop、repeat</p>
<p><strong>循环控制</strong>：</p>
<p>iterate 【标签】 类似于 continue，继续，结束本次循环，继续下一次<br>leave 【标签】 类似于 break，跳出，结束当前所在的循环</p>
<p><strong>语法</strong>：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E5%9F%BA%E7%A1%80_1_%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png"><img src="https://cdn.jsdelivr.net/gh/LihengXu/mycdn/img/MySQL%E5%9F%BA%E7%A1%80_1_%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="img"></a></p>
<p><strong>示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#1.没有添加循环控制语句</span><br><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line">DROP PROCEDURE pro_while1$</span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	WHILE i&lt;&#x3D;insertCount DO</span><br><span class="line">		INSERT INTO admin(username,&#96;password&#96;) VALUES(CONCAT(&#39;Rose&#39;,i),&#39;666&#39;);</span><br><span class="line">		SET i&#x3D;i+1;</span><br><span class="line">	END WHILE;</span><br><span class="line">END $</span><br><span class="line">CALL pro_while1(100)$</span><br><span class="line"></span><br><span class="line">#2.添加leave语句</span><br><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</span><br><span class="line">TRUNCATE TABLE admin$</span><br><span class="line">DROP PROCEDURE test_while1$</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 1;</span><br><span class="line">	a:WHILE i&lt;&#x3D;insertCount DO</span><br><span class="line">		INSERT INTO admin(username,&#96;password&#96;)</span><br><span class="line">		VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);</span><br><span class="line">		IF i&gt;&#x3D;20 THEN LEAVE a;</span><br><span class="line">		END IF;</span><br><span class="line">		SET i&#x3D;i+1;</span><br><span class="line">	END WHILE a;</span><br><span class="line">END $</span><br><span class="line">CALL test_while1(100)$</span><br><span class="line"></span><br><span class="line">#3.添加iterate语句</span><br><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span><br><span class="line">TRUNCATE TABLE admin$</span><br><span class="line">DROP PROCEDURE test_while1$</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	a:WHILE i&lt;&#x3D;insertCount DO</span><br><span class="line">		SET i&#x3D;i+1;</span><br><span class="line">		IF MOD(i,2)!&#x3D;0 THEN ITERATE a;</span><br><span class="line">		END IF;</span><br><span class="line"></span><br><span class="line">		INSERT INTO admin(username,&#96;password&#96;)</span><br><span class="line">		VALUES(CONCAT(&#39;xiaohua&#39;,i),&#39;0000&#39;);	</span><br><span class="line">	END WHILE a;</span><br><span class="line">END $</span><br><span class="line">CALL test_while1(100)$</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/MySQL%E5%9F%BA%E7%A1%80/" data-id="ckqujm00i000cc4ubagps5sqm" data-title="MySQL基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/06/25/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2021/05/23/%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/">问题整理</a>
          </li>
        
          <li>
            <a href="/2021/05/17/rabbitmq/">rabbitmq</a>
          </li>
        
          <li>
            <a href="/2021/04/26/%E5%AD%97%E8%8A%82%E5%AE%9E%E4%B9%A0/">字节实习</a>
          </li>
        
          <li>
            <a href="/2021/04/18/jvm%E5%AD%A6%E4%B9%A0/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>